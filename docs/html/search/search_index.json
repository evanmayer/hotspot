{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This repo contains code that is a part of the TIME collaboration . Logo by Guochao (Jason) Sun. hotspot Code for simulating and driving a cable-driven parallel robot for mapping beams on surfaces. Running Run python main.py -h for the docstring describing the command line interface. You will be prompted to enter the position of the centroid of the end effector (raft), then the robot will await a command. Choices are described onscreen. Example python main.py ./data/input/geometry/frame.csv ./data/input/profiles/circle.csv Dependencies Creating a conda environment I use miniconda to keep my development environments separate. If there is a .yml file available that lists the dependencies I need, I run conda env create -f <filename>.yml to use it to make a new conda env with those dependencies. Conda parses the contents, creates a new env with the given name, and installs the required packages. Updating .yml as new dependencies are needed I periodically use conda env export --from-history | tee hotspot.yml to dump whatever I've manually installed so far into the .yml. This avoids specifying exact versions of packages, but will still try to install all the packages needed. To update the environment as changes are made to hotspot.yml , run conda env update --name hotspot --file hotspot.yml --prune LabJack libraries Driving Hawkeye sources with LabJack modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack, and the hotspot.yml file will handle the Python install via pip . Contributing Testing Testing is accomplished with pytest . Passing tests are a prerequisite for committing code, and new code should come with new tests. To run the test suite defined in the tests dir, change dir to the toplevel dir of the repo and execute pytest Pushing changes If you need push permissions, message me. Otherwise, you may fork, create a new branch with your changes, and fill out a Pull Request to have the changes reviewed and merged in. How did you make your algorithm flowcharts? diagrams.net","title":"Home"},{"location":"#hotspot","text":"Code for simulating and driving a cable-driven parallel robot for mapping beams on surfaces.","title":"hotspot"},{"location":"#running","text":"Run python main.py -h for the docstring describing the command line interface. You will be prompted to enter the position of the centroid of the end effector (raft), then the robot will await a command. Choices are described onscreen.","title":"Running"},{"location":"#example","text":"python main.py ./data/input/geometry/frame.csv ./data/input/profiles/circle.csv","title":"Example"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#creating-a-conda-environment","text":"I use miniconda to keep my development environments separate. If there is a .yml file available that lists the dependencies I need, I run conda env create -f <filename>.yml to use it to make a new conda env with those dependencies. Conda parses the contents, creates a new env with the given name, and installs the required packages.","title":"Creating a conda environment"},{"location":"#updating-yml-as-new-dependencies-are-needed","text":"I periodically use conda env export --from-history | tee hotspot.yml to dump whatever I've manually installed so far into the .yml. This avoids specifying exact versions of packages, but will still try to install all the packages needed. To update the environment as changes are made to hotspot.yml , run conda env update --name hotspot --file hotspot.yml --prune","title":"Updating .yml as new dependencies are needed"},{"location":"#labjack-libraries","text":"Driving Hawkeye sources with LabJack modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack, and the hotspot.yml file will handle the Python install via pip .","title":"LabJack libraries"},{"location":"#contributing","text":"","title":"Contributing"},{"location":"#testing","text":"Testing is accomplished with pytest . Passing tests are a prerequisite for committing code, and new code should come with new tests. To run the test suite defined in the tests dir, change dir to the toplevel dir of the repo and execute pytest","title":"Testing"},{"location":"#pushing-changes","text":"If you need push permissions, message me. Otherwise, you may fork, create a new branch with your changes, and fill out a Pull Request to have the changes reviewed and merged in.","title":"Pushing changes"},{"location":"#how-did-you-make-your-algorithm-flowcharts","text":"diagrams.net","title":"How did you make your algorithm flowcharts?"},{"location":"HOWTO/","text":"How To This doc contains instructions for various tasks related to setting up and running the beam mapper. Setting Up the Environment First, check that the environment setup has not been done before. If conda activate hotspot succeeds, skip these steps. Python Dependencies Anaconda If the Python environment/package manager Anaconda does not exist on the Raspberry Pi you're running this on, I recommend installing Miniconda like this: curl \"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-armv7l.sh\" -o \"Miniconda.sh\" chmod +x Miniconda.sh ./Miniconda.sh Once that is done, we are ready to set up the hotspot environment. conda allows specifying the packages needed in a file with a .yml extension. This is done for you. Create the hotspot conda env with conda env create -f hotspot.yml It should install things like numpy and matplotlib , as well as libraries for the hardware, such as Adafruit's adafruit-circuitpython-motorkit library for driving the steppers, and the labjack-ljm library for controlling the Hawkeye IR sources via the LabJack. However, driving Hawkeye sources with LabJack Python modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack. Once that is done, activate the env with conda activate hotspot Keeping things up to date If you need to install something else, remember to update hotspot.yml by doing conda env export --from-history | tee hotspot.yml If your hotspot.yml has been updated, and you need to update your env with the new hotspot.yml , do conda env update --file hotspot.yml --prune Software Testing with pytest In order to verify that basic low-level functionality is unbroken, run pytest from the toplevel directory. Setting Up the Hardware Enable Raspberry Pi Hardware The raspberry pi should have at least two motor driver hat boards . These are PCBs with onboard chips that talk to the raspberry pi on an I2C bus via the 2x20 header pins. They issue commands to the motor driver chips, which handle the delivery and timing of greater voltage and current than the raspberry pi is capable of on its own. Follow the steps for Enabling I2C communication from Adafruit. A backup pdf is saved in the pdf dir. Power Motors The motor driver board must be powered via its own power supply, since the raspberry pi cannot provide the requisite voltage or current. A lab power supply with 12V output is attached to the +/- screw terminal block on the motor driver hat. For stacking multiple hats, jumpers are attached to the screw terminals to route +/- voltage to the additional hats. The motor controllers on each hat are designed to run with 5-12V, with a maximum instantaneous current of ~1.2A. LabJack The LabJack board also needs its own power supply to drive the voltage/current that is switched via the breakout board. A tunable lab power supply is attached to one of the screw terminals labeled \"VS#,\" for \"voltage source #,\" where # is one of the channels, 1-6. The voltage of this power supply will depend on what is hooked up to the switchable terminals. If you are using LEDs to stand in for Hawkeye IR sources (e.g. for testing), 3.3V is fine. The Hawkeye IR50 source temperature depends on the voltage applied, and the current draw depends on the voltage (see datasheet in pdf dir). The design target temperature is 750 C, requiring a voltage of 6.7 V and acurrent of ~134 mA per source, for a total current draw of ~1.74 A when all sources are turned on. The power supply must be able to meet these requirements. Communication Raspberry Pi You can log in to the raspberry pi via ssh . In order for your computer to \"see\" the raspberry pi, though, they must be on the same network. This can be accomplished a few ways (or order of ease of use): 1. By connecting both computers to a router or network switch that can assign each connected device an IP address automatically. Wired is easier than wireless . 1. By connecting directly to the pi via an Ethernet patch cable and setting up a link-local connection 1. By connecting directly to the pi via an Ethernet patch cable and assigning static IP addresses to each host. The first option is the easiest, but depends on having access to an exisiting network, so limits your connectivity options. If you have access to a Linux machine, the second option is about as easy and more flexible, in my opinion. The hostname and password are printed on the bottom of the white plastic case. Once connection is sorted out, ping the pi to make sure: bash ping timepi.local The ssh command goes like this: bash ssh -X pi@timepi.local -X allows X-forwarding, in case a graphical application (like plotting) is invoked. You will be prompted for a password, which you can find printed on the bottom of the white plastic raspberry pi case. Motors Motors should be connected to the screw terminals of the pi's stepper hat like this: Getting the order right ensures the stepper's coils are energized in the correct sequence to get it to rotate. The stepper motors have NEMA-17 spec hole patterns, which mate to the 3D printed CFRP motor mount brackets which we will attach to the beam mapper frame. Each stepper should be attached to its motor mount using M3 x 0.5 x 10mm screws. Use lubricant, because metal on CFRP will be squeaky. At this point, it is important to consider mapping of motor HAT terminal -> stepper motor -> motor mount -> corner of beam mapper frame. The Executive.__init__() function specifies this mapping, so the motor installation location and stepper instance in __init__() should match, to ensure the correct motor commands are sent to the correct stepper. In general, the HAT closest to the Pi will be kit0 (although this can be double-checked by looking at the address - 0x60 is the default I2C address for the hat, which can be changed by bridging the HAT pads A0-A4, so the board addressed by 0x60 will have no pads bridged). The terminal blocks M1-M2 are used for stepper1 on each HAT, and M3-M4 are used for stepper2 . It doesn't matter which terminal maps to which corner, only that the code and physical arrangement agree. Spools The spools are each attached to the 5mm stepper motor shaft via one M3 setscrew. The fishing line is affixed to the each spool by wrapping it around the setscrew and screwing it in to the threaded recess on the spool circumference. Positive motor rotation is defined by convention to spin the shaft clockwise when viewed from the rear of the motor. Motors should be oriented relative to the cable such that a positive motor rotation produces a positive cable length change (i.e., cable is played out from the spool), and a negative motor rotation winds cable onto the spool. After attaching the cables to the spools, the other end should be routed through the ~.9mm hole in the motor mount bracket. Finally, excess cable should be wound onto the spool, under tension, to avoid trapping excess cable underneath as the cable is wound on. This process can be done by hand. Raft The end effector of this robot is a rectangular raft carrying several Hawkeye Technologies IR-50 emitters. The robot drives the centroid of the effector to a specified position, and the control algorithm performs a specific sequence of flashes using a number of the emitters to enhance the detectability of the signal in the TIME receiver output data. The effector is attached to the cables by simply passing them through the raft's eyelets, wrapping ends of the fishing line around the screws in each corner of the raft, and screwing them down. Frame The 3D printed CFRP stepper motor mounts are attached to the beam mapper frame by 5/16-18 x 2\" or 2.25\" bolts with nyloc \"jam\" nuts. A 3D printed CFRP \"homing bar\" with a corner reference feature sticks out into the mapping region to provide a repeatable location for placing the corner of the effector raft. This part is attached to the beam mapper frame with one 5/16-18 x 2\" or 2.25\" bolt with nyloc \"jam\" nut. Ensure the arm is pressed flat against the inside of the frame, no matter where it is attached. Two aluminum registration tabs are screwed into the end of each frame piece opposite the black plastic end caps, using a 5/16-18 x 1/4\" screw. They are long enough to reach an edge of the mirror regardless of if the mirror's corners have been machined off. These tabs register the frame to a third edge of the mirror, so it is important that they not be bent . Long 5/16-18 steel threaded rods connect the two halves of the frame. On one end of the threaded rods, a nyloc \"jam\" nut on the outside of the perforated aluminum extrusion provides clamping force. On the other end of the threaded rod, a slide-adjust nut allows easily changing the distance between clamping surfaces, and applies clamping force to the outside of the opposite aluminum extrusion. When all of these pieces are attached to the frame, it is ready to install onto a mirror for mapping. The frame should be opened wide enough to allow it to fit over a mirror, then clamped down to register against two opposite faces. Physical Installation and Input File Creation Coordinate System In order for the raft to be moved to a meaningful position in mirror-space, coordinates must be referenced to sensible locations where the mirror edges and robot frame register to one another. The x-axis is in the plane of contact between the \"south\" frame and an edge of the mirror. The y-axis is in the contact plane between the side aluminum registration tab and a perpendicular mirror edge. The coordinate system of the robot therefore has its origin at the SW corner, where the aluminum alignment tab on the fixed frame meets the aluminum extrusion face. Input Files There are two types of input files: geometry and profile. Geometry Geometry files are one-line .csv files in hotspot/data/input/geometry . Each one defines the physical setup of the robot when it is in a certain configuration, for instance, when it is installed on a mirror of a certain dimension. Each column entry describes an aspect of the physical setup of the system. For example: sw_0 sw_1 nw_0 nw_1 se_0 se_1 ne_0 ne_1 w h 0 0 0 1 1 0 1 1 .1 .1 Each corner point is the location of an eyelet through which the cable passes. The width and height of the raft are defined by the separations between eyelets on the raft, through which the cable passes. Profile The profile files are multi-line .csv files in hotspot/data/input/profiles . Each one defines a new position to which the robot should move, in the coordinate system defined above. Upon reaching each location in the profile, the robot is programmed to flash Hawkeye sources on and off (default: 10 \"on\" states, 50% duty cycle, 5 Hz), and which sources are enabled are configurable with the flasher_cmds column in the profile .csv. Each 0 or 1, space-separated, in the first column, corresponds to one of twelve addressable solid state switchable voltage sources on the LabJack PS12DC Power Switching Board. The index to address mapping is defined in the dictionary at the top of hardware.py . Since there are 3 groups of Hawkeye sources, there are more addressable relays than strictly necessary. For example, to move to a single coordinate and flash all addresses: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 1 1 1 1 1 1 1 1 1 .5 .5 to move to a single coordinate and flash only the center Hawkeye: flasher_cmds pos_cmd_0s pos_cmd_1s 1 0 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash the center and inner ring Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash all Hawkeyes (center, inner ring, outer ring): flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 0 0 0 0 0 0 0 0 0 .5 .5 Building up a sequence of moves allows a grid or shape to be scanned. Input File Creation Since the dimensions of the motor mounts have been measured relative to each edge, the positions of the corner eyelets can be calculated, given the separation between the movable and fixed frame faces. The eyelets of the motor mounts measured $6.19 \\pm 0.5$ mm from the frame to the face of the motor mount, and $7.96 \\pm 0.02$ mm from the face of the motor mount to the eyelet, for a total eyelet offset from the contact patch of $0.014 \\pm 0.001$ m. This value will be used to calculate eyelet y-positions as a function of frame separation. The eyelet positions should not change in the x-direction, unless the motor mounts are removed from the aluminum frames. The final piece of information needed for the robot to move is the initial position, the home position. The installed position of the corner feature on the underside of the homing bar is measured, so that when the raft is nested in the corner feature, a repeatable and known raft centroid position is acheived. The homed centroid position is entered at the command line when prompted. Example Geometry Calculation This is an example of the measurements needed to create a geoemtry file. Actual values listed here should not be used unless they have been verified against actual hardware, as raft and endpoint dimensions could have changed due to hardware revisions. For a benchtop test, the frame separation is $0.392 \\pm 0.001$ m, so the north side y-coordinates are $0.392 - 0.014 = 0.378$ m. Feature X Y SE 0.528 +/- 0.001 0.014 +/- 0.001 SW 0.057 +/- 0.001 0.014 +/- 0.001 NE 0.528 +/- 0.001 0.378 +/- 0.001 NW 0.057 +/- 0.001 0.378 +/- 0.001 Homing feature corner 0.155 +/- 0.001 0.151 +/- 0.001 The dimensions of the raft attachment points were measured. These distances are the distances between the points on the raft where the cables exit the eyelets. The eyelets themselves were located $1.2$ mm from each edge of the raft. This modifies the effective position of the homing feature by $(+0.001, +0.001)$ m. Raft width: $0.045 \\pm 0.001$ m Raft height: $0.040 \\pm 0.001$ m Together, the location of the raft centroid when it is nested at the HOME location: $r = (0.156 + 0.045/2, 0.152 - 0.040/2)$ Therefore, the input file for this shape would read: Input Loc. X Y SE 0.528 0.014 SW 0.057 0.014 NE 0.528 0.378 NW 0.057 0.378 RAFT 0.045 0.040 And when prompted for the raft's position during home calibration: Input Loc. X Y HOME 0.179 0.172 Operation When a surface geometry file has been created and the profile for the given shape to be mapped is generated, we are ready to run the program. Pre-mapping checks Make sure that 12 V is being supplied to both motor driver boards in the stack, that the polarity is correct, and that the power supply output is on. Make sure that the cable is wound onto each spool and that no loops of excess cable are trapped underneath the cable wound onto the spools. Check the excess cable played out in the raft's current position. Some excess is fine as long as it doesn't interfere with the raft's motion. If the cable is taut before homing, this is also fine, but the homing routine may need to be run a few times before the raft reaches the home position. Ensure the Hawkeye source signal lines won't interfere with raft operation. Ensure the hotspot conda env is active. Mapping Start the program with python main.py ./data/input/geometry/<geometry.csv> ./data/input/profiles/<profile.csv> Perform a homing calibration: c , RETURN key. The NW motor will drive the raft to the NW corner while the NE, SW, SE axes go slack, and begin skipping steps after reaching the limit. This (and some noise) is normal. Verify that the raft reached its home against the NW corner, and that the other axes achieved tension. If not, GOTO 2. Perform a mapping sequence: s , RETURN key. The raft will drive to each location and flash the Hawkeyes at each point in the sequence. Before beginning each move, the axes will back off tension to avoid skipping steps, and should re-tension upon arrival. You may request a mode change at any time. Mode changes are processed at the end of each move. Upon completing a sequence, it may be repeated by changing to any other mode and requesting the sequence mode again. Example Call Graph Without motors or LabJack attached, so does not include overhead of those libraries. Module Flow Charts Executive Documentation Reference HTML The html documentation of the source code and Markdown materials is generated by portray . To regenerate the documentation, execute: portray as_html -m hotspot -o docs/html/ --overwrite pycallgraph To re-generate the call graph image, directory, run pycallgraph -i \"alg*\" -i \"const*\" -i \"exec*\" -i \"hardw*\" -i \"hot*\" -i \"hw*\" -i \"tele*\" graphviz --output-file = ../doc/img/pycallgraph.png -- main.py ../data/input/geometry/frame.csv ../data/input/profiles/box_frame.csv You must have graphviz installed using your operating system's package manager. For most accurate graph and timing information, do this with all peripheral hardware attached, so the call graphs include interfacing with the motor drivers and LabJack. Test Fixture Setup For testing the software and hardware together, we set up the raspberry pi and the steppers on an optics bench in Steward Observatory Lab 168. This allows us to affix the steppers to something a roughly known distance apart. This was done to allow testing of the algorithms while the frame was in development. Stepper Fixture Steppers are attached to the optics bench for testing via 3D-printed brackets. 1/4-20 socket head cap screws affix the bracket to the bench, and M3 screws affix the steppers to the brackets. Fishing line routing On the optics bench, the fishing line was routed from the motor spools to the raft via 3D printed posts, forming 4 corners of a rectangle to emulate the operational configuration. These posts were 3D printed 1/4-20 screws in PETG plastic, with ~.9mm (as designed, not as printed) holes in the top to allow routing the fishing line through. Test raft For testing purposes, the raft was another 3D printed part, a rectangular plastic coupon with four holes to accept M3 screws for tying down the ends of the fishing line a known distance apart. This was done in lieu of having a raft of Hawkeye sources ready.","title":"Howto"},{"location":"HOWTO/#how-to","text":"This doc contains instructions for various tasks related to setting up and running the beam mapper.","title":"How To"},{"location":"HOWTO/#setting-up-the-environment","text":"First, check that the environment setup has not been done before. If conda activate hotspot succeeds, skip these steps.","title":"Setting Up the Environment"},{"location":"HOWTO/#python-dependencies","text":"","title":"Python Dependencies"},{"location":"HOWTO/#anaconda","text":"If the Python environment/package manager Anaconda does not exist on the Raspberry Pi you're running this on, I recommend installing Miniconda like this: curl \"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-armv7l.sh\" -o \"Miniconda.sh\" chmod +x Miniconda.sh ./Miniconda.sh Once that is done, we are ready to set up the hotspot environment. conda allows specifying the packages needed in a file with a .yml extension. This is done for you. Create the hotspot conda env with conda env create -f hotspot.yml It should install things like numpy and matplotlib , as well as libraries for the hardware, such as Adafruit's adafruit-circuitpython-motorkit library for driving the steppers, and the labjack-ljm library for controlling the Hawkeye IR sources via the LabJack. However, driving Hawkeye sources with LabJack Python modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack. Once that is done, activate the env with conda activate hotspot","title":"Anaconda"},{"location":"HOWTO/#keeping-things-up-to-date","text":"If you need to install something else, remember to update hotspot.yml by doing conda env export --from-history | tee hotspot.yml If your hotspot.yml has been updated, and you need to update your env with the new hotspot.yml , do conda env update --file hotspot.yml --prune","title":"Keeping things up to date"},{"location":"HOWTO/#software-testing-with-pytest","text":"In order to verify that basic low-level functionality is unbroken, run pytest from the toplevel directory.","title":"Software Testing with pytest"},{"location":"HOWTO/#setting-up-the-hardware","text":"","title":"Setting Up the Hardware"},{"location":"HOWTO/#enable-raspberry-pi-hardware","text":"The raspberry pi should have at least two motor driver hat boards . These are PCBs with onboard chips that talk to the raspberry pi on an I2C bus via the 2x20 header pins. They issue commands to the motor driver chips, which handle the delivery and timing of greater voltage and current than the raspberry pi is capable of on its own. Follow the steps for Enabling I2C communication from Adafruit. A backup pdf is saved in the pdf dir.","title":"Enable Raspberry Pi Hardware"},{"location":"HOWTO/#power","text":"","title":"Power"},{"location":"HOWTO/#motors","text":"The motor driver board must be powered via its own power supply, since the raspberry pi cannot provide the requisite voltage or current. A lab power supply with 12V output is attached to the +/- screw terminal block on the motor driver hat. For stacking multiple hats, jumpers are attached to the screw terminals to route +/- voltage to the additional hats. The motor controllers on each hat are designed to run with 5-12V, with a maximum instantaneous current of ~1.2A.","title":"Motors"},{"location":"HOWTO/#labjack","text":"The LabJack board also needs its own power supply to drive the voltage/current that is switched via the breakout board. A tunable lab power supply is attached to one of the screw terminals labeled \"VS#,\" for \"voltage source #,\" where # is one of the channels, 1-6. The voltage of this power supply will depend on what is hooked up to the switchable terminals. If you are using LEDs to stand in for Hawkeye IR sources (e.g. for testing), 3.3V is fine. The Hawkeye IR50 source temperature depends on the voltage applied, and the current draw depends on the voltage (see datasheet in pdf dir). The design target temperature is 750 C, requiring a voltage of 6.7 V and acurrent of ~134 mA per source, for a total current draw of ~1.74 A when all sources are turned on. The power supply must be able to meet these requirements.","title":"LabJack"},{"location":"HOWTO/#communication","text":"","title":"Communication"},{"location":"HOWTO/#raspberry-pi","text":"You can log in to the raspberry pi via ssh . In order for your computer to \"see\" the raspberry pi, though, they must be on the same network. This can be accomplished a few ways (or order of ease of use): 1. By connecting both computers to a router or network switch that can assign each connected device an IP address automatically. Wired is easier than wireless . 1. By connecting directly to the pi via an Ethernet patch cable and setting up a link-local connection 1. By connecting directly to the pi via an Ethernet patch cable and assigning static IP addresses to each host. The first option is the easiest, but depends on having access to an exisiting network, so limits your connectivity options. If you have access to a Linux machine, the second option is about as easy and more flexible, in my opinion. The hostname and password are printed on the bottom of the white plastic case. Once connection is sorted out, ping the pi to make sure: bash ping timepi.local The ssh command goes like this: bash ssh -X pi@timepi.local -X allows X-forwarding, in case a graphical application (like plotting) is invoked. You will be prompted for a password, which you can find printed on the bottom of the white plastic raspberry pi case.","title":"Raspberry Pi"},{"location":"HOWTO/#motors_1","text":"Motors should be connected to the screw terminals of the pi's stepper hat like this: Getting the order right ensures the stepper's coils are energized in the correct sequence to get it to rotate. The stepper motors have NEMA-17 spec hole patterns, which mate to the 3D printed CFRP motor mount brackets which we will attach to the beam mapper frame. Each stepper should be attached to its motor mount using M3 x 0.5 x 10mm screws. Use lubricant, because metal on CFRP will be squeaky. At this point, it is important to consider mapping of motor HAT terminal -> stepper motor -> motor mount -> corner of beam mapper frame. The Executive.__init__() function specifies this mapping, so the motor installation location and stepper instance in __init__() should match, to ensure the correct motor commands are sent to the correct stepper. In general, the HAT closest to the Pi will be kit0 (although this can be double-checked by looking at the address - 0x60 is the default I2C address for the hat, which can be changed by bridging the HAT pads A0-A4, so the board addressed by 0x60 will have no pads bridged). The terminal blocks M1-M2 are used for stepper1 on each HAT, and M3-M4 are used for stepper2 . It doesn't matter which terminal maps to which corner, only that the code and physical arrangement agree.","title":"Motors"},{"location":"HOWTO/#spools","text":"The spools are each attached to the 5mm stepper motor shaft via one M3 setscrew. The fishing line is affixed to the each spool by wrapping it around the setscrew and screwing it in to the threaded recess on the spool circumference. Positive motor rotation is defined by convention to spin the shaft clockwise when viewed from the rear of the motor. Motors should be oriented relative to the cable such that a positive motor rotation produces a positive cable length change (i.e., cable is played out from the spool), and a negative motor rotation winds cable onto the spool. After attaching the cables to the spools, the other end should be routed through the ~.9mm hole in the motor mount bracket. Finally, excess cable should be wound onto the spool, under tension, to avoid trapping excess cable underneath as the cable is wound on. This process can be done by hand.","title":"Spools"},{"location":"HOWTO/#raft","text":"The end effector of this robot is a rectangular raft carrying several Hawkeye Technologies IR-50 emitters. The robot drives the centroid of the effector to a specified position, and the control algorithm performs a specific sequence of flashes using a number of the emitters to enhance the detectability of the signal in the TIME receiver output data. The effector is attached to the cables by simply passing them through the raft's eyelets, wrapping ends of the fishing line around the screws in each corner of the raft, and screwing them down.","title":"Raft"},{"location":"HOWTO/#frame","text":"The 3D printed CFRP stepper motor mounts are attached to the beam mapper frame by 5/16-18 x 2\" or 2.25\" bolts with nyloc \"jam\" nuts. A 3D printed CFRP \"homing bar\" with a corner reference feature sticks out into the mapping region to provide a repeatable location for placing the corner of the effector raft. This part is attached to the beam mapper frame with one 5/16-18 x 2\" or 2.25\" bolt with nyloc \"jam\" nut. Ensure the arm is pressed flat against the inside of the frame, no matter where it is attached. Two aluminum registration tabs are screwed into the end of each frame piece opposite the black plastic end caps, using a 5/16-18 x 1/4\" screw. They are long enough to reach an edge of the mirror regardless of if the mirror's corners have been machined off. These tabs register the frame to a third edge of the mirror, so it is important that they not be bent . Long 5/16-18 steel threaded rods connect the two halves of the frame. On one end of the threaded rods, a nyloc \"jam\" nut on the outside of the perforated aluminum extrusion provides clamping force. On the other end of the threaded rod, a slide-adjust nut allows easily changing the distance between clamping surfaces, and applies clamping force to the outside of the opposite aluminum extrusion. When all of these pieces are attached to the frame, it is ready to install onto a mirror for mapping. The frame should be opened wide enough to allow it to fit over a mirror, then clamped down to register against two opposite faces.","title":"Frame"},{"location":"HOWTO/#physical-installation-and-input-file-creation","text":"","title":"Physical Installation and Input File Creation"},{"location":"HOWTO/#coordinate-system","text":"In order for the raft to be moved to a meaningful position in mirror-space, coordinates must be referenced to sensible locations where the mirror edges and robot frame register to one another. The x-axis is in the plane of contact between the \"south\" frame and an edge of the mirror. The y-axis is in the contact plane between the side aluminum registration tab and a perpendicular mirror edge. The coordinate system of the robot therefore has its origin at the SW corner, where the aluminum alignment tab on the fixed frame meets the aluminum extrusion face.","title":"Coordinate System"},{"location":"HOWTO/#input-files","text":"There are two types of input files: geometry and profile.","title":"Input Files"},{"location":"HOWTO/#geometry","text":"Geometry files are one-line .csv files in hotspot/data/input/geometry . Each one defines the physical setup of the robot when it is in a certain configuration, for instance, when it is installed on a mirror of a certain dimension. Each column entry describes an aspect of the physical setup of the system. For example: sw_0 sw_1 nw_0 nw_1 se_0 se_1 ne_0 ne_1 w h 0 0 0 1 1 0 1 1 .1 .1 Each corner point is the location of an eyelet through which the cable passes. The width and height of the raft are defined by the separations between eyelets on the raft, through which the cable passes.","title":"Geometry"},{"location":"HOWTO/#profile","text":"The profile files are multi-line .csv files in hotspot/data/input/profiles . Each one defines a new position to which the robot should move, in the coordinate system defined above. Upon reaching each location in the profile, the robot is programmed to flash Hawkeye sources on and off (default: 10 \"on\" states, 50% duty cycle, 5 Hz), and which sources are enabled are configurable with the flasher_cmds column in the profile .csv. Each 0 or 1, space-separated, in the first column, corresponds to one of twelve addressable solid state switchable voltage sources on the LabJack PS12DC Power Switching Board. The index to address mapping is defined in the dictionary at the top of hardware.py . Since there are 3 groups of Hawkeye sources, there are more addressable relays than strictly necessary. For example, to move to a single coordinate and flash all addresses: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 1 1 1 1 1 1 1 1 1 .5 .5 to move to a single coordinate and flash only the center Hawkeye: flasher_cmds pos_cmd_0s pos_cmd_1s 1 0 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash the center and inner ring Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash all Hawkeyes (center, inner ring, outer ring): flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 0 0 0 0 0 0 0 0 0 .5 .5 Building up a sequence of moves allows a grid or shape to be scanned.","title":"Profile"},{"location":"HOWTO/#input-file-creation","text":"Since the dimensions of the motor mounts have been measured relative to each edge, the positions of the corner eyelets can be calculated, given the separation between the movable and fixed frame faces. The eyelets of the motor mounts measured $6.19 \\pm 0.5$ mm from the frame to the face of the motor mount, and $7.96 \\pm 0.02$ mm from the face of the motor mount to the eyelet, for a total eyelet offset from the contact patch of $0.014 \\pm 0.001$ m. This value will be used to calculate eyelet y-positions as a function of frame separation. The eyelet positions should not change in the x-direction, unless the motor mounts are removed from the aluminum frames. The final piece of information needed for the robot to move is the initial position, the home position. The installed position of the corner feature on the underside of the homing bar is measured, so that when the raft is nested in the corner feature, a repeatable and known raft centroid position is acheived. The homed centroid position is entered at the command line when prompted.","title":"Input File Creation"},{"location":"HOWTO/#example-geometry-calculation","text":"This is an example of the measurements needed to create a geoemtry file. Actual values listed here should not be used unless they have been verified against actual hardware, as raft and endpoint dimensions could have changed due to hardware revisions. For a benchtop test, the frame separation is $0.392 \\pm 0.001$ m, so the north side y-coordinates are $0.392 - 0.014 = 0.378$ m. Feature X Y SE 0.528 +/- 0.001 0.014 +/- 0.001 SW 0.057 +/- 0.001 0.014 +/- 0.001 NE 0.528 +/- 0.001 0.378 +/- 0.001 NW 0.057 +/- 0.001 0.378 +/- 0.001 Homing feature corner 0.155 +/- 0.001 0.151 +/- 0.001 The dimensions of the raft attachment points were measured. These distances are the distances between the points on the raft where the cables exit the eyelets. The eyelets themselves were located $1.2$ mm from each edge of the raft. This modifies the effective position of the homing feature by $(+0.001, +0.001)$ m. Raft width: $0.045 \\pm 0.001$ m Raft height: $0.040 \\pm 0.001$ m Together, the location of the raft centroid when it is nested at the HOME location: $r = (0.156 + 0.045/2, 0.152 - 0.040/2)$ Therefore, the input file for this shape would read: Input Loc. X Y SE 0.528 0.014 SW 0.057 0.014 NE 0.528 0.378 NW 0.057 0.378 RAFT 0.045 0.040 And when prompted for the raft's position during home calibration: Input Loc. X Y HOME 0.179 0.172","title":"Example Geometry Calculation"},{"location":"HOWTO/#operation","text":"When a surface geometry file has been created and the profile for the given shape to be mapped is generated, we are ready to run the program.","title":"Operation"},{"location":"HOWTO/#pre-mapping-checks","text":"Make sure that 12 V is being supplied to both motor driver boards in the stack, that the polarity is correct, and that the power supply output is on. Make sure that the cable is wound onto each spool and that no loops of excess cable are trapped underneath the cable wound onto the spools. Check the excess cable played out in the raft's current position. Some excess is fine as long as it doesn't interfere with the raft's motion. If the cable is taut before homing, this is also fine, but the homing routine may need to be run a few times before the raft reaches the home position. Ensure the Hawkeye source signal lines won't interfere with raft operation. Ensure the hotspot conda env is active.","title":"Pre-mapping checks"},{"location":"HOWTO/#mapping","text":"Start the program with python main.py ./data/input/geometry/<geometry.csv> ./data/input/profiles/<profile.csv> Perform a homing calibration: c , RETURN key. The NW motor will drive the raft to the NW corner while the NE, SW, SE axes go slack, and begin skipping steps after reaching the limit. This (and some noise) is normal. Verify that the raft reached its home against the NW corner, and that the other axes achieved tension. If not, GOTO 2. Perform a mapping sequence: s , RETURN key. The raft will drive to each location and flash the Hawkeyes at each point in the sequence. Before beginning each move, the axes will back off tension to avoid skipping steps, and should re-tension upon arrival. You may request a mode change at any time. Mode changes are processed at the end of each move. Upon completing a sequence, it may be repeated by changing to any other mode and requesting the sequence mode again.","title":"Mapping"},{"location":"HOWTO/#example-call-graph","text":"Without motors or LabJack attached, so does not include overhead of those libraries.","title":"Example Call Graph"},{"location":"HOWTO/#module-flow-charts","text":"","title":"Module Flow Charts"},{"location":"HOWTO/#executive","text":"","title":"Executive"},{"location":"HOWTO/#documentation","text":"","title":"Documentation"},{"location":"HOWTO/#reference-html","text":"The html documentation of the source code and Markdown materials is generated by portray . To regenerate the documentation, execute: portray as_html -m hotspot -o docs/html/ --overwrite","title":"Reference HTML"},{"location":"HOWTO/#pycallgraph","text":"To re-generate the call graph image, directory, run pycallgraph -i \"alg*\" -i \"const*\" -i \"exec*\" -i \"hardw*\" -i \"hot*\" -i \"hw*\" -i \"tele*\" graphviz --output-file = ../doc/img/pycallgraph.png -- main.py ../data/input/geometry/frame.csv ../data/input/profiles/box_frame.csv You must have graphviz installed using your operating system's package manager. For most accurate graph and timing information, do this with all peripheral hardware attached, so the call graphs include interfacing with the motor drivers and LabJack.","title":"pycallgraph"},{"location":"HOWTO/#test-fixture-setup","text":"For testing the software and hardware together, we set up the raspberry pi and the steppers on an optics bench in Steward Observatory Lab 168. This allows us to affix the steppers to something a roughly known distance apart. This was done to allow testing of the algorithms while the frame was in development.","title":"Test Fixture Setup"},{"location":"HOWTO/#stepper-fixture","text":"Steppers are attached to the optics bench for testing via 3D-printed brackets. 1/4-20 socket head cap screws affix the bracket to the bench, and M3 screws affix the steppers to the brackets.","title":"Stepper Fixture"},{"location":"HOWTO/#fishing-line-routing","text":"On the optics bench, the fishing line was routed from the motor spools to the raft via 3D printed posts, forming 4 corners of a rectangle to emulate the operational configuration. These posts were 3D printed 1/4-20 screws in PETG plastic, with ~.9mm (as designed, not as printed) holes in the top to allow routing the fishing line through.","title":"Fishing line routing"},{"location":"HOWTO/#test-raft","text":"For testing purposes, the raft was another 3D printed part, a rectangular plastic coupon with four holes to accept M3 screws for tying down the ends of the fishing line a known distance apart. This was done in lieu of having a raft of Hawkeye sources ready.","title":"Test raft"},{"location":"reference/hotspot/","text":"Module hotspot None None Sub-modules hotspot.algorithm hotspot.constants hotspot.executive hotspot.hardware hotspot.hw_context hotspot.telemetry","title":"Index"},{"location":"reference/hotspot/#module-hotspot","text":"None None","title":"Module hotspot"},{"location":"reference/hotspot/#sub-modules","text":"hotspot.algorithm hotspot.constants hotspot.executive hotspot.hardware hotspot.hw_context hotspot.telemetry","title":"Sub-modules"},{"location":"reference/hotspot/algorithm/","text":"Module hotspot.algorithm None None View Source # This file houses the algorithms necessary for calculating the control # quantities. # MKS units only. import logging import multiprocessing as mp import numpy as np import time import hotspot.constants as const logger = logging . getLogger ( __name__ ) # logger.setLevel(getattr(logging, const.LOGLEVEL)) class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )): logger . debug ( 'TestSurface init' ) corner_list = [ nw , ne , se , sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { inp } .' assert len ({ elem for elem in corner_list }) == len ( corner_list ), f 'Vertices should be unique: { corner_list } ' # Corner points are expressed as x,y offsets in mirror coordinate frame self . corners = np . array ([[ sw , nw ], [ se , ne ]]) self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] def is_inbounds ( self , pos : tuple ): ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [ self . sw , self . nw , self . ne , self . se , self . sw ] reason = None for i in range ( len ( vertex_seq ) - 1 ): disp0 = vertex_seq [ i ] - pos disp1 = vertex_seq [ i + 1 ] - pos mag0 = np . linalg . norm ( disp0 ) mag1 = np . linalg . norm ( disp1 ) # is pos too close to a vertex (protect against divide by 0) if ( mag0 < eps or mag1 < eps ): result = False reason = 'Too close to corner' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np . arccos ( np . dot ( v0_hat , v1_hat )) # is pos too close to an edge if np . abs ( ang - np . pi ) < eps : result = False reason = 'Too close to edge' break ang_tot_rad += ang # is pos inside shape if np . abs ( ang_tot_rad - 2. * np . pi ) > eps : result = False reason = f 'Outside shape: { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason : logger . debug ( f 'Bounds check failed: { reason } ' ) return result class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { position } .' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location { home_pos } is outside of bounds for surface { self . surf } ' ) @property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command { new_pos } is outside of bounds for surface { self . surf } ' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: { distance } ' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: { pos_cmd } ' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move: { lengths_after } ' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: { motor_cmds } \\n Delta lengths: { delta_lengths } ' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds Variables logger Classes Raft class Raft ( position : tuple , width : float , height : float ) View Source class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {position}.' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @ property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @ position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos Instance variables position Accessor for raft origin position in mirror coordinate frame Robot class Robot ( surf : hotspot . algorithm . TestSurface , raft : hotspot . algorithm . Raft , tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7fb736fd9940 >> ) View Source class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @ property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @ home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location {home_pos} is outside of bounds for surface {self.surf}' ) @ property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @ pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command {new_pos} is outside of bounds for surface {self.surf}' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds Instance variables home The location in mirror coordinate frame the robot will guide to when commanded home pos_cmd The location in mirror coordinate frame the robot will guide to for the next move Methods process_input def process_input ( self , pos_cmd : tuple ) Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters: Name Type Description Default pos_cmd None the position command in the frame of the surface None Returns: Type Description dict of tuples dict containing motor commands in radians. View Source def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds TestSurface class TestSurface ( sw = ( 0.0 , 0.0 ), se = ( 1.0 , 0.0 ), nw = ( 0.0 , 1.0 ), ne = ( 1.0 , 1.0 ) ) View Source class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )) : logger . debug ( 'TestSurface init' ) corner_list = [ nw, ne, se, sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {inp}.' assert len ( { elem for elem in corner_list } ) == len ( corner_list ), f 'Vertices should be unique: {corner_list}' # Corner points are expressed as x , y offsets in mirror coordinate frame self . corners = np . array ( [ [sw, nw ] , [ se, ne ] ] ) self . sw = self . corners [ 0,0 ] self . se = self . corners [ 1,0 ] self . nw = self . corners [ 0,1 ] self . ne = self . corners [ 1,1 ] def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result Methods is_inbounds def is_inbounds ( self , pos : tuple ) Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. View Source def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result","title":"Algorithm"},{"location":"reference/hotspot/algorithm/#module-hotspotalgorithm","text":"None None View Source # This file houses the algorithms necessary for calculating the control # quantities. # MKS units only. import logging import multiprocessing as mp import numpy as np import time import hotspot.constants as const logger = logging . getLogger ( __name__ ) # logger.setLevel(getattr(logging, const.LOGLEVEL)) class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )): logger . debug ( 'TestSurface init' ) corner_list = [ nw , ne , se , sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { inp } .' assert len ({ elem for elem in corner_list }) == len ( corner_list ), f 'Vertices should be unique: { corner_list } ' # Corner points are expressed as x,y offsets in mirror coordinate frame self . corners = np . array ([[ sw , nw ], [ se , ne ]]) self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] def is_inbounds ( self , pos : tuple ): ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [ self . sw , self . nw , self . ne , self . se , self . sw ] reason = None for i in range ( len ( vertex_seq ) - 1 ): disp0 = vertex_seq [ i ] - pos disp1 = vertex_seq [ i + 1 ] - pos mag0 = np . linalg . norm ( disp0 ) mag1 = np . linalg . norm ( disp1 ) # is pos too close to a vertex (protect against divide by 0) if ( mag0 < eps or mag1 < eps ): result = False reason = 'Too close to corner' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np . arccos ( np . dot ( v0_hat , v1_hat )) # is pos too close to an edge if np . abs ( ang - np . pi ) < eps : result = False reason = 'Too close to edge' break ang_tot_rad += ang # is pos inside shape if np . abs ( ang_tot_rad - 2. * np . pi ) > eps : result = False reason = f 'Outside shape: { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason : logger . debug ( f 'Bounds check failed: { reason } ' ) return result class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { position } .' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location { home_pos } is outside of bounds for surface { self . surf } ' ) @property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command { new_pos } is outside of bounds for surface { self . surf } ' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: { distance } ' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: { pos_cmd } ' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move: { lengths_after } ' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: { motor_cmds } \\n Delta lengths: { delta_lengths } ' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"Module hotspot.algorithm"},{"location":"reference/hotspot/algorithm/#variables","text":"logger","title":"Variables"},{"location":"reference/hotspot/algorithm/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/algorithm/#raft","text":"class Raft ( position : tuple , width : float , height : float ) View Source class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {position}.' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @ property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @ position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos","title":"Raft"},{"location":"reference/hotspot/algorithm/#instance-variables","text":"position Accessor for raft origin position in mirror coordinate frame","title":"Instance variables"},{"location":"reference/hotspot/algorithm/#robot","text":"class Robot ( surf : hotspot . algorithm . TestSurface , raft : hotspot . algorithm . Raft , tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7fb736fd9940 >> ) View Source class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @ property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @ home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location {home_pos} is outside of bounds for surface {self.surf}' ) @ property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @ pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command {new_pos} is outside of bounds for surface {self.surf}' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"Robot"},{"location":"reference/hotspot/algorithm/#instance-variables_1","text":"home The location in mirror coordinate frame the robot will guide to when commanded home pos_cmd The location in mirror coordinate frame the robot will guide to for the next move","title":"Instance variables"},{"location":"reference/hotspot/algorithm/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/algorithm/#process_input","text":"def process_input ( self , pos_cmd : tuple ) Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters: Name Type Description Default pos_cmd None the position command in the frame of the surface None Returns: Type Description dict of tuples dict containing motor commands in radians. View Source def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"process_input"},{"location":"reference/hotspot/algorithm/#testsurface","text":"class TestSurface ( sw = ( 0.0 , 0.0 ), se = ( 1.0 , 0.0 ), nw = ( 0.0 , 1.0 ), ne = ( 1.0 , 1.0 ) ) View Source class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )) : logger . debug ( 'TestSurface init' ) corner_list = [ nw, ne, se, sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {inp}.' assert len ( { elem for elem in corner_list } ) == len ( corner_list ), f 'Vertices should be unique: {corner_list}' # Corner points are expressed as x , y offsets in mirror coordinate frame self . corners = np . array ( [ [sw, nw ] , [ se, ne ] ] ) self . sw = self . corners [ 0,0 ] self . se = self . corners [ 1,0 ] self . nw = self . corners [ 0,1 ] self . ne = self . corners [ 1,1 ] def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result","title":"TestSurface"},{"location":"reference/hotspot/algorithm/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/algorithm/#is_inbounds","text":"def is_inbounds ( self , pos : tuple ) Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. View Source def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result","title":"is_inbounds"},{"location":"reference/hotspot/constants/","text":"Module hotspot.constants None None View Source # Numbers that don't change from mirror to mirror # MKS units throughout if not specified. import numpy as np import os from hotspot.hw_context import stepper # Adafruit stacking motor driver hats are addressable. HAT_0_ADDR = 0x60 HAT_1_ADDR = 0x61 # Adafruit stepper style. Used to enable/disable microstepping. STEPPER_STYLE = stepper . INTERLEAVE PWM_FREQ = 1600 # Adafruit microstepping modifier. Divides each single step by the modifier: # E.g. a value of 8 splits one 1.8 deg step into eight .225 deg steps. # Even numbers from 2-8. MICROSTEP_NUM = 2 # Used for converting rotational changes into stepper commands DEG_PER_STEP = 360. / 200. / MICROSTEP_NUM DEG_PER_RAD = 180. / np . pi # Used for converting linear distances into rotational ones PULLEY_RADIUS = 0.03 / 2. # Limits the total number of commands that may be in the command queue at once. # Pretty much only limited by memory. MAX_QLEN = 2 ** 16 # delta x distance from the NW eyelet to the raft centroid, when it is driven # to the NW limit and the raft isn't cockeyed HOMING_OFFSET_X = 0.0276 # same, but for y HOMING_OFFSET_Y = - 0.0252 # Not sure how issuing step commands to multiple motors too fast will mess # with the motor hat timing, so wait a bit just to be safe STEP_WAIT = 1e-3 # Backup vars in case we need to switch to arduino motor control over serial # SERIAL_PORT = '/dev/ttyACM0' # SERIAL_BAUD = 115200 # Helps with I/O TOPLEVEL_DIR = os . path . abspath ( os . path . join ( __file__ , '..' , '..' )) Variables DEG_PER_RAD DEG_PER_STEP HAT_0_ADDR HAT_1_ADDR HOMING_OFFSET_X HOMING_OFFSET_Y MAX_QLEN MICROSTEP_NUM PULLEY_RADIUS PWM_FREQ STEPPER_STYLE STEP_WAIT TOPLEVEL_DIR","title":"Constants"},{"location":"reference/hotspot/constants/#module-hotspotconstants","text":"None None View Source # Numbers that don't change from mirror to mirror # MKS units throughout if not specified. import numpy as np import os from hotspot.hw_context import stepper # Adafruit stacking motor driver hats are addressable. HAT_0_ADDR = 0x60 HAT_1_ADDR = 0x61 # Adafruit stepper style. Used to enable/disable microstepping. STEPPER_STYLE = stepper . INTERLEAVE PWM_FREQ = 1600 # Adafruit microstepping modifier. Divides each single step by the modifier: # E.g. a value of 8 splits one 1.8 deg step into eight .225 deg steps. # Even numbers from 2-8. MICROSTEP_NUM = 2 # Used for converting rotational changes into stepper commands DEG_PER_STEP = 360. / 200. / MICROSTEP_NUM DEG_PER_RAD = 180. / np . pi # Used for converting linear distances into rotational ones PULLEY_RADIUS = 0.03 / 2. # Limits the total number of commands that may be in the command queue at once. # Pretty much only limited by memory. MAX_QLEN = 2 ** 16 # delta x distance from the NW eyelet to the raft centroid, when it is driven # to the NW limit and the raft isn't cockeyed HOMING_OFFSET_X = 0.0276 # same, but for y HOMING_OFFSET_Y = - 0.0252 # Not sure how issuing step commands to multiple motors too fast will mess # with the motor hat timing, so wait a bit just to be safe STEP_WAIT = 1e-3 # Backup vars in case we need to switch to arduino motor control over serial # SERIAL_PORT = '/dev/ttyACM0' # SERIAL_BAUD = 115200 # Helps with I/O TOPLEVEL_DIR = os . path . abspath ( os . path . join ( __file__ , '..' , '..' ))","title":"Module hotspot.constants"},{"location":"reference/hotspot/constants/#variables","text":"DEG_PER_RAD DEG_PER_STEP HAT_0_ADDR HAT_1_ADDR HOMING_OFFSET_X HOMING_OFFSET_Y MAX_QLEN MICROSTEP_NUM PULLEY_RADIUS PWM_FREQ STEPPER_STYLE STEP_WAIT TOPLEVEL_DIR","title":"Variables"},{"location":"reference/hotspot/executive/","text":"Module hotspot.executive None None View Source # This file houses the code to coordinate starting, running, and stopping # the various processes/threads needed. import logging import multiprocessing as mp import numpy as np import os import serial import sys import threading import time from hotspot.hw_context import MotorKit from hotspot.hw_context import stepper import hotspot.algorithm as alg import hotspot.constants as const import hotspot.hardware as hw import hotspot.telemetry as tm logger = logging . getLogger ( __name__ ) MODES = { 'c' : 'CAL_HOME' , 'h' : 'HOME' , 's' : 'SEQ' , 'w' : 'WAIT' } HR = '-' * 80 MENU_STR = HR + f ' \\n Listening for user input for mode changes. Type a mode char and press enter: \\n { MODES } \\n ' + HR class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'CAL_HOME' self . last_mode = 'CAL_HOME' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) #self.ser = serial.Serial(const.SERIAL_PORT, const.SERIAL_BAUD) # time.sleep(2) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: { fname } ' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number { len ( rows ) } exceeds command' + ' queue length {const.MAX_QLEN} . Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: { self . robot . home } ' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) # Ensure all steppers start on a single step boundary for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . FORWARD ) time . sleep ( 100 * const . STEP_WAIT ) self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position { self . robot . raft . position } ' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: { self . robot . home } ' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: { self . robot . raft . position } ' ) logger . info ( f 'Command completed. Sequence progress: { progress : .2f } %' ) # take time to log TM and update display before doing next cmd self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict angs = [ cmd for cmd in [ motor_cmds [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]]] steps_taken = hw . all_steppers ([ self . steppers [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]], angs ) #steps_taken = hw.all_steppers_serial(self.ser, angs) logger . debug ( f 'Move cmd: { cmd } ' ) # HACK: ECM: stepper tension slush fund: # back off tension before moving, do move, then tension back up to avoid # skipping. slack = 20 * const . MICROSTEP_NUM for _ in range ( slack ): for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . FORWARD ) time . sleep ( const . STEP_WAIT ) # HACK: Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. ECM: This should really probably # happen inside the control algorithm itself, or even better, ditch # the linear approximation and do the math to find out how each motor # should move at each point in the move. MAX_DIST = .015 pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) while dist_to_go > MAX_DIST : logger . debug ( f 'Dist. to go in this move: { dist_to_go } ' ) # determine a position MAX_DIST away from the starting pos along # the line of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: { v } , Unit vector: { u } ' ) pos_cmd = pos_before + MAX_DIST * u logger . debug ( f 'Intermediate move: { pos_cmd } ' ) send_pos_cmd ( pos_cmd ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) logger . debug ( f 'Final move: { pos_after } ' ) send_pos_cmd ( pos_after ) # HACK: ECM: take tension back up once in position for k in range ( slack + 1 ): # a dirty, dirty hack to get another step in in case of skips for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) return def do_labjack_tasks ( self , cmd : dict ): freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] #self.ser.close() return Variables HR MENU_STR MODES logger Classes Executive class Executive ( geometry_file : str , plot_enable = False ) Attributes Name Type Description Default geometry_file None Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. None View Source class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'CAL_HOME' self . last_mode = 'CAL_HOME' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) #self.ser = serial.Serial(const.SERIAL_PORT, const.SERIAL_BAUD) # time.sleep(2) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: {self.robot.home}' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) # Ensure all steppers start on a single step boundary for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . FORWARD ) time . sleep ( 100 * const . STEP_WAIT ) self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: {self.robot.raft.position}' ) logger . info ( f 'Command completed. Sequence progress: {progress:.2f} %' ) # take time to log TM and update display before doing next cmd self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict angs = [ cmd for cmd in [ motor_cmds [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]]] steps_taken = hw . all_steppers ([ self . steppers [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]], angs ) #steps_taken = hw.all_steppers_serial(self.ser, angs) logger . debug ( f 'Move cmd: {cmd}' ) # HACK: ECM: stepper tension slush fund: # back off tension before moving, do move, then tension back up to avoid # skipping. slack = 20 * const . MICROSTEP_NUM for _ in range ( slack ): for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . FORWARD ) time . sleep ( const . STEP_WAIT ) # HACK: Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. ECM: This should really probably # happen inside the control algorithm itself, or even better, ditch # the linear approximation and do the math to find out how each motor # should move at each point in the move. MAX_DIST = . 015 pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) while dist_to_go > MAX_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position MAX_DIST away from the starting pos along # the line of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + MAX_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) logger . debug ( f 'Final move: {pos_after}' ) send_pos_cmd ( pos_after ) # HACK: ECM: take tension back up once in position for k in range ( slack + 1 ): # a dirty, dirty hack to get another step in in case of skips for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) return def do_labjack_tasks ( self , cmd : dict ): freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] #self.ser.close() return Methods add_cmds def add_cmds ( self , fname : str ) Read command input file and add commands to the command queue. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def add_cmds ( self , fname : str ) : ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ) : logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ) : cmd = {} cmd [ 'flasher_cmds' ] = [ int(item) for item in rows[i ][ 0 ] . split () ] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ] , rows [ i ][ 2 ] ) self . cmd_queue . put ( cmd ) return cal_home def cal_home ( self ) Ask the user to input the current position of the center of the raft to store it as the home position. View Source def cal_home ( self ) : ''' Ask the user to input the current position of the center of the raft to store it as the home position . ''' print ( ' Where is home? Input the current position, in meters, of ' + ' the raft centroid relative to the mirror origin, then press ' + ' ENTER to store it as home. ' ) x = float ( input ( ' x-coord: ' )) y = float ( input ( ' y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f ' Home position set: {self.robot.home} ' ) return cal_home_auto def cal_home_auto ( self ) Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. View Source def cal_home_auto ( self ) : ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting , to NE , SE , SW don 't # inhibit motion [self.steppers[key].release() for key in self.steppers.keys()] # Worst case, about how far would we have to move before hitting NW? max_distance = np.linalg.norm(self.robot.surf.nw - self.robot.surf.se) max_radians = max_distance / const.PULLEY_RADIUS # valid for single or double steps max_steps = np.round(np.abs(max_radians) * const.DEG_PER_RAD / (360. / 200. / 1)).astype(int) num_steps = max(1, max_steps) logger.info(' Homing to NW ') report_interval = 100 i = num_steps while i > 0: self.steppers[' nw '].onestep(style=stepper.DOUBLE, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') logger.info(' Retracting cables to tension NE , SE , SW ') i = num_steps while i > 0: self.steppers[' ne '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' se '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' sw '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') # Ensure all steppers start on a single step boundary for key in self.steppers.keys(): self.steppers[key].onestep(style=stepper.DOUBLE, direction=stepper.FORWARD) time.sleep(100*const.STEP_WAIT) self.steppers[key].onestep(style=stepper.DOUBLE, direction=stepper.BACKWARD) pos = self.robot.surf.nw + np.array((const.HOMING_OFFSET_X, const.HOMING_OFFSET_Y)) self.robot.raft.position = pos self.robot.home = pos logger.info(f' Raft is homed with centroid position { self . robot . raft . position } ') logger.warning(' Verify that the raft has been driven to one of its limits and all cables are taut . If not , request CAL_HOME again . ') packet = {' algorithm ': { ' Time UTC ( s ) ': time.time(), ' Position Command ( m ) ' : pos, ' Motor Delta Angle Command ( rad ) ' : np . array ( [ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return close def close ( self ) View Source def close ( self ) : [ self.steppers[key ] . release () for key in self . steppers . keys () ] #self . ser . close () return do_labjack_tasks def do_labjack_tasks ( self , cmd : dict ) View Source def do_labjack_tasks ( self , cmd : dict ) : freq = 5 . # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ ' flasher_cmds ' ] ) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1 . / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) packet = { ' LabJack Cmd ' : { ' Time UTC (s) ' : time . time () , ' Addresses Turned On ' : 1 + np . where ( np . array ( cmd [ ' flasher_cmds ' ] ) > 0 ) [ 0 ], } } self . tm_queue . put ( packet ) return do_motor_tasks def do_motor_tasks ( self , cmd : dict ) -> list Transform the move command into motor commands Parameters: Name Type Description Default cmd Command packet dictionary with keys for position commands to pass to control algorithm None View Source def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ) : ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict angs = [ cmd for cmd in [motor_cmds[key ] for key in [ 'sw', 'nw', 'ne', 'se' ] ]] steps_taken = hw . all_steppers ( [ self.steppers[key ] for key in [ 'sw', 'nw', 'ne', 'se' ] ] , angs ) #steps_taken = hw . all_steppers_serial ( self . ser , angs ) logger . debug ( f 'Move cmd: {cmd}' ) # HACK : ECM : stepper tension slush fund : # back off tension before moving , do move , then tension back up to avoid # skipping . slack = 20 * const . MICROSTEP_NUM for _ in range ( slack ) : for key in self . steppers . keys () : self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . FORWARD ) time . sleep ( const . STEP_WAIT ) # HACK : Linear approximation only holds for small distances , so # chunk up big moves into tiny bits . ECM : This should really probably # happen inside the control algorithm itself , or even better , ditch # the linear approximation and do the math to find out how each motor # should move at each point in the move . MAX_DIST = .015 pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) while dist_to_go > MAX_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position MAX_DIST away from the starting pos along # the line of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + MAX_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) logger . debug ( f 'Final move: {pos_after}' ) send_pos_cmd ( pos_after ) # HACK : ECM : take tension back up once in position for k in range ( slack + 1 ) : # a dirty , dirty hack to get another step in in case of skips for key in self . steppers . keys () : self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) return empty_queue def empty_queue ( self , queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7fb736fd9940 >> ) Completely empty the given Queue object. Parameters: Name Type Description Default queue None Any queue None View Source def empty_queue ( self , queue : mp . Queue ) : ''' Completely empty the given Queue object . Parameters ---------- queue Any queue ''' while not queue . empty () : queue . get () return go_home def go_home ( self ) Clear all commands in the queue and drive to the home position. View Source def go_home ( self ) : ''' Clear all commands in the queue and drive to the home position. ''' # If not already home , go there . eps = np . finfo ( float ). eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )) : logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return run def run ( self , fname : str ) Main run function, including processing human input to switch between states. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def run ( self , fname : str ) : ''' Main run function , including processing human input to switch between states . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col . Data spec described in docstring of sequence () function . ''' # Allow user input to change the mode . input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue , ) , daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input . self . mode = ' WAIT ' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty () : kbd_in = self . kbd_queue . get_nowait () if ' c ' == kbd_in : logger . info ( ' Home calibration requested. ' ) self . mode = ' CAL_HOME ' elif ' h ' == kbd_in : logger . info ( ' Moving to home requested. ' ) self . mode = ' HOME ' elif ' s ' == kbd_in : logger . info ( ' Sequence run requested. ' ) self . mode = ' SEQ ' elif ' w ' == kbd_in : logger . info ( ' Wait mode requested. ' ) self . mode = ' WAIT ' else : continue if self . mode == ' CAL_HOME ' : self . cal_home_auto () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' HOME ' : self . go_home () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' SEQ ' : self . sequence ( fname ) elif self . mode == ' WAIT ' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down. ' ) running = False self . close () return sequence def sequence ( self , fname : str ) On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate None View Source def sequence ( self , fname : str ) : ''' On each call , pop a new command off of the command queue and dispatch it to motors / LabJack . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col : - flasher_cmds : 1 or 0 depending on whether that address is enabled - pos_cmd_0s : 0 th element of position command coordinate - pos_cmd_1s : 1 st element of position command coordinate ''' # If we are changing to sequence from another mode , ensure we start # fresh if self . mode != self . last_mode : logger . info ( ' Beginning command sequence. ' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : return else : cmd = self . cmd_queue . get () progress = 100 . * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks , then LJ tasks in serial , so IR source tasks happen at the end of each move . self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f ' Raft centroid: {self.robot.raft.position} ' ) logger . info ( f ' Command completed. Sequence progress: {progress:.2f} % ' ) # take time to log TM and update display before doing next cmd self . router . process_tm ( plot_enable = self . plot_enable ) return wait def wait ( self ) View Source def wait ( self ) : return","title":"Executive"},{"location":"reference/hotspot/executive/#module-hotspotexecutive","text":"None None View Source # This file houses the code to coordinate starting, running, and stopping # the various processes/threads needed. import logging import multiprocessing as mp import numpy as np import os import serial import sys import threading import time from hotspot.hw_context import MotorKit from hotspot.hw_context import stepper import hotspot.algorithm as alg import hotspot.constants as const import hotspot.hardware as hw import hotspot.telemetry as tm logger = logging . getLogger ( __name__ ) MODES = { 'c' : 'CAL_HOME' , 'h' : 'HOME' , 's' : 'SEQ' , 'w' : 'WAIT' } HR = '-' * 80 MENU_STR = HR + f ' \\n Listening for user input for mode changes. Type a mode char and press enter: \\n { MODES } \\n ' + HR class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'CAL_HOME' self . last_mode = 'CAL_HOME' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) #self.ser = serial.Serial(const.SERIAL_PORT, const.SERIAL_BAUD) # time.sleep(2) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: { fname } ' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number { len ( rows ) } exceeds command' + ' queue length {const.MAX_QLEN} . Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: { self . robot . home } ' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) # Ensure all steppers start on a single step boundary for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . FORWARD ) time . sleep ( 100 * const . STEP_WAIT ) self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position { self . robot . raft . position } ' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: { self . robot . home } ' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: { self . robot . raft . position } ' ) logger . info ( f 'Command completed. Sequence progress: { progress : .2f } %' ) # take time to log TM and update display before doing next cmd self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict angs = [ cmd for cmd in [ motor_cmds [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]]] steps_taken = hw . all_steppers ([ self . steppers [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]], angs ) #steps_taken = hw.all_steppers_serial(self.ser, angs) logger . debug ( f 'Move cmd: { cmd } ' ) # HACK: ECM: stepper tension slush fund: # back off tension before moving, do move, then tension back up to avoid # skipping. slack = 20 * const . MICROSTEP_NUM for _ in range ( slack ): for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . FORWARD ) time . sleep ( const . STEP_WAIT ) # HACK: Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. ECM: This should really probably # happen inside the control algorithm itself, or even better, ditch # the linear approximation and do the math to find out how each motor # should move at each point in the move. MAX_DIST = .015 pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) while dist_to_go > MAX_DIST : logger . debug ( f 'Dist. to go in this move: { dist_to_go } ' ) # determine a position MAX_DIST away from the starting pos along # the line of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: { v } , Unit vector: { u } ' ) pos_cmd = pos_before + MAX_DIST * u logger . debug ( f 'Intermediate move: { pos_cmd } ' ) send_pos_cmd ( pos_cmd ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) logger . debug ( f 'Final move: { pos_after } ' ) send_pos_cmd ( pos_after ) # HACK: ECM: take tension back up once in position for k in range ( slack + 1 ): # a dirty, dirty hack to get another step in in case of skips for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) return def do_labjack_tasks ( self , cmd : dict ): freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] #self.ser.close() return","title":"Module hotspot.executive"},{"location":"reference/hotspot/executive/#variables","text":"HR MENU_STR MODES logger","title":"Variables"},{"location":"reference/hotspot/executive/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/executive/#executive","text":"class Executive ( geometry_file : str , plot_enable = False )","title":"Executive"},{"location":"reference/hotspot/executive/#attributes","text":"Name Type Description Default geometry_file None Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. None View Source class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'CAL_HOME' self . last_mode = 'CAL_HOME' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) #self.ser = serial.Serial(const.SERIAL_PORT, const.SERIAL_BAUD) # time.sleep(2) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: {self.robot.home}' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) # Ensure all steppers start on a single step boundary for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . FORWARD ) time . sleep ( 100 * const . STEP_WAIT ) self . steppers [ key ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: {self.robot.raft.position}' ) logger . info ( f 'Command completed. Sequence progress: {progress:.2f} %' ) # take time to log TM and update display before doing next cmd self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict angs = [ cmd for cmd in [ motor_cmds [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]]] steps_taken = hw . all_steppers ([ self . steppers [ key ] for key in [ 'sw' , 'nw' , 'ne' , 'se' ]], angs ) #steps_taken = hw.all_steppers_serial(self.ser, angs) logger . debug ( f 'Move cmd: {cmd}' ) # HACK: ECM: stepper tension slush fund: # back off tension before moving, do move, then tension back up to avoid # skipping. slack = 20 * const . MICROSTEP_NUM for _ in range ( slack ): for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . FORWARD ) time . sleep ( const . STEP_WAIT ) # HACK: Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. ECM: This should really probably # happen inside the control algorithm itself, or even better, ditch # the linear approximation and do the math to find out how each motor # should move at each point in the move. MAX_DIST = . 015 pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) while dist_to_go > MAX_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position MAX_DIST away from the starting pos along # the line of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + MAX_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) logger . debug ( f 'Final move: {pos_after}' ) send_pos_cmd ( pos_after ) # HACK: ECM: take tension back up once in position for k in range ( slack + 1 ): # a dirty, dirty hack to get another step in in case of skips for key in self . steppers . keys (): self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) return def do_labjack_tasks ( self , cmd : dict ): freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] #self.ser.close() return","title":"Attributes"},{"location":"reference/hotspot/executive/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/executive/#add_cmds","text":"def add_cmds ( self , fname : str ) Read command input file and add commands to the command queue. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def add_cmds ( self , fname : str ) : ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ) : logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ) : cmd = {} cmd [ 'flasher_cmds' ] = [ int(item) for item in rows[i ][ 0 ] . split () ] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ] , rows [ i ][ 2 ] ) self . cmd_queue . put ( cmd ) return","title":"add_cmds"},{"location":"reference/hotspot/executive/#cal_home","text":"def cal_home ( self ) Ask the user to input the current position of the center of the raft to store it as the home position. View Source def cal_home ( self ) : ''' Ask the user to input the current position of the center of the raft to store it as the home position . ''' print ( ' Where is home? Input the current position, in meters, of ' + ' the raft centroid relative to the mirror origin, then press ' + ' ENTER to store it as home. ' ) x = float ( input ( ' x-coord: ' )) y = float ( input ( ' y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f ' Home position set: {self.robot.home} ' ) return","title":"cal_home"},{"location":"reference/hotspot/executive/#cal_home_auto","text":"def cal_home_auto ( self ) Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. View Source def cal_home_auto ( self ) : ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting , to NE , SE , SW don 't # inhibit motion [self.steppers[key].release() for key in self.steppers.keys()] # Worst case, about how far would we have to move before hitting NW? max_distance = np.linalg.norm(self.robot.surf.nw - self.robot.surf.se) max_radians = max_distance / const.PULLEY_RADIUS # valid for single or double steps max_steps = np.round(np.abs(max_radians) * const.DEG_PER_RAD / (360. / 200. / 1)).astype(int) num_steps = max(1, max_steps) logger.info(' Homing to NW ') report_interval = 100 i = num_steps while i > 0: self.steppers[' nw '].onestep(style=stepper.DOUBLE, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') logger.info(' Retracting cables to tension NE , SE , SW ') i = num_steps while i > 0: self.steppers[' ne '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' se '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' sw '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') # Ensure all steppers start on a single step boundary for key in self.steppers.keys(): self.steppers[key].onestep(style=stepper.DOUBLE, direction=stepper.FORWARD) time.sleep(100*const.STEP_WAIT) self.steppers[key].onestep(style=stepper.DOUBLE, direction=stepper.BACKWARD) pos = self.robot.surf.nw + np.array((const.HOMING_OFFSET_X, const.HOMING_OFFSET_Y)) self.robot.raft.position = pos self.robot.home = pos logger.info(f' Raft is homed with centroid position { self . robot . raft . position } ') logger.warning(' Verify that the raft has been driven to one of its limits and all cables are taut . If not , request CAL_HOME again . ') packet = {' algorithm ': { ' Time UTC ( s ) ': time.time(), ' Position Command ( m ) ' : pos, ' Motor Delta Angle Command ( rad ) ' : np . array ( [ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return","title":"cal_home_auto"},{"location":"reference/hotspot/executive/#close","text":"def close ( self ) View Source def close ( self ) : [ self.steppers[key ] . release () for key in self . steppers . keys () ] #self . ser . close () return","title":"close"},{"location":"reference/hotspot/executive/#do_labjack_tasks","text":"def do_labjack_tasks ( self , cmd : dict ) View Source def do_labjack_tasks ( self , cmd : dict ) : freq = 5 . # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ ' flasher_cmds ' ] ) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1 . / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) packet = { ' LabJack Cmd ' : { ' Time UTC (s) ' : time . time () , ' Addresses Turned On ' : 1 + np . where ( np . array ( cmd [ ' flasher_cmds ' ] ) > 0 ) [ 0 ], } } self . tm_queue . put ( packet ) return","title":"do_labjack_tasks"},{"location":"reference/hotspot/executive/#do_motor_tasks","text":"def do_motor_tasks ( self , cmd : dict ) -> list Transform the move command into motor commands Parameters: Name Type Description Default cmd Command packet dictionary with keys for position commands to pass to control algorithm None View Source def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ) : ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict angs = [ cmd for cmd in [motor_cmds[key ] for key in [ 'sw', 'nw', 'ne', 'se' ] ]] steps_taken = hw . all_steppers ( [ self.steppers[key ] for key in [ 'sw', 'nw', 'ne', 'se' ] ] , angs ) #steps_taken = hw . all_steppers_serial ( self . ser , angs ) logger . debug ( f 'Move cmd: {cmd}' ) # HACK : ECM : stepper tension slush fund : # back off tension before moving , do move , then tension back up to avoid # skipping . slack = 20 * const . MICROSTEP_NUM for _ in range ( slack ) : for key in self . steppers . keys () : self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . FORWARD ) time . sleep ( const . STEP_WAIT ) # HACK : Linear approximation only holds for small distances , so # chunk up big moves into tiny bits . ECM : This should really probably # happen inside the control algorithm itself , or even better , ditch # the linear approximation and do the math to find out how each motor # should move at each point in the move . MAX_DIST = .015 pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) while dist_to_go > MAX_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position MAX_DIST away from the starting pos along # the line of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + MAX_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) logger . debug ( f 'Final move: {pos_after}' ) send_pos_cmd ( pos_after ) # HACK : ECM : take tension back up once in position for k in range ( slack + 1 ) : # a dirty , dirty hack to get another step in in case of skips for key in self . steppers . keys () : self . steppers [ key ] . onestep ( style = const . STEPPER_STYLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) return","title":"do_motor_tasks"},{"location":"reference/hotspot/executive/#empty_queue","text":"def empty_queue ( self , queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7fb736fd9940 >> ) Completely empty the given Queue object. Parameters: Name Type Description Default queue None Any queue None View Source def empty_queue ( self , queue : mp . Queue ) : ''' Completely empty the given Queue object . Parameters ---------- queue Any queue ''' while not queue . empty () : queue . get () return","title":"empty_queue"},{"location":"reference/hotspot/executive/#go_home","text":"def go_home ( self ) Clear all commands in the queue and drive to the home position. View Source def go_home ( self ) : ''' Clear all commands in the queue and drive to the home position. ''' # If not already home , go there . eps = np . finfo ( float ). eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )) : logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return","title":"go_home"},{"location":"reference/hotspot/executive/#run","text":"def run ( self , fname : str ) Main run function, including processing human input to switch between states. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def run ( self , fname : str ) : ''' Main run function , including processing human input to switch between states . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col . Data spec described in docstring of sequence () function . ''' # Allow user input to change the mode . input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue , ) , daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input . self . mode = ' WAIT ' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty () : kbd_in = self . kbd_queue . get_nowait () if ' c ' == kbd_in : logger . info ( ' Home calibration requested. ' ) self . mode = ' CAL_HOME ' elif ' h ' == kbd_in : logger . info ( ' Moving to home requested. ' ) self . mode = ' HOME ' elif ' s ' == kbd_in : logger . info ( ' Sequence run requested. ' ) self . mode = ' SEQ ' elif ' w ' == kbd_in : logger . info ( ' Wait mode requested. ' ) self . mode = ' WAIT ' else : continue if self . mode == ' CAL_HOME ' : self . cal_home_auto () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' HOME ' : self . go_home () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' SEQ ' : self . sequence ( fname ) elif self . mode == ' WAIT ' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down. ' ) running = False self . close () return","title":"run"},{"location":"reference/hotspot/executive/#sequence","text":"def sequence ( self , fname : str ) On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate None View Source def sequence ( self , fname : str ) : ''' On each call , pop a new command off of the command queue and dispatch it to motors / LabJack . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col : - flasher_cmds : 1 or 0 depending on whether that address is enabled - pos_cmd_0s : 0 th element of position command coordinate - pos_cmd_1s : 1 st element of position command coordinate ''' # If we are changing to sequence from another mode , ensure we start # fresh if self . mode != self . last_mode : logger . info ( ' Beginning command sequence. ' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : return else : cmd = self . cmd_queue . get () progress = 100 . * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks , then LJ tasks in serial , so IR source tasks happen at the end of each move . self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f ' Raft centroid: {self.robot.raft.position} ' ) logger . info ( f ' Command completed. Sequence progress: {progress:.2f} % ' ) # take time to log TM and update display before doing next cmd self . router . process_tm ( plot_enable = self . plot_enable ) return","title":"sequence"},{"location":"reference/hotspot/executive/#wait","text":"def wait ( self ) View Source def wait ( self ) : return","title":"wait"},{"location":"reference/hotspot/hardware/","text":"Module hotspot.hardware None None View Source # This file defines the interfaces used to command the hardware. import logging import numpy as np import serial import threading import time from labjack import ljm import hotspot.constants as const from hotspot.hw_context import stepper , openS , eWriteAddress # Conventions: # - positive steps/angular rates (stepper.FORWARD) spin the motor shaft # clockwise (CW) when viewed from the rear. # - negative steps/angular rates (stepper.BACKWARD) spin the motor shaft # counterclockwise (CCW) when viewed from the rear. logger = logging . getLogger ( __name__ ) # Map relay number to modbus register on the LJ RELAY_DICT = { '1' : 2008 , '2' : 2009 , '3' : 2010 , '4' : 2011 , '5' : 2012 , '6' : 2013 , '7' : 2014 , '8' : 2015 , '9' : 2016 , '10' : 2017 , '11' : 2018 , '12' : 2019 } # Needed to open connection to labjack board MODEL_NAME = 'T7' MODE = 'USB' # ----------------------------------------------------------------------------- # Stepper functions # ----------------------------------------------------------------------------- def all_steppers ( steppers : list , radians : list ): ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters ---------- steppers iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) radians iterable of signed angle to move each stepper (radians) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper ''' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over-tension to mitigate skipping # steps: positive steps first to unwind cable, then negative order = np . argsort ( directions )[:: - 1 ] . astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_to_go = np . round ( np . abs ( radians ) * const . DEG_PER_RAD / const . DEG_PER_STEP ) . astype ( int ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ): if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1, or 1 step per loop cycle. dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2x to allow integer arithmetic for _ in range ( dx ): for i , stepper_n in enumerate ( steppers ): # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ i ] += 1 * stepper_dirs [ i ] deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return def all_steppers_serial ( ser , radians : list ): ''' Step by passing the number of steps as a sequence of integers over serial. This is included as a contingency in the event that Arduino is necessary. Parameters ---------- serial pySerial Serial instance radians iterable of signed angle to move each stepper (radians) Returns ------- ''' # arduino has stepping mode hardcoded, so dont allow runtime changes of steps to radian modifier steps_to_go = np . round ( np . array ( radians ) * const . DEG_PER_RAD / ( 360. / 200. / 8. )) . astype ( int ) . astype ( str ) step_str = ',' . join ( steps_to_go ) + ' \\n ' ser . write ( step_str . encode ()) return steps_to_go . astype ( int ) # ----------------------------------------------------------------------------- # LabJack Functions # ----------------------------------------------------------------------------- def try_open ( model : str , mode : str , retry = True ): ''' Try and open a connection to a LabJack. Parameters ---------- model LabJack board model name, typ. 'T7' mode LabJack communication mode, typ. 'USB' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( 'Error opening LJ connection' ) print ( err ) if retry : time . sleep ( 1 ) print ( 'Trying again in 1s.' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name def write_value ( handle , addr : int , value = 0 ): ''' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not ''' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True def threaded_write ( handle , target : int , value : int ): ''' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer ''' logger . debug ( f 'Trying address { target } state { value } ' ) written = False while ( 1 ): try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return def spawn_all_threads ( handle , states : list ): ''' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take ''' logger . debug ( f 'LJ states: { states } ' ) for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], states [ int ( key ) - 1 ]), daemon = True ) thread . start () return def spawn_all_threads_off ( handle ): ''' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` ''' for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], 0 ), daemon = True ) thread . start () return if __name__ == '__main__' : pass # import serial # import time # with serial.Serial('COM5', 115200) as ser: # time.sleep(2) # all_steppers_serial(ser, np.array(4*[2. * np.pi / 10.])) # all_steppers_serial(ser, np.array(4*[-2. * np.pi])) # from hw_context import MotorKit # kit0 = MotorKit(address=const.HAT_0_ADDR, steppers_microsteps=const.MICROSTEP_NUM, pwm_frequency=const.PWM_FREQ) # kit1 = MotorKit(address=const.HAT_0_ADDR, steppers_microsteps=const.MICROSTEP_NUM, pwm_frequency=const.PWM_FREQ) # steppers = [ # kit1.stepper2, # sw # kit0.stepper1, # ne # kit0.stepper2, # nw # kit1.stepper1] # se # all_steppers(steppers, [np.pi/4., 0, np.pi/4., 0]) # all_steppers(steppers, [0, -np.pi/4., 0, -np.pi/4.]) # [stepper.release() for stepper in steppers] Variables MODE MODEL_NAME RELAY_DICT logger Functions all_steppers def all_steppers ( steppers : list , radians : list ) The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters: Name Type Description Default steppers None iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) None radians None iterable of signed angle to move each stepper (radians) None Returns: Type Description steps_taken iterable of integers reporting the number of steps taken by each stepper View Source def all_steppers ( steppers : list , radians : list ) : ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm , in the pos quadrant only , with all lines starting at ( 0 , 0 ). All motors will either step or not according to the algorithm . ( We are kind of forgoing linear travel speed control here , but we never had reliable speed control anyway , because RPI Debian is not a RT OS .) Parameters ---------- steppers iterable of 4 x Adafruit MotorKit stepper instances ( not adafruit_motor . stepper module ) radians iterable of signed angle to move each stepper ( radians ) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper '' ' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over - tension to mitigate skipping # steps : positive steps first to unwind cable , then negative order = np . argsort ( directions )[ ::- 1 ]. astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_to_go = np . round ( np . abs ( radians ) * const . DEG_PER_RAD / const . DEG_PER_STEP ). astype ( int ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ) : if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1 , or 1 step per loop cycle . dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2 x to allow integer arithmetic for _ in range ( dx ) : for i , stepper_n in enumerate ( steppers ) : # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ i ] += 1 * stepper_dirs [ i ] deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return all_steppers_serial def all_steppers_serial ( ser , radians : list ) Step by passing the number of steps as a sequence of integers over serial. This is included as a contingency in the event that Arduino is necessary. Parameters: Name Type Description Default serial None pySerial Serial instance None radians None iterable of signed angle to move each stepper (radians) None View Source def all_steppers_serial ( ser , radians : list ): ''' Step by passing the number of steps as a sequence of integers over serial. This is included as a contingency in the event that Arduino is necessary. Parameters ---------- serial pySerial Serial instance radians iterable of signed angle to move each stepper (radians) Returns ------- ''' # arduino has stepping mode hardcoded, so dont allow runtime changes of steps to radian modifier steps_to_go = np . round ( np . array ( radians ) * const . DEG_PER_RAD / ( 360. / 200. / 8. )) . astype ( int ) . astype ( str ) step_str = ',' . join ( steps_to_go ) + ' \\n ' ser . write ( step_str . encode ()) return steps_to_go . astype ( int ) spawn_all_threads def spawn_all_threads ( handle , states : list ) Spawns threads and passes the states each relay will need to have Parameters: Name Type Description Default handle None LabJack board model handle from try_open None states None iterable of integers describing the states each relay should take None View Source def spawn_all_threads ( handle , states : list ) : ' '' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take '' ' logger . debug ( f 'LJ states: {states}' ) for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , states [ int ( key ) - 1 ] ), daemon = True ) thread . start () return spawn_all_threads_off def spawn_all_threads_off ( handle ) Spawns threads and sets all relay states off. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None View Source def spawn_all_threads_off ( handle ) : ' '' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` '' ' for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , 0 ), daemon = True ) thread . start () return threaded_write def threaded_write ( handle , target : int , value : int ) Wrapper around write_value for use in threaded calls. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None target None LabJack relay address integer None View Source def threaded_write ( handle , target : int , value : int ) : ' '' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer '' ' logger . debug ( f 'Trying address {target} state {value}' ) written = False while ( 1 ) : try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return try_open def try_open ( model : str , mode : str , retry = True ) Try and open a connection to a LabJack. Parameters: Name Type Description Default model None LabJack board model name, typ. 'T7' None mode None LabJack communication mode, typ. 'USB' None Returns: Type Description name handle to opened LabJack board instance View Source def try_open ( model : str , mode : str , retry = True ) : ''' Try and open a connection to a LabJack . Parameters ---------- model LabJack board model name , typ . ' T7 ' mode LabJack communication mode , typ . ' USB ' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( ' Error opening LJ connection ' ) print ( err ) if retry : time . sleep ( 1 ) print ( ' Trying again in 1s. ' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name write_value def write_value ( handle , addr : int , value = 0 ) Write a value to a LabJack, catching errors. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None addr None LabJack relay address integer None Kwargs None None None ------ None None None value int value to write to LabJack relay None Returns: Type Description bool True if successful, False if not View Source def write_value ( handle , addr : int , value = 0 ) : ' '' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not '' ' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True","title":"Hardware"},{"location":"reference/hotspot/hardware/#module-hotspothardware","text":"None None View Source # This file defines the interfaces used to command the hardware. import logging import numpy as np import serial import threading import time from labjack import ljm import hotspot.constants as const from hotspot.hw_context import stepper , openS , eWriteAddress # Conventions: # - positive steps/angular rates (stepper.FORWARD) spin the motor shaft # clockwise (CW) when viewed from the rear. # - negative steps/angular rates (stepper.BACKWARD) spin the motor shaft # counterclockwise (CCW) when viewed from the rear. logger = logging . getLogger ( __name__ ) # Map relay number to modbus register on the LJ RELAY_DICT = { '1' : 2008 , '2' : 2009 , '3' : 2010 , '4' : 2011 , '5' : 2012 , '6' : 2013 , '7' : 2014 , '8' : 2015 , '9' : 2016 , '10' : 2017 , '11' : 2018 , '12' : 2019 } # Needed to open connection to labjack board MODEL_NAME = 'T7' MODE = 'USB' # ----------------------------------------------------------------------------- # Stepper functions # ----------------------------------------------------------------------------- def all_steppers ( steppers : list , radians : list ): ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters ---------- steppers iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) radians iterable of signed angle to move each stepper (radians) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper ''' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over-tension to mitigate skipping # steps: positive steps first to unwind cable, then negative order = np . argsort ( directions )[:: - 1 ] . astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_to_go = np . round ( np . abs ( radians ) * const . DEG_PER_RAD / const . DEG_PER_STEP ) . astype ( int ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ): if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1, or 1 step per loop cycle. dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2x to allow integer arithmetic for _ in range ( dx ): for i , stepper_n in enumerate ( steppers ): # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ i ] += 1 * stepper_dirs [ i ] deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return def all_steppers_serial ( ser , radians : list ): ''' Step by passing the number of steps as a sequence of integers over serial. This is included as a contingency in the event that Arduino is necessary. Parameters ---------- serial pySerial Serial instance radians iterable of signed angle to move each stepper (radians) Returns ------- ''' # arduino has stepping mode hardcoded, so dont allow runtime changes of steps to radian modifier steps_to_go = np . round ( np . array ( radians ) * const . DEG_PER_RAD / ( 360. / 200. / 8. )) . astype ( int ) . astype ( str ) step_str = ',' . join ( steps_to_go ) + ' \\n ' ser . write ( step_str . encode ()) return steps_to_go . astype ( int ) # ----------------------------------------------------------------------------- # LabJack Functions # ----------------------------------------------------------------------------- def try_open ( model : str , mode : str , retry = True ): ''' Try and open a connection to a LabJack. Parameters ---------- model LabJack board model name, typ. 'T7' mode LabJack communication mode, typ. 'USB' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( 'Error opening LJ connection' ) print ( err ) if retry : time . sleep ( 1 ) print ( 'Trying again in 1s.' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name def write_value ( handle , addr : int , value = 0 ): ''' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not ''' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True def threaded_write ( handle , target : int , value : int ): ''' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer ''' logger . debug ( f 'Trying address { target } state { value } ' ) written = False while ( 1 ): try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return def spawn_all_threads ( handle , states : list ): ''' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take ''' logger . debug ( f 'LJ states: { states } ' ) for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], states [ int ( key ) - 1 ]), daemon = True ) thread . start () return def spawn_all_threads_off ( handle ): ''' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` ''' for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], 0 ), daemon = True ) thread . start () return if __name__ == '__main__' : pass # import serial # import time # with serial.Serial('COM5', 115200) as ser: # time.sleep(2) # all_steppers_serial(ser, np.array(4*[2. * np.pi / 10.])) # all_steppers_serial(ser, np.array(4*[-2. * np.pi])) # from hw_context import MotorKit # kit0 = MotorKit(address=const.HAT_0_ADDR, steppers_microsteps=const.MICROSTEP_NUM, pwm_frequency=const.PWM_FREQ) # kit1 = MotorKit(address=const.HAT_0_ADDR, steppers_microsteps=const.MICROSTEP_NUM, pwm_frequency=const.PWM_FREQ) # steppers = [ # kit1.stepper2, # sw # kit0.stepper1, # ne # kit0.stepper2, # nw # kit1.stepper1] # se # all_steppers(steppers, [np.pi/4., 0, np.pi/4., 0]) # all_steppers(steppers, [0, -np.pi/4., 0, -np.pi/4.]) # [stepper.release() for stepper in steppers]","title":"Module hotspot.hardware"},{"location":"reference/hotspot/hardware/#variables","text":"MODE MODEL_NAME RELAY_DICT logger","title":"Variables"},{"location":"reference/hotspot/hardware/#functions","text":"","title":"Functions"},{"location":"reference/hotspot/hardware/#all_steppers","text":"def all_steppers ( steppers : list , radians : list ) The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters: Name Type Description Default steppers None iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) None radians None iterable of signed angle to move each stepper (radians) None Returns: Type Description steps_taken iterable of integers reporting the number of steps taken by each stepper View Source def all_steppers ( steppers : list , radians : list ) : ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm , in the pos quadrant only , with all lines starting at ( 0 , 0 ). All motors will either step or not according to the algorithm . ( We are kind of forgoing linear travel speed control here , but we never had reliable speed control anyway , because RPI Debian is not a RT OS .) Parameters ---------- steppers iterable of 4 x Adafruit MotorKit stepper instances ( not adafruit_motor . stepper module ) radians iterable of signed angle to move each stepper ( radians ) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper '' ' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over - tension to mitigate skipping # steps : positive steps first to unwind cable , then negative order = np . argsort ( directions )[ ::- 1 ]. astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_to_go = np . round ( np . abs ( radians ) * const . DEG_PER_RAD / const . DEG_PER_STEP ). astype ( int ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ) : if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1 , or 1 step per loop cycle . dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2 x to allow integer arithmetic for _ in range ( dx ) : for i , stepper_n in enumerate ( steppers ) : # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ i ] += 1 * stepper_dirs [ i ] deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return","title":"all_steppers"},{"location":"reference/hotspot/hardware/#all_steppers_serial","text":"def all_steppers_serial ( ser , radians : list ) Step by passing the number of steps as a sequence of integers over serial. This is included as a contingency in the event that Arduino is necessary. Parameters: Name Type Description Default serial None pySerial Serial instance None radians None iterable of signed angle to move each stepper (radians) None View Source def all_steppers_serial ( ser , radians : list ): ''' Step by passing the number of steps as a sequence of integers over serial. This is included as a contingency in the event that Arduino is necessary. Parameters ---------- serial pySerial Serial instance radians iterable of signed angle to move each stepper (radians) Returns ------- ''' # arduino has stepping mode hardcoded, so dont allow runtime changes of steps to radian modifier steps_to_go = np . round ( np . array ( radians ) * const . DEG_PER_RAD / ( 360. / 200. / 8. )) . astype ( int ) . astype ( str ) step_str = ',' . join ( steps_to_go ) + ' \\n ' ser . write ( step_str . encode ()) return steps_to_go . astype ( int )","title":"all_steppers_serial"},{"location":"reference/hotspot/hardware/#spawn_all_threads","text":"def spawn_all_threads ( handle , states : list ) Spawns threads and passes the states each relay will need to have Parameters: Name Type Description Default handle None LabJack board model handle from try_open None states None iterable of integers describing the states each relay should take None View Source def spawn_all_threads ( handle , states : list ) : ' '' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take '' ' logger . debug ( f 'LJ states: {states}' ) for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , states [ int ( key ) - 1 ] ), daemon = True ) thread . start () return","title":"spawn_all_threads"},{"location":"reference/hotspot/hardware/#spawn_all_threads_off","text":"def spawn_all_threads_off ( handle ) Spawns threads and sets all relay states off. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None View Source def spawn_all_threads_off ( handle ) : ' '' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` '' ' for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , 0 ), daemon = True ) thread . start () return","title":"spawn_all_threads_off"},{"location":"reference/hotspot/hardware/#threaded_write","text":"def threaded_write ( handle , target : int , value : int ) Wrapper around write_value for use in threaded calls. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None target None LabJack relay address integer None View Source def threaded_write ( handle , target : int , value : int ) : ' '' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer '' ' logger . debug ( f 'Trying address {target} state {value}' ) written = False while ( 1 ) : try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return","title":"threaded_write"},{"location":"reference/hotspot/hardware/#try_open","text":"def try_open ( model : str , mode : str , retry = True ) Try and open a connection to a LabJack. Parameters: Name Type Description Default model None LabJack board model name, typ. 'T7' None mode None LabJack communication mode, typ. 'USB' None Returns: Type Description name handle to opened LabJack board instance View Source def try_open ( model : str , mode : str , retry = True ) : ''' Try and open a connection to a LabJack . Parameters ---------- model LabJack board model name , typ . ' T7 ' mode LabJack communication mode , typ . ' USB ' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( ' Error opening LJ connection ' ) print ( err ) if retry : time . sleep ( 1 ) print ( ' Trying again in 1s. ' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name","title":"try_open"},{"location":"reference/hotspot/hardware/#write_value","text":"def write_value ( handle , addr : int , value = 0 ) Write a value to a LabJack, catching errors. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None addr None LabJack relay address integer None Kwargs None None None ------ None None None value int value to write to LabJack relay None Returns: Type Description bool True if successful, False if not View Source def write_value ( handle , addr : int , value = 0 ) : ' '' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not '' ' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True","title":"write_value"},{"location":"reference/hotspot/hw_context/","text":"Module hotspot.hw_context None None View Source # This file abstracts the hardware module imports away and provides contingency # modules so dev and testing can be done on a non-rpi machine without hardware # attached. from adafruit_motor import stepper from labjack import ljm try : from adafruit_motorkit import MotorKit except NotImplementedError as err : print ( err ) print ( 'No Adafruit MotorKit module compatibility found at import. Falling back to dummy class for simulation support.' ) class DummyStepperMotor : def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass # Dummy motorkit class MotorKit : def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor () try : name = ljm . openS ( 'T7' , 'USB' ) eWriteAddress = ljm . eWriteAddress openS = ljm . openS except ljm . LJMError as err : print ( err ) print ( 'No LabJack modules found at import. Falling back to dummy class for simulation support.' ) def dummyEwriteAddress ( handle , addr , mode , value ): return def dummyOpenS ( model : str , mode : str ): return None # Overwrite eWriteAddress = dummyEwriteAddress openS = dummyOpenS Functions dummyEwriteAddress def dummyEwriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return dummyOpenS def dummyOpenS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None eWriteAddress def eWriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return openS def openS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None Classes DummyStepperMotor class DummyStepperMotor ( ) View Source class DummyStepperMotor: def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass Methods onestep def onestep ( self , direction = 1 , style = 1 ) View Source def onestep(self, direction=1, style=1): pass release def release ( self ) View Source def release(self): pass MotorKit class MotorKit ( address = 0 , steppers_microsteps = 1 , pwm_frequency = 1600 ) View Source class MotorKit: def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor ()","title":"Hw Context"},{"location":"reference/hotspot/hw_context/#module-hotspothw_context","text":"None None View Source # This file abstracts the hardware module imports away and provides contingency # modules so dev and testing can be done on a non-rpi machine without hardware # attached. from adafruit_motor import stepper from labjack import ljm try : from adafruit_motorkit import MotorKit except NotImplementedError as err : print ( err ) print ( 'No Adafruit MotorKit module compatibility found at import. Falling back to dummy class for simulation support.' ) class DummyStepperMotor : def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass # Dummy motorkit class MotorKit : def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor () try : name = ljm . openS ( 'T7' , 'USB' ) eWriteAddress = ljm . eWriteAddress openS = ljm . openS except ljm . LJMError as err : print ( err ) print ( 'No LabJack modules found at import. Falling back to dummy class for simulation support.' ) def dummyEwriteAddress ( handle , addr , mode , value ): return def dummyOpenS ( model : str , mode : str ): return None # Overwrite eWriteAddress = dummyEwriteAddress openS = dummyOpenS","title":"Module hotspot.hw_context"},{"location":"reference/hotspot/hw_context/#functions","text":"","title":"Functions"},{"location":"reference/hotspot/hw_context/#dummyewriteaddress","text":"def dummyEwriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return","title":"dummyEwriteAddress"},{"location":"reference/hotspot/hw_context/#dummyopens","text":"def dummyOpenS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None","title":"dummyOpenS"},{"location":"reference/hotspot/hw_context/#ewriteaddress","text":"def eWriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return","title":"eWriteAddress"},{"location":"reference/hotspot/hw_context/#opens","text":"def openS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None","title":"openS"},{"location":"reference/hotspot/hw_context/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/hw_context/#dummysteppermotor","text":"class DummyStepperMotor ( ) View Source class DummyStepperMotor: def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass","title":"DummyStepperMotor"},{"location":"reference/hotspot/hw_context/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/hw_context/#onestep","text":"def onestep ( self , direction = 1 , style = 1 ) View Source def onestep(self, direction=1, style=1): pass","title":"onestep"},{"location":"reference/hotspot/hw_context/#release","text":"def release ( self ) View Source def release(self): pass","title":"release"},{"location":"reference/hotspot/hw_context/#motorkit","text":"class MotorKit ( address = 0 , steppers_microsteps = 1 , pwm_frequency = 1600 ) View Source class MotorKit: def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor ()","title":"MotorKit"},{"location":"reference/hotspot/telemetry/","text":"Module hotspot.telemetry None None View Source # This file defines functions for outputting telemetry (TM) and visualization. import logging import matplotlib.pyplot as plt import multiprocessing as mp import numpy as np import os import time import h5py import hotspot.constants as const logger = logging . getLogger ( __name__ ) class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ): logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle [ source ] . keys () if 'utc' not in key . lower ()] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: { source } ' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten ()[ i ] for i , key in enumerate ( keys )} plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ): ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self . source ][ 'Time UTC (s)' ] data = file_handle [ self . source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower (): if first_time : ax . plot ( data [:, 0 ], data [:, 1 ], color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [:, 0 ], data [:, 1 ]) else : # line plot for timeseries if first_time : ax . plot ( time [:], data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ]): ax . lines [ j ] . set_data ( time [:], data [:, j ]) else : logger . warn ( f '[ { varname } ] Plotting data of shape { data . shape } not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return class DataRouter : def __init__ ( self , tm_queue : mp . Queue ): logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m %d -%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ): ''' Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. ''' # Otherwise, create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys (): # Get a group, making it if it doesn't exist if source not in f . keys (): f . create_group ( source ) group = f [ source ] for var in packet [ source ] . keys (): data = packet [ source ][ var ] # Get a dataset, making it if it doesn't exist if var in group . keys (): dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1 :])) dset [ - 1 ] = data else : data = np . array ([ packet [ source ][ var ]]) maxshape = ( None , * data . shape [ 1 :]) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ): ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty (): self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def update_display ( self ): ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys (): first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys (): self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys (): if 'utc' in var . lower (): continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Variables logger Classes DataRouter class DataRouter ( tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7fb736fd9940 >> ) View Source class DataRouter : def __init__ ( self , tm_queue : mp . Queue ) : logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m%d-%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Methods process_packet def process_packet ( self , packet : dict ) Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. View Source def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return process_tm def process_tm ( self , plot_enable = False ) Function to continuously log TM to file and update plots as TM comes in. View Source def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in . ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () update_display def update_display ( self ) Function to update plotters. View Source def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Visualizer class Visualizer ( file_handle : h5py . _hl . files . File , source : str ) View Source class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ) : logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle[source ] . keys () if 'utc' not in key . lower () ] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: {source}' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten () [ i ] for i , key in enumerate ( keys ) } plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return Methods update_subplot def update_subplot ( self , file_handle : h5py . _hl . files . File , varname : str , first_time : bool ) View Source def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"Telemetry"},{"location":"reference/hotspot/telemetry/#module-hotspottelemetry","text":"None None View Source # This file defines functions for outputting telemetry (TM) and visualization. import logging import matplotlib.pyplot as plt import multiprocessing as mp import numpy as np import os import time import h5py import hotspot.constants as const logger = logging . getLogger ( __name__ ) class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ): logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle [ source ] . keys () if 'utc' not in key . lower ()] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: { source } ' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten ()[ i ] for i , key in enumerate ( keys )} plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ): ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self . source ][ 'Time UTC (s)' ] data = file_handle [ self . source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower (): if first_time : ax . plot ( data [:, 0 ], data [:, 1 ], color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [:, 0 ], data [:, 1 ]) else : # line plot for timeseries if first_time : ax . plot ( time [:], data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ]): ax . lines [ j ] . set_data ( time [:], data [:, j ]) else : logger . warn ( f '[ { varname } ] Plotting data of shape { data . shape } not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return class DataRouter : def __init__ ( self , tm_queue : mp . Queue ): logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m %d -%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ): ''' Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. ''' # Otherwise, create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys (): # Get a group, making it if it doesn't exist if source not in f . keys (): f . create_group ( source ) group = f [ source ] for var in packet [ source ] . keys (): data = packet [ source ][ var ] # Get a dataset, making it if it doesn't exist if var in group . keys (): dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1 :])) dset [ - 1 ] = data else : data = np . array ([ packet [ source ][ var ]]) maxshape = ( None , * data . shape [ 1 :]) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ): ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty (): self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def update_display ( self ): ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys (): first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys (): self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys (): if 'utc' in var . lower (): continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"Module hotspot.telemetry"},{"location":"reference/hotspot/telemetry/#variables","text":"logger","title":"Variables"},{"location":"reference/hotspot/telemetry/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/telemetry/#datarouter","text":"class DataRouter ( tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7fb736fd9940 >> ) View Source class DataRouter : def __init__ ( self , tm_queue : mp . Queue ) : logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m%d-%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"DataRouter"},{"location":"reference/hotspot/telemetry/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/telemetry/#process_packet","text":"def process_packet ( self , packet : dict ) Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. View Source def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return","title":"process_packet"},{"location":"reference/hotspot/telemetry/#process_tm","text":"def process_tm ( self , plot_enable = False ) Function to continuously log TM to file and update plots as TM comes in. View Source def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in . ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display ()","title":"process_tm"},{"location":"reference/hotspot/telemetry/#update_display","text":"def update_display ( self ) Function to update plotters. View Source def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"update_display"},{"location":"reference/hotspot/telemetry/#visualizer","text":"class Visualizer ( file_handle : h5py . _hl . files . File , source : str ) View Source class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ) : logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle[source ] . keys () if 'utc' not in key . lower () ] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: {source}' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten () [ i ] for i , key in enumerate ( keys ) } plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"Visualizer"},{"location":"reference/hotspot/telemetry/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/telemetry/#update_subplot","text":"def update_subplot ( self , file_handle : h5py . _hl . files . File , varname : str , first_time : bool ) View Source def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"update_subplot"}]}