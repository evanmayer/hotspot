{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This repo contains code that is a part of the TIME collaboration . Logo by Guochao (Jason) Sun. hotspot Code for simulating and driving a cable-driven parallel robot for mapping beams on surfaces. Running Run python main.py -h for the docstring describing the command line interface. Example python main.py ./data/input/geometry/frame.csv ./data/input/profiles/circle.csv Dependencies Creating a conda environment I use miniconda to keep my development environments separate. If there is a .yml file available that lists the dependencies I need, I run conda env create -f <filename>.yml to use it to make a new conda env with those dependencies. Conda parses the contents, creates a new env with the given name, and installs the required packages. Updating .yml as new dependencies are needed I periodically use conda env export --from-history | tee hotspot.yml to dump whatever I've manually installed so far into the .yml. This avoids specifying exact versions of packages, but will still try to install all the packages needed. To update the environment as changes are made to hotspot.yml , run conda env update --name hotspot --file hotspot.yml --prune LabJack libraries Driving Hawkeye sources with LabJack modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack, and the hotspot.yml file will handle the Python install via pip . Contributing Testing Testing is accomplished with pytest . Passing tests are a prerequisite for committing code, and new code should come with new tests. To run the test suite defined in the tests dir, change dir to the toplevel dir of the repo and execute pytest Pushing changes If you need push permissions, message me. Otherwise, you may fork, create a new branch with your changes, and fill out a Pull Request to have the changes reviewed and merged in. How did you make your algorithm flowcharts? diagrams.net","title":"Home"},{"location":"#hotspot","text":"Code for simulating and driving a cable-driven parallel robot for mapping beams on surfaces.","title":"hotspot"},{"location":"#running","text":"Run python main.py -h for the docstring describing the command line interface.","title":"Running"},{"location":"#example","text":"python main.py ./data/input/geometry/frame.csv ./data/input/profiles/circle.csv","title":"Example"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#creating-a-conda-environment","text":"I use miniconda to keep my development environments separate. If there is a .yml file available that lists the dependencies I need, I run conda env create -f <filename>.yml to use it to make a new conda env with those dependencies. Conda parses the contents, creates a new env with the given name, and installs the required packages.","title":"Creating a conda environment"},{"location":"#updating-yml-as-new-dependencies-are-needed","text":"I periodically use conda env export --from-history | tee hotspot.yml to dump whatever I've manually installed so far into the .yml. This avoids specifying exact versions of packages, but will still try to install all the packages needed. To update the environment as changes are made to hotspot.yml , run conda env update --name hotspot --file hotspot.yml --prune","title":"Updating .yml as new dependencies are needed"},{"location":"#labjack-libraries","text":"Driving Hawkeye sources with LabJack modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack, and the hotspot.yml file will handle the Python install via pip .","title":"LabJack libraries"},{"location":"#contributing","text":"","title":"Contributing"},{"location":"#testing","text":"Testing is accomplished with pytest . Passing tests are a prerequisite for committing code, and new code should come with new tests. To run the test suite defined in the tests dir, change dir to the toplevel dir of the repo and execute pytest","title":"Testing"},{"location":"#pushing-changes","text":"If you need push permissions, message me. Otherwise, you may fork, create a new branch with your changes, and fill out a Pull Request to have the changes reviewed and merged in.","title":"Pushing changes"},{"location":"#how-did-you-make-your-algorithm-flowcharts","text":"diagrams.net","title":"How did you make your algorithm flowcharts?"},{"location":"HOWTO/","text":"How To This doc contains instructions for various tasks related to setting up and running the hotspot mirror mapper. What is hotspot ? hotspot is a cable-driven parallel robot (CDPR), with four stepper motors that move a central raft of hot IR sources, mounted on an adjustable frame. It clamps to various relay mirrors that couple radiation from the sky to the TIME spectrometer inside the receiver cabin on the APA 12M telescope on Kitt Peak, allowing an electronically controlled, hot, IR-emitting source to be swept across the mirror to observe the detectors' spatial response. timepi , the Raspberry Pi control computer The stepper motors and IR sources are controlled by logging into the Raspberry Pi and running the main.py application. You do not need to check out this repo onto a personal computer unless you wish to generate new input files . Can you talk to the Raspberry Pi? You can log in to the Raspberry Pi via ssh . In order for your computer to \"see\" it, though, they must be on the same network. This can be accomplished a few ways (or order of ease of use): By connecting both computers to a router or network switch that can assign each connected device an IP address automatically. Wired is easier than wireless . By connecting directly to the pi via an Ethernet patch cable and setting up a link-local connection By connecting directly to the pi via an Ethernet patch cable and assigning static IP addresses to each host. The first option is the easiest, but depends on having access to an exisiting network, so limits your connectivity options. If you have access to a Linux machine, the second option is about as easy. The hostname and password are printed on the bottom of the white plastic case. Once you think the connection is sorted out, ping the pi to check: ping timepi.local The ssh command goes like this: ssh -X pi@timepi.local -X allows X-forwarding, in case a graphical application (like plotting) is invoked. You will be prompted for a password, which you can find printed on the bottom of the white plastic Raspberry Pi case. Setting Up the Environment (Raspberry Pi) Is the environment set up? First, check that the environment setup has not been done before. If conda activate hotspot succeeds, skip these steps . Python Dependencies Anaconda Is Anaconda set up? If the Python environment/package manager Anaconda does not exist on the Raspberry Pi you're running this on, I recommend installing Miniconda like this: curl \"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-armv7l.sh\" -o \"Miniconda.sh\" chmod +x Miniconda.sh ./Miniconda.sh Once that is done, we are ready to set up the hotspot environment. conda environments keep a project's dependencies from polluting your computer's environment and make sure they all play nicely together. conda allows specifying the dependencies needed in a file with a .yml extension. This is done for you. Create the hotspot conda env with conda env create -f hotspot.yml It should install things like numpy and matplotlib , as well as libraries for the hardware, such as Adafruit's adafruit-circuitpython-motorkit library for driving the steppers, and the labjack-ljm library for controlling the Hawkeye IR sources via the LabJack. There are also packages for documentation. Is the LabJack library installed? NOTE: Driving Hawkeye sources with LabJack Python modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack. Once that is done, activate the env with conda activate hotspot Keeping things up to date If you need to install something new later on, remember to update hotspot.yml by doing conda env export --from-history | tee hotspot.yml If your hotspot.yml has been updated, and you need to update your env with the new hotspot.yml , do conda env update --file hotspot.yml --prune Software Testing with pytest In order to verify that basic low-level functionality is unbroken, run pytest from the toplevel directory of the repo. Setting Up the Hardware Enable Raspberry Pi Hardware Can the Raspberry Pi talk to the motor drivers? The Raspberry Pi should have at least two motor driver hat boards . These are blue PCBs with onboard chips that talk to the Raspberry Pi on an I2C bus via the 2x20 header pins. They issue commands to the motor driver chips, which handle the delivery and timing of greater voltage and current than the Raspberry Pi is capable of on its own. If you are using a factory fresh Raspberry Pi, follow the steps for Enabling I2C communication from Adafruit. NOTE: A backup pdf of instructions for this is saved in the pdf dir. Power Are the power supply settings correct? To power both the motors and Hawkeyes simultaneously, use a GW Instek GPS-4303 power supply or equivalent; channels must supply: 12V constant voltage, 4A peak instantaneous current 6.7V constant voltage, 2A peak instantaneous current 5V constant voltage, 1A peak instantaneous current (optional, for chopped signal to TIME MCE CLK card) Set the GW Instek GPS-4303 CH1, CH2, and optionally CH3 supply as shown: Ensure the current limit knobs for each channel are sufficient to keep the power supply in constant voltage mode, even when the motors and Hawkeyes are drawing current. The C.V. indicator light should stay green. Motors Do the motor driver boards have power? The Raspberry Pi cannot provide the requisite voltage or current to the motors on its own, so external power must be supplied. The motor controllers on each hat are designed to run with 5-12V, with a maximum instantaneous current of ~1.2A per channel. For stacking multiple hats, jumpers are attached to the screw terminals to route +/- voltage to the additional hats. A lab power supply with 12V output is attached to the +/- screw terminal block on the motor driver hat. As you can see, it's easiest to use leads with grabber probes to grab onto the +/- jumpers. LabJack Do the Hawkeyes have power via the LabJack? The LabJack T7 with PS12DC power switching board also needs its own power supply. A tunable lab power supply is attached to one of the screw terminals labeled \"VS#,\" for \"voltage source #,\" where # is one of the channels, 1-6. The Hawkeye IR-50 source temperature depends on the voltage applied, and the current draw depends on the voltage (see datasheet in pdf dir). The design target temperature is 750 C, requiring a voltage of 6.7V and a current of ~134mA per source, for a total current draw of ~1.74A when all sources are turned on. In practice, Hawkeye sources have not drawn quite this much current. Connect the power supply and Hawkeye source wires to the LabJack as shown: Optional: MCE CLK Sync It may be desirable to supply the same chopped signal the Hawkeyes see, but at 5V, to the MCE CLK card via a BNC cable. If this is desired, use the power supply CH3 set to 5V, and attach to +5V and GND to the terminal labeled S4. Motion Outputs Motors Can the motor drivers command the motors? If they are not already connected, motors should be connected to the screw terminals of the pi's stepper hat like this: Getting the order right ensures the stepper's coils are energized in the correct sequence to get it to rotate. The stepper motors themselves have NEMA-17 spec hole patterns, which mate to the 3D printed motor mount brackets which we will attach to the beam mapper frame. Each stepper motor should be attached to its motor mount using M3 x 0.5 x 10 mm screws. Use lubricant, because metal on plastic will be squeaky. At this point, it is important to consider the mapping of motor driver terminal -> stepper motor -> motor mount -> corner of beam mapper frame. The Executive.__init__() function specifies this mapping, so the motor installation location and stepper instance in __init__() should match, to ensure the correct motor commands are sent to the correct stepper. Steppers and wire harnesses are labeled to assist with this. In general, the driver board closest to the Pi (0n bottom) will be kit0 (although this can be double-checked by looking at the address - 0x60 is the default I2C address for the hat, which can be changed by bridging the HAT pads A0-A4, so the board addressed by 0x60 will have no pads bridged). The terminal blocks M1-M2 are used for stepper1 on each HAT, and M3-M4 are used for stepper2 . It doesn't really matter which terminal maps to which corner, but it really does matter that the code and physical arrangement agree. Spools Can the motors make the lines longer and shorter? If they are not already attached, the spools should be fixed to the 5 mm stepper motor shaft via one M3 setscrew. The fishing line is affixed to the each spool by wrapping it around the setscrew and screwing it in to the threaded recess on the spool circumference. Do not overtighten, as the threads are plastic. NOTE: Positive motor rotation is defined by convention to spin the shaft clockwise when viewed from the rear of the motor. Cables should be oriented relative to the spool such that a positive motor rotation produces a positive cable length change (i.e., cable is played out from the spool), and a negative motor rotation winds cable onto the spool. After attaching the cables to the spools, the other end should be threaded through the ~.9mm hole in the motor mount bracket. NOTE: All cables should be long enough to permit the raft to visit each corner of the frame, even when the frame is as far apart as it can be (~25.5\"). Finally, excess cable should be wound onto the spool, under tension, to avoid trapping excess cable underneath as the cable is wound on. This process should be done by hand. Raft Will moving the cables move the Hawkeyes? The end effector of this robot is a rectangular raft carrying several Hawkeye Technologies IR-50 emitters. The robot drives the centroid of the effector to a specified position, and the control algorithm performs a specific sequence of flashes using a number of the emitters to enhance the detectability of the signal in the TIME receiver output data. If the raft is not already attached to the cables, the raft cap with the Hawkeye emitters must be removed to access the screws to fix the affix the lines. Simply pass them through the raft's eyelets, wrapping the ends of the fishing line around the screws in each corner of the raft, and screwing them down. Cable Maintenance What if a cable breaks? The lid of the raft is secured by clips and a dab of cyanoacrylate glue in each corner. If the cables need to be changed (e.g., they are worn), an exacto blade can be used to break the CA glue in the corners and remove the lid. The original cable is Spiderwire EZ Braid braided dyneema fishing line (50 lb pull strength), chosen for its stretch resistance. A replacement can be found at any tackle store or Wal-Mart, but a spool of extra cable should already be stored with the beam mapper. Frame Is the frame fully assembled? The 3D printed stepper motor mounts are attached to the beam mapper frame by 5/16-18 x 2\" or 2.25\" bolts with nyloc \"jam\" nuts. Two aluminum registration tabs are screwed into the end of each frame piece opposite the black plastic end caps, using a 5/16-18 x 1/4\" screw. They are long enough to reach an edge of the mirror regardless of if the mirror's corners have been machined off. NOTE: These tabs register the frame to a third edge of the mirror, so it is important that they not be bent . Long 5/16-18 steel threaded rods connect the two halves of the frame. On one end of the threaded rods, a nyloc \"jam\" nut on the outside of the perforated aluminum extrusion provides clamping force. On the other end of the threaded rod, a slide-adjust nut with a thumb button allows easily changing the distance between clamping surfaces, and applies clamping force to the outside of the opposite aluminum extrusion. Coordinate System In order for the raft to be moved to a meaningful position in mirror-space, coordinates must be referenced to sensible locations where the mirror edges and robot frame register to one another. x-axis : plane of contact between the \"south\" frame and an edge of the mirror y-axis : plane of contact between the \"west\" side aluminum registration tab and a perpendicular mirror edge. The coordinate system of the robot therefore has its origin at the SW corner, where the aluminum alignment tab on the fixed frame meets the aluminum extrusion face. Input Files There are two types of input files: geometry and profile . Read on to learn what they are for and what is inside each. Ok, but is there an easy way to make a new one? .ipynb files are provided in the data/input/* directories to assist with making these input files. Most likely, you will only need data/input/create_profile.ipynb . The Raspberry Pi does not have Jupyter installed, so you would need a local checkout of hotspot or a copy of these notebooks to run on your own machine. Then simply copy the new files to the Raspberry Pi's /data/input/* directory with scp . Geometry Geometry files are one-line .csv files in data/input/geometry . create_geometry.ipynb is provided to script the creation of geometry files. Each one defines the physical setup of the robot when it is in a certain configuration, for instance, when it is installed on a mirror of a certain dimension. Each column entry describes an aspect of the physical setup of the system. A simplistic example: sw_0 sw_1 nw_0 nw_1 se_0 se_1 ne_0 ne_1 w h 0 0 0 1 1 0 1 1 .1 .1 Each corner point is the location of an eyelet through which the cable passes, expressed relative to the SW origin, described above. The width and height of the raft are defined by the separations between eyelets on the raft through which the cable passes. NOTE: Since the dimensions of the motor mounts have been measured relative to each edge, the y-positions of the corner eyelets can be calculated as a function of the separation between the aluminum extrusions that make up the support structure and clamping surfaces. The eyelets of the motor mounts measured 6.19 +/- 0.5 mm from the frame to the face of the motor mount bracket on the interior of the mapping region, and 7.96 +/- 0.02 mm from the face of the motor mount to the eyelet, for a total eyelet offset from the contact patch of 0.014 +/- 0.001 m. This value will be used to calculate eyelet y-positions as a function of frame separation. The eyelet positions should not ever change in the x-direction, unless the motor mounts are removed from the aluminum frames. Profile Profile files are multi-line .csv files in data/input/profiles . Each one defines a new position to which the robot should move, in the coordinate system defined above. geometry/create_profile.ipynb is provided to script the creation of profiles. Upon reaching each location in the profile, the robot is programmed to flash Hawkeye sources on and off (default: 10 \"on\" states, 50% duty cycle, 5 Hz). Which group of sources is enabled is configurable with the flasher_cmds column in the profile .csv. Each 0 or 1, space-separated, in the first column, corresponds to one of twelve addressable solid state switchable voltage sources on the LabJack PS12DC Power Switching Board. The index-to-address mapping is defined in the dictionary at the top of hardware.py . Since there are 3 groups of Hawkeye sources, there are more addressable relays than strictly necessary. For example, to move to a single coordinate and flash all addresses: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 1 1 1 1 1 1 1 1 1 .5 .5 to move to a single coordinate and flash only the center Hawkeye: flasher_cmds pos_cmd_0s pos_cmd_1s 1 0 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash the center and inner ring Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash all Hawkeyes (center, inner ring, outer ring): flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 0 0 0 0 0 0 0 0 0 .5 .5 Building up a sequence of moves allows a shape to be scanned. Output Files Output files store telemetry for each run in data/output . They are timestamped .hdf5 files. Physical Installation and Operation Physical Installation General tips Having two people helps. BE VERY CAREFUL about touching the buttons on the black slide-adjust nuts If you are adjusting the mapper spacing and you let them off of the threaded rod, they will disassemble themselves rapidly. You don't want to lose any parts. If you are loosening or tightening the mapper down to anything, when the mapper is under tension, touching the button could release tension rapidly, potentially causing a fall, which you do not want. Bring a power strip to make moving the PSU and Raspberry Pi to various mirrors easier. Bring a long ethernet cable to plug the Raspberry Pi into the rack's network switch. Don't bother trying to tape Eccosorb to anything. Just pinch it in between the mirror and threaded rod. This also helps keep the threaded rod from marring the mirror surface. Keep as much stuff as possible out of the path of the beam. K1 Underneath shutter, highest up. Put a step ladder inside the K-mirror frame to make the lift easier. Route Hawkeye cables around back of K1 and down. python main.py ./data/input/geometry/K1.csv ./data/input/profiles/K1_<profile>.csv K2 Should be easy. Remove the anti-head-smasher foam first. python main.py ./data/input/geometry/K2.csv ./data/input/profiles/K2_<profile>.csv K3 Pucker factor 11. Gravity is working against you, and you're right on top of F1, but snug things down good and tight when mounting the mapper and you will be fine. I used a crescent wrench on the black slide-adjust nuts for this one. Be careful not to release the slide-adjust nuts when using the wrench. python main.py ./data/input/geometry/K3.csv ./data/input/profiles/K3_<profile>.csv F1 Another easy one. python main.py ./data/input/geometry/F1.csv ./data/input/profiles/F1_<profile>.csv P2 Not currently reachable (clearance issues). Operation When a surface geometry file has been created and the profile for the given shape to be mapped is generated, we are ready to run the program. There should already be geometry and profile files in the data/input directories. A Note on Homing Homing a system with no stall sensing in the motor driver solution and no limit switches is possible, but crude. To get around the fact that there is no feedback, the current homing solution is to release all but one axis, then issue enough retracting steps to the remaining motor to ensure the raft has reached the limit of its travel toward that axis (NW at the time of writing). This axis is then held while the other steppers issue enough retracting steps to ensure all cables are taut. The raft is then in a known position and orientation relative to the frame, so the mapper is homed. You will hear and see vibration while this happens. It is a simple, hands-free homing solution, but there is plenty of room for improvement here. Sensors would not be hard to add, would speed up homing, and would reduce the wear on cables (and probably motors) due to the current solution. Pre-mapping checks Make sure that 12V is being supplied to both motor driver boards in the stack, that the polarity is correct. Make sure that 6.7V or less is being supplied to the LabJack switching board. Make sure the power supply output is on. Make sure that the cable is wound onto each spool and that no loops of excess cable are trapped underneath the cable wound onto the spools. Check the excess cable played out in the raft's current position. Some excess is fine as long as it doesn't interfere with the raft's motion. If the cable is taut before homing, this is also fine, but the homing routine may need to be run a few times before the raft reaches the home position. Ensure the Hawkeye source signal lines won't interfere with mapper operation. Ensure the hotspot conda env is active: conda activate hotspot . Mapping Start the program with python main.py ./data/input/geometry/<geometry.csv> ./data/input/profiles/<profile.csv> Perform a homing calibration: c , RETURN key. The NW motor will drive the raft to the NW corner while the NE, SW, SE axes go slack, and NW should begin skipping steps after reaching the limit. This (and some noise) is normal. The other axes then tension automatically. Verify that the raft reached its home against the NW corner, and that the other axes achieved tension. If not, GOTO 2. Perform a mapping sequence: s , RETURN key. The raft will drive to each location and flash the Hawkeyes at each point in the sequence. Observe the mapper, ensuring the Hawkeye signal cable does not interfere with the mapper. You may request a mode change at any time. Mode changes are processed at the end of each move. You may abort the program with Ctrl+C . Upon completing a sequence, it may be repeated by requesting the sequence mode again. Other Documentation Example Call Graph Generated without motors or LabJack attached, so this does not include overhead of those libraries, but the control flow is the same. Module Flow Charts Executive Reference HTML The html documentation of the source code and Markdown materials is generated by portray . To regenerate the documentation, execute: portray as_html -m hotspot -o docs/html/ --overwrite pycallgraph To re-generate the call graph image, directory, run pycallgraph -i \"alg*\" -i \"const*\" -i \"exec*\" -i \"hardw*\" -i \"hot*\" -i \"hw*\" -i \"tele*\" graphviz --output-file = ../doc/img/pycallgraph.png -- main.py ../data/input/geometry/frame.csv ../data/input/profiles/box_frame.csv You must have graphviz installed using your operating system's package manager. For most accurate graph and timing information, do this with all peripheral hardware attached, so the call graphs include interfacing with the motor drivers and LabJack.","title":"Howto"},{"location":"HOWTO/#how-to","text":"This doc contains instructions for various tasks related to setting up and running the hotspot mirror mapper.","title":"How To"},{"location":"HOWTO/#what-is-hotspot","text":"hotspot is a cable-driven parallel robot (CDPR), with four stepper motors that move a central raft of hot IR sources, mounted on an adjustable frame. It clamps to various relay mirrors that couple radiation from the sky to the TIME spectrometer inside the receiver cabin on the APA 12M telescope on Kitt Peak, allowing an electronically controlled, hot, IR-emitting source to be swept across the mirror to observe the detectors' spatial response.","title":"What is hotspot?"},{"location":"HOWTO/#timepi-the-raspberry-pi-control-computer","text":"The stepper motors and IR sources are controlled by logging into the Raspberry Pi and running the main.py application. You do not need to check out this repo onto a personal computer unless you wish to generate new input files .","title":"timepi, the Raspberry Pi control computer"},{"location":"HOWTO/#can-you-talk-to-the-raspberry-pi","text":"You can log in to the Raspberry Pi via ssh . In order for your computer to \"see\" it, though, they must be on the same network. This can be accomplished a few ways (or order of ease of use): By connecting both computers to a router or network switch that can assign each connected device an IP address automatically. Wired is easier than wireless . By connecting directly to the pi via an Ethernet patch cable and setting up a link-local connection By connecting directly to the pi via an Ethernet patch cable and assigning static IP addresses to each host. The first option is the easiest, but depends on having access to an exisiting network, so limits your connectivity options. If you have access to a Linux machine, the second option is about as easy. The hostname and password are printed on the bottom of the white plastic case. Once you think the connection is sorted out, ping the pi to check: ping timepi.local The ssh command goes like this: ssh -X pi@timepi.local -X allows X-forwarding, in case a graphical application (like plotting) is invoked. You will be prompted for a password, which you can find printed on the bottom of the white plastic Raspberry Pi case.","title":"Can you talk to the Raspberry Pi?"},{"location":"HOWTO/#setting-up-the-environment-raspberry-pi","text":"","title":"Setting Up the Environment (Raspberry Pi)"},{"location":"HOWTO/#is-the-environment-set-up","text":"First, check that the environment setup has not been done before. If conda activate hotspot succeeds, skip these steps .","title":"Is the environment set up?"},{"location":"HOWTO/#python-dependencies","text":"","title":"Python Dependencies"},{"location":"HOWTO/#anaconda","text":"","title":"Anaconda"},{"location":"HOWTO/#is-anaconda-set-up","text":"If the Python environment/package manager Anaconda does not exist on the Raspberry Pi you're running this on, I recommend installing Miniconda like this: curl \"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-armv7l.sh\" -o \"Miniconda.sh\" chmod +x Miniconda.sh ./Miniconda.sh Once that is done, we are ready to set up the hotspot environment. conda environments keep a project's dependencies from polluting your computer's environment and make sure they all play nicely together. conda allows specifying the dependencies needed in a file with a .yml extension. This is done for you. Create the hotspot conda env with conda env create -f hotspot.yml It should install things like numpy and matplotlib , as well as libraries for the hardware, such as Adafruit's adafruit-circuitpython-motorkit library for driving the steppers, and the labjack-ljm library for controlling the Hawkeye IR sources via the LabJack. There are also packages for documentation.","title":"Is Anaconda set up?"},{"location":"HOWTO/#is-the-labjack-library-installed","text":"NOTE: Driving Hawkeye sources with LabJack Python modules requires both the system libraries and the Python interface to be installed. Download and install the LJM libraries from LabJack. Once that is done, activate the env with conda activate hotspot","title":"Is the LabJack library installed?"},{"location":"HOWTO/#keeping-things-up-to-date","text":"If you need to install something new later on, remember to update hotspot.yml by doing conda env export --from-history | tee hotspot.yml If your hotspot.yml has been updated, and you need to update your env with the new hotspot.yml , do conda env update --file hotspot.yml --prune","title":"Keeping things up to date"},{"location":"HOWTO/#software-testing-with-pytest","text":"In order to verify that basic low-level functionality is unbroken, run pytest from the toplevel directory of the repo.","title":"Software Testing with pytest"},{"location":"HOWTO/#setting-up-the-hardware","text":"","title":"Setting Up the Hardware"},{"location":"HOWTO/#enable-raspberry-pi-hardware","text":"","title":"Enable Raspberry Pi Hardware"},{"location":"HOWTO/#can-the-raspberry-pi-talk-to-the-motor-drivers","text":"The Raspberry Pi should have at least two motor driver hat boards . These are blue PCBs with onboard chips that talk to the Raspberry Pi on an I2C bus via the 2x20 header pins. They issue commands to the motor driver chips, which handle the delivery and timing of greater voltage and current than the Raspberry Pi is capable of on its own. If you are using a factory fresh Raspberry Pi, follow the steps for Enabling I2C communication from Adafruit. NOTE: A backup pdf of instructions for this is saved in the pdf dir.","title":"Can the Raspberry Pi talk to the motor drivers?"},{"location":"HOWTO/#power","text":"","title":"Power"},{"location":"HOWTO/#are-the-power-supply-settings-correct","text":"To power both the motors and Hawkeyes simultaneously, use a GW Instek GPS-4303 power supply or equivalent; channels must supply: 12V constant voltage, 4A peak instantaneous current 6.7V constant voltage, 2A peak instantaneous current 5V constant voltage, 1A peak instantaneous current (optional, for chopped signal to TIME MCE CLK card) Set the GW Instek GPS-4303 CH1, CH2, and optionally CH3 supply as shown: Ensure the current limit knobs for each channel are sufficient to keep the power supply in constant voltage mode, even when the motors and Hawkeyes are drawing current. The C.V. indicator light should stay green.","title":"Are the power supply settings correct?"},{"location":"HOWTO/#motors","text":"","title":"Motors"},{"location":"HOWTO/#do-the-motor-driver-boards-have-power","text":"The Raspberry Pi cannot provide the requisite voltage or current to the motors on its own, so external power must be supplied. The motor controllers on each hat are designed to run with 5-12V, with a maximum instantaneous current of ~1.2A per channel. For stacking multiple hats, jumpers are attached to the screw terminals to route +/- voltage to the additional hats. A lab power supply with 12V output is attached to the +/- screw terminal block on the motor driver hat. As you can see, it's easiest to use leads with grabber probes to grab onto the +/- jumpers.","title":"Do the motor driver boards have power?"},{"location":"HOWTO/#labjack","text":"","title":"LabJack"},{"location":"HOWTO/#do-the-hawkeyes-have-power-via-the-labjack","text":"The LabJack T7 with PS12DC power switching board also needs its own power supply. A tunable lab power supply is attached to one of the screw terminals labeled \"VS#,\" for \"voltage source #,\" where # is one of the channels, 1-6. The Hawkeye IR-50 source temperature depends on the voltage applied, and the current draw depends on the voltage (see datasheet in pdf dir). The design target temperature is 750 C, requiring a voltage of 6.7V and a current of ~134mA per source, for a total current draw of ~1.74A when all sources are turned on. In practice, Hawkeye sources have not drawn quite this much current. Connect the power supply and Hawkeye source wires to the LabJack as shown:","title":"Do the Hawkeyes have power via the LabJack?"},{"location":"HOWTO/#optional-mce-clk-sync","text":"It may be desirable to supply the same chopped signal the Hawkeyes see, but at 5V, to the MCE CLK card via a BNC cable. If this is desired, use the power supply CH3 set to 5V, and attach to +5V and GND to the terminal labeled S4.","title":"Optional: MCE CLK Sync"},{"location":"HOWTO/#motion-outputs","text":"","title":"Motion Outputs"},{"location":"HOWTO/#motors_1","text":"","title":"Motors"},{"location":"HOWTO/#can-the-motor-drivers-command-the-motors","text":"If they are not already connected, motors should be connected to the screw terminals of the pi's stepper hat like this: Getting the order right ensures the stepper's coils are energized in the correct sequence to get it to rotate. The stepper motors themselves have NEMA-17 spec hole patterns, which mate to the 3D printed motor mount brackets which we will attach to the beam mapper frame. Each stepper motor should be attached to its motor mount using M3 x 0.5 x 10 mm screws. Use lubricant, because metal on plastic will be squeaky. At this point, it is important to consider the mapping of motor driver terminal -> stepper motor -> motor mount -> corner of beam mapper frame. The Executive.__init__() function specifies this mapping, so the motor installation location and stepper instance in __init__() should match, to ensure the correct motor commands are sent to the correct stepper. Steppers and wire harnesses are labeled to assist with this. In general, the driver board closest to the Pi (0n bottom) will be kit0 (although this can be double-checked by looking at the address - 0x60 is the default I2C address for the hat, which can be changed by bridging the HAT pads A0-A4, so the board addressed by 0x60 will have no pads bridged). The terminal blocks M1-M2 are used for stepper1 on each HAT, and M3-M4 are used for stepper2 . It doesn't really matter which terminal maps to which corner, but it really does matter that the code and physical arrangement agree.","title":"Can the motor drivers command the motors?"},{"location":"HOWTO/#spools","text":"","title":"Spools"},{"location":"HOWTO/#can-the-motors-make-the-lines-longer-and-shorter","text":"If they are not already attached, the spools should be fixed to the 5 mm stepper motor shaft via one M3 setscrew. The fishing line is affixed to the each spool by wrapping it around the setscrew and screwing it in to the threaded recess on the spool circumference. Do not overtighten, as the threads are plastic. NOTE: Positive motor rotation is defined by convention to spin the shaft clockwise when viewed from the rear of the motor. Cables should be oriented relative to the spool such that a positive motor rotation produces a positive cable length change (i.e., cable is played out from the spool), and a negative motor rotation winds cable onto the spool. After attaching the cables to the spools, the other end should be threaded through the ~.9mm hole in the motor mount bracket. NOTE: All cables should be long enough to permit the raft to visit each corner of the frame, even when the frame is as far apart as it can be (~25.5\"). Finally, excess cable should be wound onto the spool, under tension, to avoid trapping excess cable underneath as the cable is wound on. This process should be done by hand.","title":"Can the motors make the lines longer and shorter?"},{"location":"HOWTO/#raft","text":"","title":"Raft"},{"location":"HOWTO/#will-moving-the-cables-move-the-hawkeyes","text":"The end effector of this robot is a rectangular raft carrying several Hawkeye Technologies IR-50 emitters. The robot drives the centroid of the effector to a specified position, and the control algorithm performs a specific sequence of flashes using a number of the emitters to enhance the detectability of the signal in the TIME receiver output data. If the raft is not already attached to the cables, the raft cap with the Hawkeye emitters must be removed to access the screws to fix the affix the lines. Simply pass them through the raft's eyelets, wrapping the ends of the fishing line around the screws in each corner of the raft, and screwing them down.","title":"Will moving the cables move the Hawkeyes?"},{"location":"HOWTO/#cable-maintenance","text":"","title":"Cable Maintenance"},{"location":"HOWTO/#what-if-a-cable-breaks","text":"The lid of the raft is secured by clips and a dab of cyanoacrylate glue in each corner. If the cables need to be changed (e.g., they are worn), an exacto blade can be used to break the CA glue in the corners and remove the lid. The original cable is Spiderwire EZ Braid braided dyneema fishing line (50 lb pull strength), chosen for its stretch resistance. A replacement can be found at any tackle store or Wal-Mart, but a spool of extra cable should already be stored with the beam mapper.","title":"What if a cable breaks?"},{"location":"HOWTO/#frame","text":"","title":"Frame"},{"location":"HOWTO/#is-the-frame-fully-assembled","text":"The 3D printed stepper motor mounts are attached to the beam mapper frame by 5/16-18 x 2\" or 2.25\" bolts with nyloc \"jam\" nuts. Two aluminum registration tabs are screwed into the end of each frame piece opposite the black plastic end caps, using a 5/16-18 x 1/4\" screw. They are long enough to reach an edge of the mirror regardless of if the mirror's corners have been machined off. NOTE: These tabs register the frame to a third edge of the mirror, so it is important that they not be bent . Long 5/16-18 steel threaded rods connect the two halves of the frame. On one end of the threaded rods, a nyloc \"jam\" nut on the outside of the perforated aluminum extrusion provides clamping force. On the other end of the threaded rod, a slide-adjust nut with a thumb button allows easily changing the distance between clamping surfaces, and applies clamping force to the outside of the opposite aluminum extrusion.","title":"Is the frame fully assembled?"},{"location":"HOWTO/#coordinate-system","text":"In order for the raft to be moved to a meaningful position in mirror-space, coordinates must be referenced to sensible locations where the mirror edges and robot frame register to one another. x-axis : plane of contact between the \"south\" frame and an edge of the mirror y-axis : plane of contact between the \"west\" side aluminum registration tab and a perpendicular mirror edge. The coordinate system of the robot therefore has its origin at the SW corner, where the aluminum alignment tab on the fixed frame meets the aluminum extrusion face.","title":"Coordinate System"},{"location":"HOWTO/#input-files","text":"There are two types of input files: geometry and profile . Read on to learn what they are for and what is inside each.","title":"Input Files"},{"location":"HOWTO/#ok-but-is-there-an-easy-way-to-make-a-new-one","text":".ipynb files are provided in the data/input/* directories to assist with making these input files. Most likely, you will only need data/input/create_profile.ipynb . The Raspberry Pi does not have Jupyter installed, so you would need a local checkout of hotspot or a copy of these notebooks to run on your own machine. Then simply copy the new files to the Raspberry Pi's /data/input/* directory with scp .","title":"Ok, but is there an easy way to make a new one?"},{"location":"HOWTO/#geometry","text":"Geometry files are one-line .csv files in data/input/geometry . create_geometry.ipynb is provided to script the creation of geometry files. Each one defines the physical setup of the robot when it is in a certain configuration, for instance, when it is installed on a mirror of a certain dimension. Each column entry describes an aspect of the physical setup of the system. A simplistic example: sw_0 sw_1 nw_0 nw_1 se_0 se_1 ne_0 ne_1 w h 0 0 0 1 1 0 1 1 .1 .1 Each corner point is the location of an eyelet through which the cable passes, expressed relative to the SW origin, described above. The width and height of the raft are defined by the separations between eyelets on the raft through which the cable passes. NOTE: Since the dimensions of the motor mounts have been measured relative to each edge, the y-positions of the corner eyelets can be calculated as a function of the separation between the aluminum extrusions that make up the support structure and clamping surfaces. The eyelets of the motor mounts measured 6.19 +/- 0.5 mm from the frame to the face of the motor mount bracket on the interior of the mapping region, and 7.96 +/- 0.02 mm from the face of the motor mount to the eyelet, for a total eyelet offset from the contact patch of 0.014 +/- 0.001 m. This value will be used to calculate eyelet y-positions as a function of frame separation. The eyelet positions should not ever change in the x-direction, unless the motor mounts are removed from the aluminum frames.","title":"Geometry"},{"location":"HOWTO/#profile","text":"Profile files are multi-line .csv files in data/input/profiles . Each one defines a new position to which the robot should move, in the coordinate system defined above. geometry/create_profile.ipynb is provided to script the creation of profiles. Upon reaching each location in the profile, the robot is programmed to flash Hawkeye sources on and off (default: 10 \"on\" states, 50% duty cycle, 5 Hz). Which group of sources is enabled is configurable with the flasher_cmds column in the profile .csv. Each 0 or 1, space-separated, in the first column, corresponds to one of twelve addressable solid state switchable voltage sources on the LabJack PS12DC Power Switching Board. The index-to-address mapping is defined in the dictionary at the top of hardware.py . Since there are 3 groups of Hawkeye sources, there are more addressable relays than strictly necessary. For example, to move to a single coordinate and flash all addresses: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 1 1 1 1 1 1 1 1 1 .5 .5 to move to a single coordinate and flash only the center Hawkeye: flasher_cmds pos_cmd_0s pos_cmd_1s 1 0 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash the center and inner ring Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 0 0 0 0 0 0 0 0 0 0 .5 .5 to move to a single coordinate and flash all Hawkeyes (center, inner ring, outer ring): flasher_cmds pos_cmd_0s pos_cmd_1s 1 1 1 0 0 0 0 0 0 0 0 0 .5 .5 Building up a sequence of moves allows a shape to be scanned.","title":"Profile"},{"location":"HOWTO/#output-files","text":"Output files store telemetry for each run in data/output . They are timestamped .hdf5 files.","title":"Output Files"},{"location":"HOWTO/#physical-installation-and-operation","text":"","title":"Physical Installation and Operation"},{"location":"HOWTO/#physical-installation","text":"","title":"Physical Installation"},{"location":"HOWTO/#general-tips","text":"Having two people helps. BE VERY CAREFUL about touching the buttons on the black slide-adjust nuts If you are adjusting the mapper spacing and you let them off of the threaded rod, they will disassemble themselves rapidly. You don't want to lose any parts. If you are loosening or tightening the mapper down to anything, when the mapper is under tension, touching the button could release tension rapidly, potentially causing a fall, which you do not want. Bring a power strip to make moving the PSU and Raspberry Pi to various mirrors easier. Bring a long ethernet cable to plug the Raspberry Pi into the rack's network switch. Don't bother trying to tape Eccosorb to anything. Just pinch it in between the mirror and threaded rod. This also helps keep the threaded rod from marring the mirror surface. Keep as much stuff as possible out of the path of the beam.","title":"General tips"},{"location":"HOWTO/#k1","text":"Underneath shutter, highest up. Put a step ladder inside the K-mirror frame to make the lift easier. Route Hawkeye cables around back of K1 and down. python main.py ./data/input/geometry/K1.csv ./data/input/profiles/K1_<profile>.csv","title":"K1"},{"location":"HOWTO/#k2","text":"Should be easy. Remove the anti-head-smasher foam first. python main.py ./data/input/geometry/K2.csv ./data/input/profiles/K2_<profile>.csv","title":"K2"},{"location":"HOWTO/#k3","text":"Pucker factor 11. Gravity is working against you, and you're right on top of F1, but snug things down good and tight when mounting the mapper and you will be fine. I used a crescent wrench on the black slide-adjust nuts for this one. Be careful not to release the slide-adjust nuts when using the wrench. python main.py ./data/input/geometry/K3.csv ./data/input/profiles/K3_<profile>.csv","title":"K3"},{"location":"HOWTO/#f1","text":"Another easy one. python main.py ./data/input/geometry/F1.csv ./data/input/profiles/F1_<profile>.csv","title":"F1"},{"location":"HOWTO/#p2","text":"Not currently reachable (clearance issues).","title":"P2"},{"location":"HOWTO/#operation","text":"When a surface geometry file has been created and the profile for the given shape to be mapped is generated, we are ready to run the program. There should already be geometry and profile files in the data/input directories.","title":"Operation"},{"location":"HOWTO/#a-note-on-homing","text":"Homing a system with no stall sensing in the motor driver solution and no limit switches is possible, but crude. To get around the fact that there is no feedback, the current homing solution is to release all but one axis, then issue enough retracting steps to the remaining motor to ensure the raft has reached the limit of its travel toward that axis (NW at the time of writing). This axis is then held while the other steppers issue enough retracting steps to ensure all cables are taut. The raft is then in a known position and orientation relative to the frame, so the mapper is homed. You will hear and see vibration while this happens. It is a simple, hands-free homing solution, but there is plenty of room for improvement here. Sensors would not be hard to add, would speed up homing, and would reduce the wear on cables (and probably motors) due to the current solution.","title":"A Note on Homing"},{"location":"HOWTO/#pre-mapping-checks","text":"Make sure that 12V is being supplied to both motor driver boards in the stack, that the polarity is correct. Make sure that 6.7V or less is being supplied to the LabJack switching board. Make sure the power supply output is on. Make sure that the cable is wound onto each spool and that no loops of excess cable are trapped underneath the cable wound onto the spools. Check the excess cable played out in the raft's current position. Some excess is fine as long as it doesn't interfere with the raft's motion. If the cable is taut before homing, this is also fine, but the homing routine may need to be run a few times before the raft reaches the home position. Ensure the Hawkeye source signal lines won't interfere with mapper operation. Ensure the hotspot conda env is active: conda activate hotspot .","title":"Pre-mapping checks"},{"location":"HOWTO/#mapping","text":"Start the program with python main.py ./data/input/geometry/<geometry.csv> ./data/input/profiles/<profile.csv> Perform a homing calibration: c , RETURN key. The NW motor will drive the raft to the NW corner while the NE, SW, SE axes go slack, and NW should begin skipping steps after reaching the limit. This (and some noise) is normal. The other axes then tension automatically. Verify that the raft reached its home against the NW corner, and that the other axes achieved tension. If not, GOTO 2. Perform a mapping sequence: s , RETURN key. The raft will drive to each location and flash the Hawkeyes at each point in the sequence. Observe the mapper, ensuring the Hawkeye signal cable does not interfere with the mapper. You may request a mode change at any time. Mode changes are processed at the end of each move. You may abort the program with Ctrl+C . Upon completing a sequence, it may be repeated by requesting the sequence mode again.","title":"Mapping"},{"location":"HOWTO/#other-documentation","text":"","title":"Other Documentation"},{"location":"HOWTO/#example-call-graph","text":"Generated without motors or LabJack attached, so this does not include overhead of those libraries, but the control flow is the same.","title":"Example Call Graph"},{"location":"HOWTO/#module-flow-charts","text":"","title":"Module Flow Charts"},{"location":"HOWTO/#executive","text":"","title":"Executive"},{"location":"HOWTO/#reference-html","text":"The html documentation of the source code and Markdown materials is generated by portray . To regenerate the documentation, execute: portray as_html -m hotspot -o docs/html/ --overwrite","title":"Reference HTML"},{"location":"HOWTO/#pycallgraph","text":"To re-generate the call graph image, directory, run pycallgraph -i \"alg*\" -i \"const*\" -i \"exec*\" -i \"hardw*\" -i \"hot*\" -i \"hw*\" -i \"tele*\" graphviz --output-file = ../doc/img/pycallgraph.png -- main.py ../data/input/geometry/frame.csv ../data/input/profiles/box_frame.csv You must have graphviz installed using your operating system's package manager. For most accurate graph and timing information, do this with all peripheral hardware attached, so the call graphs include interfacing with the motor drivers and LabJack.","title":"pycallgraph"},{"location":"reference/hotspot/","text":"Module hotspot None None Sub-modules hotspot.algorithm hotspot.constants hotspot.executive hotspot.hardware hotspot.hw_context hotspot.telemetry","title":"Index"},{"location":"reference/hotspot/#module-hotspot","text":"None None","title":"Module hotspot"},{"location":"reference/hotspot/#sub-modules","text":"hotspot.algorithm hotspot.constants hotspot.executive hotspot.hardware hotspot.hw_context hotspot.telemetry","title":"Sub-modules"},{"location":"reference/hotspot/algorithm/","text":"Module hotspot.algorithm None None View Source # This file houses the algorithms necessary for calculating the control # quantities. # MKS units only. import logging import multiprocessing as mp import numpy as np import time import hotspot.constants as const logger = logging . getLogger ( __name__ ) # logger.setLevel(getattr(logging, const.LOGLEVEL)) class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )): logger . debug ( 'TestSurface init' ) corner_list = [ nw , ne , se , sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { inp } .' assert len ({ elem for elem in corner_list }) == len ( corner_list ), f 'Vertices should be unique: { corner_list } ' # Corner points are expressed as x,y offsets in mirror coordinate frame self . corners = np . array ([[ sw , nw ], [ se , ne ]]) self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] def is_inbounds ( self , pos : tuple ): ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [ self . sw , self . nw , self . ne , self . se , self . sw ] reason = None for i in range ( len ( vertex_seq ) - 1 ): disp0 = vertex_seq [ i ] - pos disp1 = vertex_seq [ i + 1 ] - pos mag0 = np . linalg . norm ( disp0 ) mag1 = np . linalg . norm ( disp1 ) # is pos too close to a vertex (protect against divide by 0) if ( mag0 < eps or mag1 < eps ): result = False reason = 'Too close to corner' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np . arccos ( np . dot ( v0_hat , v1_hat )) # is pos too close to an edge if np . abs ( ang - np . pi ) < eps : result = False reason = 'Too close to edge' break ang_tot_rad += ang # is pos inside shape if np . abs ( ang_tot_rad - 2. * np . pi ) > eps : result = False reason = f 'Outside shape: { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason : logger . debug ( f 'Bounds check failed: { reason } ' ) return result class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { position } .' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location { home_pos } is outside of bounds for surface { self . surf } ' ) @property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command { new_pos } is outside of bounds for surface { self . surf } ' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: { distance } ' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: { pos_cmd } ' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move: { lengths_after } ' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: { motor_cmds } \\n Delta lengths: { delta_lengths } ' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds Variables logger Classes Raft class Raft ( position : tuple , width : float , height : float ) View Source class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {position}.' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @ property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @ position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos Instance variables position Accessor for raft origin position in mirror coordinate frame Robot class Robot ( surf : hotspot . algorithm . TestSurface , raft : hotspot . algorithm . Raft , tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f65d47839b0 >> ) View Source class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @ property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @ home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location {home_pos} is outside of bounds for surface {self.surf}' ) @ property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @ pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command {new_pos} is outside of bounds for surface {self.surf}' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds Instance variables home The location in mirror coordinate frame the robot will guide to when commanded home pos_cmd The location in mirror coordinate frame the robot will guide to for the next move Methods process_input def process_input ( self , pos_cmd : tuple ) Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters: Name Type Description Default pos_cmd None the position command in the frame of the surface None Returns: Type Description dict of tuples dict containing motor commands in radians. View Source def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds TestSurface class TestSurface ( sw = ( 0.0 , 0.0 ), se = ( 1.0 , 0.0 ), nw = ( 0.0 , 1.0 ), ne = ( 1.0 , 1.0 ) ) View Source class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )) : logger . debug ( 'TestSurface init' ) corner_list = [ nw, ne, se, sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {inp}.' assert len ( { elem for elem in corner_list } ) == len ( corner_list ), f 'Vertices should be unique: {corner_list}' # Corner points are expressed as x , y offsets in mirror coordinate frame self . corners = np . array ( [ [sw, nw ] , [ se, ne ] ] ) self . sw = self . corners [ 0,0 ] self . se = self . corners [ 1,0 ] self . nw = self . corners [ 0,1 ] self . ne = self . corners [ 1,1 ] def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result Methods is_inbounds def is_inbounds ( self , pos : tuple ) Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. View Source def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result","title":"Algorithm"},{"location":"reference/hotspot/algorithm/#module-hotspotalgorithm","text":"None None View Source # This file houses the algorithms necessary for calculating the control # quantities. # MKS units only. import logging import multiprocessing as mp import numpy as np import time import hotspot.constants as const logger = logging . getLogger ( __name__ ) # logger.setLevel(getattr(logging, const.LOGLEVEL)) class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )): logger . debug ( 'TestSurface init' ) corner_list = [ nw , ne , se , sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { inp } .' assert len ({ elem for elem in corner_list }) == len ( corner_list ), f 'Vertices should be unique: { corner_list } ' # Corner points are expressed as x,y offsets in mirror coordinate frame self . corners = np . array ([[ sw , nw ], [ se , ne ]]) self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] def is_inbounds ( self , pos : tuple ): ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [ self . sw , self . nw , self . ne , self . se , self . sw ] reason = None for i in range ( len ( vertex_seq ) - 1 ): disp0 = vertex_seq [ i ] - pos disp1 = vertex_seq [ i + 1 ] - pos mag0 = np . linalg . norm ( disp0 ) mag1 = np . linalg . norm ( disp1 ) # is pos too close to a vertex (protect against divide by 0) if ( mag0 < eps or mag1 < eps ): result = False reason = 'Too close to corner' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np . arccos ( np . dot ( v0_hat , v1_hat )) # is pos too close to an edge if np . abs ( ang - np . pi ) < eps : result = False reason = 'Too close to edge' break ang_tot_rad += ang # is pos inside shape if np . abs ( ang_tot_rad - 2. * np . pi ) > eps : result = False reason = f 'Outside shape: { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason : logger . debug ( f 'Bounds check failed: { reason } ' ) return result class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { position } .' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location { home_pos } is outside of bounds for surface { self . surf } ' ) @property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command { new_pos } is outside of bounds for surface { self . surf } ' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: { distance } ' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: { pos_cmd } ' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move: { lengths_after } ' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: { motor_cmds } \\n Delta lengths: { delta_lengths } ' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"Module hotspot.algorithm"},{"location":"reference/hotspot/algorithm/#variables","text":"logger","title":"Variables"},{"location":"reference/hotspot/algorithm/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/algorithm/#raft","text":"class Raft ( position : tuple , width : float , height : float ) View Source class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {position}.' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] @ property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @ position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos","title":"Raft"},{"location":"reference/hotspot/algorithm/#instance-variables","text":"position Accessor for raft origin position in mirror coordinate frame","title":"Instance variables"},{"location":"reference/hotspot/algorithm/#robot","text":"class Robot ( surf : hotspot . algorithm . TestSurface , raft : hotspot . algorithm . Raft , tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f65d47839b0 >> ) View Source class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue @ property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @ home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location {home_pos} is outside of bounds for surface {self.surf}' ) @ property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @ pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command {new_pos} is outside of bounds for surface {self.surf}' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"Robot"},{"location":"reference/hotspot/algorithm/#instance-variables_1","text":"home The location in mirror coordinate frame the robot will guide to when commanded home pos_cmd The location in mirror coordinate frame the robot will guide to for the next move","title":"Instance variables"},{"location":"reference/hotspot/algorithm/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/algorithm/#process_input","text":"def process_input ( self , pos_cmd : tuple ) Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters: Name Type Description Default pos_cmd None the position command in the frame of the surface None Returns: Type Description dict of tuples dict containing motor commands in radians. View Source def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # Input checking, this is just in case of malformed inputs. eps = np . finfo ( float ) . eps distance = np . linalg . norm ( np . array ( pos_cmd ) - self . raft . position ) if distance <= eps : logger . warning ( f 'Position command malformed: distance: {distance}' ) return motor_cmds lengths_before = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) delta_lengths = lengths_after - lengths_before delta_angles = delta_lengths / const . PULLEY_RADIUS motor_cmds [ 'sw' ] = delta_angles [ 0 , 0 ] motor_cmds [ 'se' ] = delta_angles [ 1 , 0 ] motor_cmds [ 'nw' ] = delta_angles [ 0 , 1 ] motor_cmds [ 'ne' ] = delta_angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds} \\n Delta lengths:{delta_lengths}' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Delta Angle Command (rad)' : delta_angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"process_input"},{"location":"reference/hotspot/algorithm/#testsurface","text":"class TestSurface ( sw = ( 0.0 , 0.0 ), se = ( 1.0 , 0.0 ), nw = ( 0.0 , 1.0 ), ne = ( 1.0 , 1.0 ) ) View Source class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )) : logger . debug ( 'TestSurface init' ) corner_list = [ nw, ne, se, sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {inp}.' assert len ( { elem for elem in corner_list } ) == len ( corner_list ), f 'Vertices should be unique: {corner_list}' # Corner points are expressed as x , y offsets in mirror coordinate frame self . corners = np . array ( [ [sw, nw ] , [ se, ne ] ] ) self . sw = self . corners [ 0,0 ] self . se = self . corners [ 1,0 ] self . nw = self . corners [ 0,1 ] self . ne = self . corners [ 1,1 ] def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result","title":"TestSurface"},{"location":"reference/hotspot/algorithm/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/algorithm/#is_inbounds","text":"def is_inbounds ( self , pos : tuple ) Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. View Source def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.debug(f' Bounds check failed : { reason }' ) return result","title":"is_inbounds"},{"location":"reference/hotspot/constants/","text":"Module hotspot.constants None None View Source # Numbers that don't change from mirror to mirror # MKS units throughout if not specified. import numpy as np import os from hotspot.hw_context import stepper # Adafruit stacking motor driver hats are addressable. HAT_0_ADDR = 0x60 HAT_1_ADDR = 0x61 PWM_FREQ = 1600 # Adafruit stepper style. Used to enable/disable microstepping. # ECM: Mess with this at your peril. Microstepping has less torque, # and is more prone to skipping steps in the high-tension situations # these motors are subject to. STEPPER_STYLE = stepper . INTERLEAVE # Adafruit microstepping modifier. Divides each single step by the modifier: # E.g. a value of 8 splits one 1.8 deg step into eight .225 deg steps. # Even numbers from 2-8. MICROSTEP_NUM = 2 # Used for converting rotational changes into stepper commands DEG_PER_STEP = 360. / 200. / MICROSTEP_NUM DEG_PER_RAD = 180. / np . pi # Used for converting linear distances into rotational ones PULLEY_RADIUS = 0.0302 / 2. # Limits the total number of commands that may be in the command queue at once. # Pretty much only limited by memory. MAX_QLEN = 2 ** 16 # delta x distance from the NW eyelet to the raft centroid, when it is driven # to the NW limit and the raft isn't cockeyed HOMING_OFFSET_X = 0.0276 # same, but for y HOMING_OFFSET_Y = - 0.0252 # Not sure how issuing step commands to multiple motors too fast will mess # with the motor hat timing, so wait a bit just to be safe STEP_WAIT = 1e-7 # Helps with I/O TOPLEVEL_DIR = os . path . abspath ( os . path . join ( __file__ , '..' , '..' )) Variables DEG_PER_RAD DEG_PER_STEP HAT_0_ADDR HAT_1_ADDR HOMING_OFFSET_X HOMING_OFFSET_Y MAX_QLEN MICROSTEP_NUM PULLEY_RADIUS PWM_FREQ STEPPER_STYLE STEP_WAIT TOPLEVEL_DIR","title":"Constants"},{"location":"reference/hotspot/constants/#module-hotspotconstants","text":"None None View Source # Numbers that don't change from mirror to mirror # MKS units throughout if not specified. import numpy as np import os from hotspot.hw_context import stepper # Adafruit stacking motor driver hats are addressable. HAT_0_ADDR = 0x60 HAT_1_ADDR = 0x61 PWM_FREQ = 1600 # Adafruit stepper style. Used to enable/disable microstepping. # ECM: Mess with this at your peril. Microstepping has less torque, # and is more prone to skipping steps in the high-tension situations # these motors are subject to. STEPPER_STYLE = stepper . INTERLEAVE # Adafruit microstepping modifier. Divides each single step by the modifier: # E.g. a value of 8 splits one 1.8 deg step into eight .225 deg steps. # Even numbers from 2-8. MICROSTEP_NUM = 2 # Used for converting rotational changes into stepper commands DEG_PER_STEP = 360. / 200. / MICROSTEP_NUM DEG_PER_RAD = 180. / np . pi # Used for converting linear distances into rotational ones PULLEY_RADIUS = 0.0302 / 2. # Limits the total number of commands that may be in the command queue at once. # Pretty much only limited by memory. MAX_QLEN = 2 ** 16 # delta x distance from the NW eyelet to the raft centroid, when it is driven # to the NW limit and the raft isn't cockeyed HOMING_OFFSET_X = 0.0276 # same, but for y HOMING_OFFSET_Y = - 0.0252 # Not sure how issuing step commands to multiple motors too fast will mess # with the motor hat timing, so wait a bit just to be safe STEP_WAIT = 1e-7 # Helps with I/O TOPLEVEL_DIR = os . path . abspath ( os . path . join ( __file__ , '..' , '..' ))","title":"Module hotspot.constants"},{"location":"reference/hotspot/constants/#variables","text":"DEG_PER_RAD DEG_PER_STEP HAT_0_ADDR HAT_1_ADDR HOMING_OFFSET_X HOMING_OFFSET_Y MAX_QLEN MICROSTEP_NUM PULLEY_RADIUS PWM_FREQ STEPPER_STYLE STEP_WAIT TOPLEVEL_DIR","title":"Variables"},{"location":"reference/hotspot/executive/","text":"Module hotspot.executive None None View Source # This file houses the code to process inputs, send commands to motors and IR # sources, and log/display telemetry import logging import multiprocessing as mp import numpy as np import os import sys import threading import time from hotspot.hw_context import MotorKit from hotspot.hw_context import stepper import hotspot.algorithm as alg import hotspot.constants as const import hotspot.hardware as hw import hotspot.telemetry as tm logger = logging . getLogger ( __name__ ) MODES = { 'c' : 'CAL_HOME' , 'h' : 'HOME' , 's' : 'SEQ' , 'w' : 'WAIT' } HR = '-' * 80 MENU_STR = HR + f ' \\n Listening for user input for mode changes. Type a mode char and press enter: \\n { MODES } \\n ' + HR class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : if const . STEPPER_STYLE == stepper . INTERLEAVE : assert const . MICROSTEP_NUM == 2 , 'const.MICROSTEP_NUM multiplier must be 2 for interleaved stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } # Keep track of total steps taken post-homing. Closed loop paths # should maintain ~0 net steps. self . stepper_net_steps = np . array ([ 0 ] * 4 ) # Keep track of rounding errors in steps to correct them as they # accumulate self . net_step_error = np . array ([ 0. ] * 4 ) self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: { fname } ' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number { len ( rows ) } exceeds command' + ' queue length {const.MAX_QLEN} . Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'i' == kbd_in : logger . info ( 'Home position override requested.' ) self . mode = 'INPUT_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'INPUT_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: { self . robot . home } ' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps // 1 ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position { self . robot . raft . position } ' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: { self . robot . home } ' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: { self . robot . raft . position } ' ) logger . info ( f 'Command completed. Sequence progress: { progress : .2f } %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = [ 'sw' , 'nw' , 'ne' , 'se' ] angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] order , steps_taken , err = hw . all_steppers ([ self . steppers [ key ] for key in keys ], angs ) # Perform corrections for rounding errors self . stepper_net_steps += steps_taken self . net_step_error += err logger . debug ( f 'Net steps: { self . stepper_net_steps } ' ) logger . debug ( f 'Net step error incurred by rounding: { self . net_step_error } ' ) for i , step_err in enumerate ( self . net_step_error ): # If off by more than a step, fix it. if np . abs ( step_err ) >= 0.5 : steps_to_go = np . round ( step_err ) . astype ( int ) logger . debug ( f 'Correcting { steps_to_go } steps on { keys [ i ] } ' ) # correct in the opposite direction of error self . stepper_net_steps [ i ] += - steps_to_go self . net_step_error [ i ] += - steps_to_go stepper_dir = stepper . BACKWARD direction = np . sign ( steps_to_go ) if direction == - 1 : stepper_dir = stepper . FORWARD for _ in range ( abs ( steps_to_go )): self . steppers [ keys [ i ]] . onestep ( style = const . STEPPER_STYLE , direction = stepper_dir ) time . sleep ( const . STEP_WAIT ) logger . debug ( f 'Move cmd: { cmd } ' ) pos_after = cmd [ 'pos_cmd' ] send_pos_cmd ( pos_after ) return def do_labjack_tasks ( self , cmd : dict ): packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] return Variables HR MENU_STR MODES logger Classes Executive class Executive ( geometry_file : str , plot_enable = False ) Attributes Name Type Description Default geometry_file None Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. None View Source class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : if const . STEPPER_STYLE == stepper . INTERLEAVE : assert const . MICROSTEP_NUM == 2 , 'const.MICROSTEP_NUM multiplier must be 2 for interleaved stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } # Keep track of total steps taken post-homing. Closed loop paths # should maintain ~0 net steps. self . stepper_net_steps = np . array ([ 0 ] * 4 ) # Keep track of rounding errors in steps to correct them as they # accumulate self . net_step_error = np . array ([ 0. ] * 4 ) self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'i' == kbd_in : logger . info ( 'Home position override requested.' ) self . mode = 'INPUT_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'INPUT_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: {self.robot.home}' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps // 1 ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: {self.robot.raft.position}' ) logger . info ( f 'Command completed. Sequence progress: {progress:.2f} %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = [ 'sw' , 'nw' , 'ne' , 'se' ] angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] order , steps_taken , err = hw . all_steppers ([ self . steppers [ key ] for key in keys ], angs ) # Perform corrections for rounding errors self . stepper_net_steps += steps_taken self . net_step_error += err logger . debug ( f 'Net steps: {self.stepper_net_steps}' ) logger . debug ( f 'Net step error incurred by rounding: {self.net_step_error}' ) for i , step_err in enumerate ( self . net_step_error ): # If off by more than a step, fix it. if np . abs ( step_err ) >= 0.5 : steps_to_go = np . round ( step_err ) . astype ( int ) logger . debug ( f 'Correcting {steps_to_go} steps on {keys[i]}' ) # correct in the opposite direction of error self . stepper_net_steps [ i ] += - steps_to_go self . net_step_error [ i ] += - steps_to_go stepper_dir = stepper . BACKWARD direction = np . sign ( steps_to_go ) if direction == - 1 : stepper_dir = stepper . FORWARD for _ in range ( abs ( steps_to_go )): self . steppers [ keys [ i ]] . onestep ( style = const . STEPPER_STYLE , direction = stepper_dir ) time . sleep ( const . STEP_WAIT ) logger . debug ( f 'Move cmd: {cmd}' ) pos_after = cmd [ 'pos_cmd' ] send_pos_cmd ( pos_after ) return def do_labjack_tasks ( self , cmd : dict ): packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] return Methods add_cmds def add_cmds ( self , fname : str ) Read command input file and add commands to the command queue. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def add_cmds ( self , fname : str ) : ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ) : logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ) : cmd = {} cmd [ 'flasher_cmds' ] = [ int(item) for item in rows[i ][ 0 ] . split () ] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ] , rows [ i ][ 2 ] ) self . cmd_queue . put ( cmd ) return cal_home def cal_home ( self ) Ask the user to input the current position of the center of the raft to store it as the home position. View Source def cal_home ( self ) : ''' Ask the user to input the current position of the center of the raft to store it as the home position . ''' print ( ' Where is home? Input the current position, in meters, of ' + ' the raft centroid relative to the mirror origin, then press ' + ' ENTER to store it as home. ' ) x = float ( input ( ' x-coord: ' )) y = float ( input ( ' y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f ' Home position set: {self.robot.home} ' ) return cal_home_auto def cal_home_auto ( self ) Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. View Source def cal_home_auto ( self ) : ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting , to NE , SE , SW don 't # inhibit motion [self.steppers[key].release() for key in self.steppers.keys()] # Worst case, about how far would we have to move before hitting NW? max_distance = np.linalg.norm(self.robot.surf.nw - self.robot.surf.se) max_radians = max_distance / const.PULLEY_RADIUS # valid for single or double steps max_steps = np.round(np.abs(max_radians) * const.DEG_PER_RAD / (360. / 200. / 1)).astype(int) num_steps = max(1, max_steps // 1) logger.info(' Homing to NW ') report_interval = 100 i = num_steps while i > 0: self.steppers[' nw '].onestep(style=stepper.DOUBLE, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') logger.info(' Retracting cables to tension NE , SE , SW ') i = num_steps while i > 0: self.steppers[' ne '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' se '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' sw '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') pos = self.robot.surf.nw + np.array((const.HOMING_OFFSET_X, const.HOMING_OFFSET_Y)) self.robot.raft.position = pos self.robot.home = pos logger.info(f' Raft is homed with centroid position { self . robot . raft . position } ') logger.warning(' Verify that the raft has been driven to one of its limits and all cables are taut . If not , request CAL_HOME again . ') packet = {' algorithm ': { ' Time UTC ( s ) ': time.time(), ' Position Command ( m ) ' : pos, ' Motor Delta Angle Command ( rad ) ' : np . array ( [ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return close def close ( self ) View Source def close ( self ) : [ self.steppers[key ] . release () for key in self . steppers . keys () ] return do_labjack_tasks def do_labjack_tasks ( self , cmd : dict ) View Source def do_labjack_tasks ( self , cmd : dict ) : packet = { ' LabJack Cmd ' : { ' Time UTC (s) ' : time . time () , ' Addresses Turned On ' : 1 + np . where ( np . array ( cmd [ ' flasher_cmds ' ] ) > 0 ) [ 0 ], } } self . tm_queue . put ( packet ) freq = 5 . # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ ' flasher_cmds ' ] ) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1 . / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) return do_motor_tasks def do_motor_tasks ( self , cmd : dict ) -> list Transform the move command into motor commands Parameters: Name Type Description Default cmd Command packet dictionary with keys for position commands to pass to control algorithm None View Source def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ) : ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = [ 'sw', 'nw', 'ne', 'se' ] angs = [ cmd for cmd in [motor_cmds[key ] for key in keys ]] order , steps_taken , err = hw . all_steppers ( [ self.steppers[key ] for key in keys ] , angs ) # Perform corrections for rounding errors self . stepper_net_steps += steps_taken self . net_step_error += err logger . debug ( f 'Net steps: {self.stepper_net_steps}' ) logger . debug ( f 'Net step error incurred by rounding: {self.net_step_error}' ) for i , step_err in enumerate ( self . net_step_error ) : # If off by more than a step , fix it . if np . abs ( step_err ) >= 0.5 : steps_to_go = np . round ( step_err ). astype ( int ) logger . debug ( f 'Correcting {steps_to_go} steps on {keys[i]}' ) # correct in the opposite direction of error self . stepper_net_steps [ i ] += - steps_to_go self . net_step_error [ i ] += - steps_to_go stepper_dir = stepper . BACKWARD direction = np . sign ( steps_to_go ) if direction == - 1 : stepper_dir = stepper . FORWARD for _ in range ( abs ( steps_to_go )) : self . steppers [ keys[i ] ] . onestep ( style = const . STEPPER_STYLE , direction = stepper_dir ) time . sleep ( const . STEP_WAIT ) logger . debug ( f 'Move cmd: {cmd}' ) pos_after = cmd [ 'pos_cmd' ] send_pos_cmd ( pos_after ) return empty_queue def empty_queue ( self , queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f65d47839b0 >> ) Completely empty the given Queue object. Parameters: Name Type Description Default queue None Any queue None View Source def empty_queue ( self , queue : mp . Queue ) : ''' Completely empty the given Queue object . Parameters ---------- queue Any queue ''' while not queue . empty () : queue . get () return go_home def go_home ( self ) Clear all commands in the queue and drive to the home position. View Source def go_home ( self ) : ''' Clear all commands in the queue and drive to the home position. ''' # If not already home , go there . eps = np . finfo ( float ). eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )) : logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return run def run ( self , fname : str ) Main run function, including processing human input to switch between states. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def run ( self , fname : str ) : ''' Main run function , including processing human input to switch between states . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col . Data spec described in docstring of sequence () function . ''' # Allow user input to change the mode . input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue , ) , daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input . self . mode = ' WAIT ' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty () : kbd_in = self . kbd_queue . get_nowait () if ' c ' == kbd_in : logger . info ( ' Home calibration requested. ' ) self . mode = ' CAL_HOME ' elif ' i ' == kbd_in : logger . info ( ' Home position override requested. ' ) self . mode = ' INPUT_HOME ' elif ' h ' == kbd_in : logger . info ( ' Moving to home requested. ' ) self . mode = ' HOME ' elif ' s ' == kbd_in : logger . info ( ' Sequence run requested. ' ) self . mode = ' SEQ ' elif ' w ' == kbd_in : logger . info ( ' Wait mode requested. ' ) self . mode = ' WAIT ' else : continue if self . mode == ' CAL_HOME ' : self . cal_home_auto () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' INPUT_HOME ' : self . cal_home () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' HOME ' : self . go_home () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' SEQ ' : self . sequence ( fname ) elif self . mode == ' WAIT ' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down. ' ) running = False self . close () return sequence def sequence ( self , fname : str ) On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate None View Source def sequence ( self , fname : str ) : ''' On each call , pop a new command off of the command queue and dispatch it to motors / LabJack . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col : - flasher_cmds : 1 or 0 depending on whether that address is enabled - pos_cmd_0s : 0 th element of position command coordinate - pos_cmd_1s : 1 st element of position command coordinate ''' # If we are changing to sequence from another mode , ensure we start # fresh if self . mode != self . last_mode : logger . info ( ' Beginning command sequence. ' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = ' WAIT ' return else : cmd = self . cmd_queue . get () progress = 100 . * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks , then LJ tasks in serial , so IR source tasks happen at the end of each move . self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f ' Raft centroid: {self.robot.raft.position} ' ) logger . info ( f ' Command completed. Sequence progress: {progress:.2f} % ' ) self . router . process_tm ( plot_enable = self . plot_enable ) return wait def wait ( self ) View Source def wait ( self ) : if self . plot_enable : self . router . run_gui_event_loop () return","title":"Executive"},{"location":"reference/hotspot/executive/#module-hotspotexecutive","text":"None None View Source # This file houses the code to process inputs, send commands to motors and IR # sources, and log/display telemetry import logging import multiprocessing as mp import numpy as np import os import sys import threading import time from hotspot.hw_context import MotorKit from hotspot.hw_context import stepper import hotspot.algorithm as alg import hotspot.constants as const import hotspot.hardware as hw import hotspot.telemetry as tm logger = logging . getLogger ( __name__ ) MODES = { 'c' : 'CAL_HOME' , 'h' : 'HOME' , 's' : 'SEQ' , 'w' : 'WAIT' } HR = '-' * 80 MENU_STR = HR + f ' \\n Listening for user input for mode changes. Type a mode char and press enter: \\n { MODES } \\n ' + HR class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : if const . STEPPER_STYLE == stepper . INTERLEAVE : assert const . MICROSTEP_NUM == 2 , 'const.MICROSTEP_NUM multiplier must be 2 for interleaved stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } # Keep track of total steps taken post-homing. Closed loop paths # should maintain ~0 net steps. self . stepper_net_steps = np . array ([ 0 ] * 4 ) # Keep track of rounding errors in steps to correct them as they # accumulate self . net_step_error = np . array ([ 0. ] * 4 ) self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: { fname } ' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number { len ( rows ) } exceeds command' + ' queue length {const.MAX_QLEN} . Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'i' == kbd_in : logger . info ( 'Home position override requested.' ) self . mode = 'INPUT_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'INPUT_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: { self . robot . home } ' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps // 1 ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: { progress : .2f } %' ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position { self . robot . raft . position } ' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: { self . robot . home } ' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: { self . robot . raft . position } ' ) logger . info ( f 'Command completed. Sequence progress: { progress : .2f } %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = [ 'sw' , 'nw' , 'ne' , 'se' ] angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] order , steps_taken , err = hw . all_steppers ([ self . steppers [ key ] for key in keys ], angs ) # Perform corrections for rounding errors self . stepper_net_steps += steps_taken self . net_step_error += err logger . debug ( f 'Net steps: { self . stepper_net_steps } ' ) logger . debug ( f 'Net step error incurred by rounding: { self . net_step_error } ' ) for i , step_err in enumerate ( self . net_step_error ): # If off by more than a step, fix it. if np . abs ( step_err ) >= 0.5 : steps_to_go = np . round ( step_err ) . astype ( int ) logger . debug ( f 'Correcting { steps_to_go } steps on { keys [ i ] } ' ) # correct in the opposite direction of error self . stepper_net_steps [ i ] += - steps_to_go self . net_step_error [ i ] += - steps_to_go stepper_dir = stepper . BACKWARD direction = np . sign ( steps_to_go ) if direction == - 1 : stepper_dir = stepper . FORWARD for _ in range ( abs ( steps_to_go )): self . steppers [ keys [ i ]] . onestep ( style = const . STEPPER_STYLE , direction = stepper_dir ) time . sleep ( const . STEP_WAIT ) logger . debug ( f 'Move cmd: { cmd } ' ) pos_after = cmd [ 'pos_cmd' ] send_pos_cmd ( pos_after ) return def do_labjack_tasks ( self , cmd : dict ): packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] return","title":"Module hotspot.executive"},{"location":"reference/hotspot/executive/#variables","text":"HR MENU_STR MODES logger","title":"Variables"},{"location":"reference/hotspot/executive/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/executive/#executive","text":"class Executive ( geometry_file : str , plot_enable = False )","title":"Executive"},{"location":"reference/hotspot/executive/#attributes","text":"Name Type Description Default geometry_file None Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. None View Source class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) if const . STEPPER_STYLE in [ stepper . SINGLE , stepper . DOUBLE ]: assert const . MICROSTEP_NUM == 1 , 'const.MICROSTEP_NUM multiplier must be 1 for single- or double-stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , pwm_frequency = const . PWM_FREQ ) else : if const . STEPPER_STYLE == stepper . INTERLEAVE : assert const . MICROSTEP_NUM == 2 , 'const.MICROSTEP_NUM multiplier must be 2 for interleaved stepping mode.' kit0 = MotorKit ( address = const . HAT_0_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) kit1 = MotorKit ( address = const . HAT_1_ADDR , steppers_microsteps = const . MICROSTEP_NUM , pwm_frequency = const . PWM_FREQ ) # This mapping should match the physical setup. kit0 is closest to the # parent board, kit1 is on top. stepper1 is terminals M1+M2, stepper2 # is terminals M3+M4 self . steppers = { 'sw' : kit1 . stepper2 , 'ne' : kit0 . stepper1 , 'nw' : kit0 . stepper2 , 'se' : kit1 . stepper1 } # Keep track of total steps taken post-homing. Closed loop paths # should maintain ~0 net steps. self . stepper_net_steps = np . array ([ 0 ] * 4 ) # Keep track of rounding errors in steps to correct them as they # accumulate self . net_step_error = np . array ([ 0. ] * 4 ) self . lj_instance = hw . try_open ( hw . MODEL_NAME , hw . MODE ) hw . spawn_all_threads_off ( self . lj_instance ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( sys . stdin . read ( 1 )) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = [ int ( item ) for item in rows [ i ][ 0 ] . split ()] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'i' == kbd_in : logger . info ( 'Home position override requested.' ) self . mode = 'INPUT_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 's' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'SEQ' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' else : continue if self . mode == 'CAL_HOME' : self . cal_home_auto () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'INPUT_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'SEQ' : self . sequence ( fname ) elif self . mode == 'WAIT' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def cal_home ( self ): ''' Ask the user to input the current position of the center of the raft to store it as the home position. ''' print ( 'Where is home? Input the current position, in meters, of' + ' the raft centroid relative to the mirror origin, then press' + ' ENTER to store it as home.' ) x = float ( input ( 'x-coord: ' )) y = float ( input ( 'y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f 'Home position set: {self.robot.home}' ) return def cal_home_auto ( self ): ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting, to NE, SE, SW don't # inhibit motion [ self . steppers [ key ] . release () for key in self . steppers . keys ()] # Worst case, about how far would we have to move before hitting NW? max_distance = np . linalg . norm ( self . robot . surf . nw - self . robot . surf . se ) max_radians = max_distance / const . PULLEY_RADIUS # valid for single or double steps max_steps = np . round ( np . abs ( max_radians ) * const . DEG_PER_RAD / ( 360. / 200. / 1 )) . astype ( int ) num_steps = max ( 1 , max_steps // 1 ) logger . info ( 'Homing to NW' ) report_interval = 100 i = num_steps while i > 0 : self . steppers [ 'nw' ] . onestep ( style = stepper . DOUBLE , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) logger . info ( 'Retracting cables to tension NE, SE, SW' ) i = num_steps while i > 0 : self . steppers [ 'ne' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'se' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) self . steppers [ 'sw' ] . onestep ( style = stepper . MICROSTEP , direction = stepper . BACKWARD ) time . sleep ( const . STEP_WAIT ) i -= 1 if not i % report_interval : progress = 100. * ( num_steps - i ) / num_steps logger . info ( f 'Progress: {progress:.2f} %' ) pos = self . robot . surf . nw + np . array (( const . HOMING_OFFSET_X , const . HOMING_OFFSET_Y )) self . robot . raft . position = pos self . robot . home = pos logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to one of its limits and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Time UTC (s)' : time . time (), 'Position Command (m)' : pos , 'Motor Delta Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks in serial, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f 'Raft centroid: {self.robot.raft.position}' ) logger . info ( f 'Command completed. Sequence progress: {progress:.2f} %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = [ 'sw' , 'nw' , 'ne' , 'se' ] angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] order , steps_taken , err = hw . all_steppers ([ self . steppers [ key ] for key in keys ], angs ) # Perform corrections for rounding errors self . stepper_net_steps += steps_taken self . net_step_error += err logger . debug ( f 'Net steps: {self.stepper_net_steps}' ) logger . debug ( f 'Net step error incurred by rounding: {self.net_step_error}' ) for i , step_err in enumerate ( self . net_step_error ): # If off by more than a step, fix it. if np . abs ( step_err ) >= 0.5 : steps_to_go = np . round ( step_err ) . astype ( int ) logger . debug ( f 'Correcting {steps_to_go} steps on {keys[i]}' ) # correct in the opposite direction of error self . stepper_net_steps [ i ] += - steps_to_go self . net_step_error [ i ] += - steps_to_go stepper_dir = stepper . BACKWARD direction = np . sign ( steps_to_go ) if direction == - 1 : stepper_dir = stepper . FORWARD for _ in range ( abs ( steps_to_go )): self . steppers [ keys [ i ]] . onestep ( style = const . STEPPER_STYLE , direction = stepper_dir ) time . sleep ( const . STEP_WAIT ) logger . debug ( f 'Move cmd: {cmd}' ) pos_after = cmd [ 'pos_cmd' ] send_pos_cmd ( pos_after ) return def do_labjack_tasks ( self , cmd : dict ): packet = { 'LabJack Cmd' : { 'Time UTC (s)' : time . time (), 'Addresses Turned On' : 1 + np . where ( np . array ( cmd [ 'flasher_cmds' ]) > 0 )[ 0 ], } } self . tm_queue . put ( packet ) freq = 5. # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) return def close ( self ): [ self . steppers [ key ] . release () for key in self . steppers . keys ()] return","title":"Attributes"},{"location":"reference/hotspot/executive/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/executive/#add_cmds","text":"def add_cmds ( self , fname : str ) Read command input file and add commands to the command queue. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def add_cmds ( self , fname : str ) : ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ) : logger . warn ( f 'Input command number {len(rows)} exceeds command' + ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ) : cmd = {} cmd [ 'flasher_cmds' ] = [ int(item) for item in rows[i ][ 0 ] . split () ] cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ] , rows [ i ][ 2 ] ) self . cmd_queue . put ( cmd ) return","title":"add_cmds"},{"location":"reference/hotspot/executive/#cal_home","text":"def cal_home ( self ) Ask the user to input the current position of the center of the raft to store it as the home position. View Source def cal_home ( self ) : ''' Ask the user to input the current position of the center of the raft to store it as the home position . ''' print ( ' Where is home? Input the current position, in meters, of ' + ' the raft centroid relative to the mirror origin, then press ' + ' ENTER to store it as home. ' ) x = float ( input ( ' x-coord: ' )) y = float ( input ( ' y-coord: ' )) pos = ( x , y ) self . robot . home = pos self . robot . raft . position = pos logger . info ( f ' Home position set: {self.robot.home} ' ) return","title":"cal_home"},{"location":"reference/hotspot/executive/#cal_home_auto","text":"def cal_home_auto ( self ) Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. View Source def cal_home_auto ( self ) : ''' Moves motors to limits to calibrate the stepper positions. First moves to NW limit, then retracts cable from each other stepper until we can be sure all lines are taut. Updates the raft centroid position according to offsets in constants.py which depend on the (repeatable) position the raft ends up in when it reaches the NW limit. Assumptions: - All cables are slack, but without excessive cable played out. - Hawkeye signaling wires protrude from the S side of the raft, preventing us from choosing SW or SE as limit finding locations. - Corners form a rectangle. - Stepper torque is sufficient to hold the raft once at NW while SW, SE, NE retract. ''' # All motors must be released before starting , to NE , SE , SW don 't # inhibit motion [self.steppers[key].release() for key in self.steppers.keys()] # Worst case, about how far would we have to move before hitting NW? max_distance = np.linalg.norm(self.robot.surf.nw - self.robot.surf.se) max_radians = max_distance / const.PULLEY_RADIUS # valid for single or double steps max_steps = np.round(np.abs(max_radians) * const.DEG_PER_RAD / (360. / 200. / 1)).astype(int) num_steps = max(1, max_steps // 1) logger.info(' Homing to NW ') report_interval = 100 i = num_steps while i > 0: self.steppers[' nw '].onestep(style=stepper.DOUBLE, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') logger.info(' Retracting cables to tension NE , SE , SW ') i = num_steps while i > 0: self.steppers[' ne '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' se '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) self.steppers[' sw '].onestep(style=stepper.MICROSTEP, direction=stepper.BACKWARD) time.sleep(const.STEP_WAIT) i -= 1 if not i % report_interval: progress = 100. * (num_steps - i) / num_steps logger.info(f' Progress : { progress : .2 f } % ') pos = self.robot.surf.nw + np.array((const.HOMING_OFFSET_X, const.HOMING_OFFSET_Y)) self.robot.raft.position = pos self.robot.home = pos logger.info(f' Raft is homed with centroid position { self . robot . raft . position } ') logger.warning(' Verify that the raft has been driven to one of its limits and all cables are taut . If not , request CAL_HOME again . ') packet = {' algorithm ': { ' Time UTC ( s ) ': time.time(), ' Position Command ( m ) ' : pos, ' Motor Delta Angle Command ( rad ) ' : np . array ( [ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return","title":"cal_home_auto"},{"location":"reference/hotspot/executive/#close","text":"def close ( self ) View Source def close ( self ) : [ self.steppers[key ] . release () for key in self . steppers . keys () ] return","title":"close"},{"location":"reference/hotspot/executive/#do_labjack_tasks","text":"def do_labjack_tasks ( self , cmd : dict ) View Source def do_labjack_tasks ( self , cmd : dict ) : packet = { ' LabJack Cmd ' : { ' Time UTC (s) ' : time . time () , ' Addresses Turned On ' : 1 + np . where ( np . array ( cmd [ ' flasher_cmds ' ] ) > 0 ) [ 0 ], } } self . tm_queue . put ( packet ) freq = 5 . # Hz num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . spawn_all_threads ( self . lj_instance , cmd [ ' flasher_cmds ' ] ) num_blinks -= 1 else : hw . spawn_all_threads_off ( self . lj_instance ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1 . / freq ) - ( time . time () - start_time )) hw . spawn_all_threads_off ( self . lj_instance ) return","title":"do_labjack_tasks"},{"location":"reference/hotspot/executive/#do_motor_tasks","text":"def do_motor_tasks ( self , cmd : dict ) -> list Transform the move command into motor commands Parameters: Name Type Description Default cmd Command packet dictionary with keys for position commands to pass to control algorithm None View Source def do_motor_tasks ( self , cmd : dict ) -> list : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple ) : ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = [ 'sw', 'nw', 'ne', 'se' ] angs = [ cmd for cmd in [motor_cmds[key ] for key in keys ]] order , steps_taken , err = hw . all_steppers ( [ self.steppers[key ] for key in keys ] , angs ) # Perform corrections for rounding errors self . stepper_net_steps += steps_taken self . net_step_error += err logger . debug ( f 'Net steps: {self.stepper_net_steps}' ) logger . debug ( f 'Net step error incurred by rounding: {self.net_step_error}' ) for i , step_err in enumerate ( self . net_step_error ) : # If off by more than a step , fix it . if np . abs ( step_err ) >= 0.5 : steps_to_go = np . round ( step_err ). astype ( int ) logger . debug ( f 'Correcting {steps_to_go} steps on {keys[i]}' ) # correct in the opposite direction of error self . stepper_net_steps [ i ] += - steps_to_go self . net_step_error [ i ] += - steps_to_go stepper_dir = stepper . BACKWARD direction = np . sign ( steps_to_go ) if direction == - 1 : stepper_dir = stepper . FORWARD for _ in range ( abs ( steps_to_go )) : self . steppers [ keys[i ] ] . onestep ( style = const . STEPPER_STYLE , direction = stepper_dir ) time . sleep ( const . STEP_WAIT ) logger . debug ( f 'Move cmd: {cmd}' ) pos_after = cmd [ 'pos_cmd' ] send_pos_cmd ( pos_after ) return","title":"do_motor_tasks"},{"location":"reference/hotspot/executive/#empty_queue","text":"def empty_queue ( self , queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f65d47839b0 >> ) Completely empty the given Queue object. Parameters: Name Type Description Default queue None Any queue None View Source def empty_queue ( self , queue : mp . Queue ) : ''' Completely empty the given Queue object . Parameters ---------- queue Any queue ''' while not queue . empty () : queue . get () return","title":"empty_queue"},{"location":"reference/hotspot/executive/#go_home","text":"def go_home ( self ) Clear all commands in the queue and drive to the home position. View Source def go_home ( self ) : ''' Clear all commands in the queue and drive to the home position. ''' # If not already home , go there . eps = np . finfo ( float ). eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )) : logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = [] cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return","title":"go_home"},{"location":"reference/hotspot/executive/#run","text":"def run ( self , fname : str ) Main run function, including processing human input to switch between states. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def run ( self , fname : str ) : ''' Main run function , including processing human input to switch between states . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col . Data spec described in docstring of sequence () function . ''' # Allow user input to change the mode . input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue , ) , daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input . self . mode = ' WAIT ' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty () : kbd_in = self . kbd_queue . get_nowait () if ' c ' == kbd_in : logger . info ( ' Home calibration requested. ' ) self . mode = ' CAL_HOME ' elif ' i ' == kbd_in : logger . info ( ' Home position override requested. ' ) self . mode = ' INPUT_HOME ' elif ' h ' == kbd_in : logger . info ( ' Moving to home requested. ' ) self . mode = ' HOME ' elif ' s ' == kbd_in : logger . info ( ' Sequence run requested. ' ) self . mode = ' SEQ ' elif ' w ' == kbd_in : logger . info ( ' Wait mode requested. ' ) self . mode = ' WAIT ' else : continue if self . mode == ' CAL_HOME ' : self . cal_home_auto () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' INPUT_HOME ' : self . cal_home () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' HOME ' : self . go_home () self . mode = ' WAIT ' print ( MENU_STR ) elif self . mode == ' SEQ ' : self . sequence ( fname ) elif self . mode == ' WAIT ' : self . wait () else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down. ' ) running = False self . close () return","title":"run"},{"location":"reference/hotspot/executive/#sequence","text":"def sequence ( self , fname : str ) On each call, pop a new command off of the command queue and dispatch it to motors/LabJack. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate None View Source def sequence ( self , fname : str ) : ''' On each call , pop a new command off of the command queue and dispatch it to motors / LabJack . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col : - flasher_cmds : 1 or 0 depending on whether that address is enabled - pos_cmd_0s : 0 th element of position command coordinate - pos_cmd_1s : 1 st element of position command coordinate ''' # If we are changing to sequence from another mode , ensure we start # fresh if self . mode != self . last_mode : logger . info ( ' Beginning command sequence. ' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = ' WAIT ' return else : cmd = self . cmd_queue . get () progress = 100 . * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks , then LJ tasks in serial , so IR source tasks happen at the end of each move . self . do_motor_tasks ( cmd ) self . do_labjack_tasks ( cmd ) logger . info ( f ' Raft centroid: {self.robot.raft.position} ' ) logger . info ( f ' Command completed. Sequence progress: {progress:.2f} % ' ) self . router . process_tm ( plot_enable = self . plot_enable ) return","title":"sequence"},{"location":"reference/hotspot/executive/#wait","text":"def wait ( self ) View Source def wait ( self ) : if self . plot_enable : self . router . run_gui_event_loop () return","title":"wait"},{"location":"reference/hotspot/hardware/","text":"Module hotspot.hardware None None View Source # This file defines the interfaces used to command the hardware. import logging import numpy as np import threading import time from labjack import ljm import hotspot.constants as const from hotspot.hw_context import stepper , openS , eWriteAddress # Conventions: # - positive steps/angular rates (stepper.FORWARD) spin the motor shaft # clockwise (CW) when viewed from the rear. # - negative steps/angular rates (stepper.BACKWARD) spin the motor shaft # counterclockwise (CCW) when viewed from the rear. logger = logging . getLogger ( __name__ ) # Map relay number to modbus register on the LJ RELAY_DICT = { '1' : 2008 , '2' : 2009 , '3' : 2010 , '4' : 2011 , '5' : 2012 , '6' : 2013 , '7' : 2014 , '8' : 2015 , '9' : 2016 , '10' : 2017 , '11' : 2018 , '12' : 2019 } # Needed to open connection to labjack board MODEL_NAME = 'T7' MODE = 'USB' # ----------------------------------------------------------------------------- # Stepper functions # ----------------------------------------------------------------------------- def all_steppers ( steppers : list , radians : list ): ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters ---------- steppers iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) radians iterable of signed angle to move each stepper (radians) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper ''' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over-tension to mitigate skipping # steps: positive steps first to unwind cable, then negative order = np . argsort ( directions )[:: - 1 ] . astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_float = radians * const . DEG_PER_RAD / const . DEG_PER_STEP # We can detect and correct at the end of each move, using the accumulated # rounding errors. steps_to_go = np . round ( steps_float ) . astype ( int ) err = steps_float - steps_to_go steps_to_go = np . abs ( steps_to_go ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ): if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1, or 1 step per loop cycle. dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2x to allow integer arithmetic for _ in range ( dx ): for i , stepper_n in enumerate ( steppers ): # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ order [ i ]] += directions [ i ] . astype ( int ) deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return order , steps_taken , err [ order ] # ----------------------------------------------------------------------------- # LabJack Functions # ----------------------------------------------------------------------------- def try_open ( model : str , mode : str , retry = True ): ''' Try and open a connection to a LabJack. Parameters ---------- model LabJack board model name, typ. 'T7' mode LabJack communication mode, typ. 'USB' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( 'Error opening LJ connection' ) print ( err ) if retry : time . sleep ( 1 ) print ( 'Trying again in 1s.' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name def write_value ( handle , addr : int , value = 0 ): ''' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not ''' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True def threaded_write ( handle , target : int , value : int ): ''' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer ''' written = False while ( 1 ): try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return def spawn_all_threads ( handle , states : list ): ''' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take ''' for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], states [ int ( key ) - 1 ]), daemon = True ) thread . start () return def spawn_all_threads_off ( handle ): ''' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` ''' for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], 0 ), daemon = True ) thread . start () return if __name__ == '__main__' : pass Variables MODE MODEL_NAME RELAY_DICT logger Functions all_steppers def all_steppers ( steppers : list , radians : list ) The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters: Name Type Description Default steppers None iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) None radians None iterable of signed angle to move each stepper (radians) None Returns: Type Description steps_taken iterable of integers reporting the number of steps taken by each stepper View Source def all_steppers ( steppers : list , radians : list ) : ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm , in the pos quadrant only , with all lines starting at ( 0 , 0 ). All motors will either step or not according to the algorithm . ( We are kind of forgoing linear travel speed control here , but we never had reliable speed control anyway , because RPI Debian is not a RT OS .) Parameters ---------- steppers iterable of 4 x Adafruit MotorKit stepper instances ( not adafruit_motor . stepper module ) radians iterable of signed angle to move each stepper ( radians ) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper '' ' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over - tension to mitigate skipping # steps : positive steps first to unwind cable , then negative order = np . argsort ( directions )[ ::- 1 ]. astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_float = radians * const . DEG_PER_RAD / const . DEG_PER_STEP # We can detect and correct at the end of each move , using the accumulated # rounding errors . steps_to_go = np . round ( steps_float ). astype ( int ) err = steps_float - steps_to_go steps_to_go = np . abs ( steps_to_go ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ) : if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1 , or 1 step per loop cycle . dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2 x to allow integer arithmetic for _ in range ( dx ) : for i , stepper_n in enumerate ( steppers ) : # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ order [ i ]] += directions [ i ]. astype ( int ) deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return order , steps_taken , err [ order ] spawn_all_threads def spawn_all_threads ( handle , states : list ) Spawns threads and passes the states each relay will need to have Parameters: Name Type Description Default handle None LabJack board model handle from try_open None states None iterable of integers describing the states each relay should take None View Source def spawn_all_threads ( handle , states : list ) : ' '' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take '' ' for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , states [ int ( key ) - 1 ] ), daemon = True ) thread . start () return spawn_all_threads_off def spawn_all_threads_off ( handle ) Spawns threads and sets all relay states off. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None View Source def spawn_all_threads_off ( handle ) : ' '' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` '' ' for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , 0 ), daemon = True ) thread . start () return threaded_write def threaded_write ( handle , target : int , value : int ) Wrapper around write_value for use in threaded calls. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None target None LabJack relay address integer None View Source def threaded_write ( handle , target : int , value : int ) : ' '' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer '' ' written = False while ( 1 ) : try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return try_open def try_open ( model : str , mode : str , retry = True ) Try and open a connection to a LabJack. Parameters: Name Type Description Default model None LabJack board model name, typ. 'T7' None mode None LabJack communication mode, typ. 'USB' None Returns: Type Description name handle to opened LabJack board instance View Source def try_open ( model : str , mode : str , retry = True ) : ''' Try and open a connection to a LabJack . Parameters ---------- model LabJack board model name , typ . ' T7 ' mode LabJack communication mode , typ . ' USB ' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( ' Error opening LJ connection ' ) print ( err ) if retry : time . sleep ( 1 ) print ( ' Trying again in 1s. ' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name write_value def write_value ( handle , addr : int , value = 0 ) Write a value to a LabJack, catching errors. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None addr None LabJack relay address integer None Kwargs None None None ------ None None None value int value to write to LabJack relay None Returns: Type Description bool True if successful, False if not View Source def write_value ( handle , addr : int , value = 0 ) : ' '' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not '' ' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True","title":"Hardware"},{"location":"reference/hotspot/hardware/#module-hotspothardware","text":"None None View Source # This file defines the interfaces used to command the hardware. import logging import numpy as np import threading import time from labjack import ljm import hotspot.constants as const from hotspot.hw_context import stepper , openS , eWriteAddress # Conventions: # - positive steps/angular rates (stepper.FORWARD) spin the motor shaft # clockwise (CW) when viewed from the rear. # - negative steps/angular rates (stepper.BACKWARD) spin the motor shaft # counterclockwise (CCW) when viewed from the rear. logger = logging . getLogger ( __name__ ) # Map relay number to modbus register on the LJ RELAY_DICT = { '1' : 2008 , '2' : 2009 , '3' : 2010 , '4' : 2011 , '5' : 2012 , '6' : 2013 , '7' : 2014 , '8' : 2015 , '9' : 2016 , '10' : 2017 , '11' : 2018 , '12' : 2019 } # Needed to open connection to labjack board MODEL_NAME = 'T7' MODE = 'USB' # ----------------------------------------------------------------------------- # Stepper functions # ----------------------------------------------------------------------------- def all_steppers ( steppers : list , radians : list ): ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters ---------- steppers iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) radians iterable of signed angle to move each stepper (radians) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper ''' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over-tension to mitigate skipping # steps: positive steps first to unwind cable, then negative order = np . argsort ( directions )[:: - 1 ] . astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_float = radians * const . DEG_PER_RAD / const . DEG_PER_STEP # We can detect and correct at the end of each move, using the accumulated # rounding errors. steps_to_go = np . round ( steps_float ) . astype ( int ) err = steps_float - steps_to_go steps_to_go = np . abs ( steps_to_go ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ): if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1, or 1 step per loop cycle. dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2x to allow integer arithmetic for _ in range ( dx ): for i , stepper_n in enumerate ( steppers ): # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ order [ i ]] += directions [ i ] . astype ( int ) deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return order , steps_taken , err [ order ] # ----------------------------------------------------------------------------- # LabJack Functions # ----------------------------------------------------------------------------- def try_open ( model : str , mode : str , retry = True ): ''' Try and open a connection to a LabJack. Parameters ---------- model LabJack board model name, typ. 'T7' mode LabJack communication mode, typ. 'USB' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( 'Error opening LJ connection' ) print ( err ) if retry : time . sleep ( 1 ) print ( 'Trying again in 1s.' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name def write_value ( handle , addr : int , value = 0 ): ''' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not ''' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True def threaded_write ( handle , target : int , value : int ): ''' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer ''' written = False while ( 1 ): try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return def spawn_all_threads ( handle , states : list ): ''' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take ''' for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], states [ int ( key ) - 1 ]), daemon = True ) thread . start () return def spawn_all_threads_off ( handle ): ''' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` ''' for key in RELAY_DICT . keys (): thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ], 0 ), daemon = True ) thread . start () return if __name__ == '__main__' : pass","title":"Module hotspot.hardware"},{"location":"reference/hotspot/hardware/#variables","text":"MODE MODEL_NAME RELAY_DICT logger","title":"Variables"},{"location":"reference/hotspot/hardware/#functions","text":"","title":"Functions"},{"location":"reference/hotspot/hardware/#all_steppers","text":"def all_steppers ( steppers : list , radians : list ) The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm, in the pos quadrant only, with all lines starting at (0, 0). All motors will either step or not according to the algorithm. (We are kind of forgoing linear travel speed control here, but we never had reliable speed control anyway, because RPI Debian is not a RT OS.) Parameters: Name Type Description Default steppers None iterable of 4x Adafruit MotorKit stepper instances (not adafruit_motor.stepper module) None radians None iterable of signed angle to move each stepper (radians) None Returns: Type Description steps_taken iterable of integers reporting the number of steps taken by each stepper View Source def all_steppers ( steppers : list , radians : list ) : ''' The number of steps any motor must take on each loop execution can be cast as a special case of Bresenham's Line Algorithm , in the pos quadrant only , with all lines starting at ( 0 , 0 ). All motors will either step or not according to the algorithm . ( We are kind of forgoing linear travel speed control here , but we never had reliable speed control anyway , because RPI Debian is not a RT OS .) Parameters ---------- steppers iterable of 4 x Adafruit MotorKit stepper instances ( not adafruit_motor . stepper module ) radians iterable of signed angle to move each stepper ( radians ) Returns ------- steps_taken iterable of integers reporting the number of steps taken by each stepper '' ' style = const . STEPPER_STYLE directions = np . sign ( radians ) # Perform steps in an order that avoids over - tension to mitigate skipping # steps : positive steps first to unwind cable , then negative order = np . argsort ( directions )[ ::- 1 ]. astype ( int ) directions = np . array ( directions )[ order ] radians = np . array ( radians )[ order ] steppers = np . array ( steppers )[ order ] steps_float = radians * const . DEG_PER_RAD / const . DEG_PER_STEP # We can detect and correct at the end of each move , using the accumulated # rounding errors . steps_to_go = np . round ( steps_float ). astype ( int ) err = steps_float - steps_to_go steps_to_go = np . abs ( steps_to_go ) stepper_dirs = [ stepper . FORWARD ] * 4 for i , direction in enumerate ( directions ) : if direction == - 1 : stepper_dirs [ i ] = stepper . BACKWARD # Normalize the slopes of the lines by making the motor that must take # the most total steps have a slope = 1 , or 1 step per loop cycle . dx = np . max ( steps_to_go ) dy = steps_to_go steps_taken = [ 0 ] * 4 deltas = 2 * dy - dx # 2 x to allow integer arithmetic for _ in range ( dx ) : for i , stepper_n in enumerate ( steppers ) : # decide whether to step or not if deltas [ i ] > 0 : stepper_n . onestep ( style = style , direction = stepper_dirs [ i ]) time . sleep ( const . STEP_WAIT ) steps_taken [ order [ i ]] += directions [ i ]. astype ( int ) deltas [ i ] -= 2 * dx deltas [ i ] += 2 * dy [ i ] return order , steps_taken , err [ order ]","title":"all_steppers"},{"location":"reference/hotspot/hardware/#spawn_all_threads","text":"def spawn_all_threads ( handle , states : list ) Spawns threads and passes the states each relay will need to have Parameters: Name Type Description Default handle None LabJack board model handle from try_open None states None iterable of integers describing the states each relay should take None View Source def spawn_all_threads ( handle , states : list ) : ' '' Spawns threads and passes the states each relay will need to have Parameters ---------- handle LabJack board model handle from `try_open` states iterable of integers describing the states each relay should take '' ' for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , states [ int ( key ) - 1 ] ), daemon = True ) thread . start () return","title":"spawn_all_threads"},{"location":"reference/hotspot/hardware/#spawn_all_threads_off","text":"def spawn_all_threads_off ( handle ) Spawns threads and sets all relay states off. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None View Source def spawn_all_threads_off ( handle ) : ' '' Spawns threads and sets all relay states off. Parameters ---------- handle LabJack board model handle from `try_open` '' ' for key in RELAY_DICT . keys () : thread = threading . Thread ( target = threaded_write , args = ( handle , RELAY_DICT [ key ] , 0 ), daemon = True ) thread . start () return","title":"spawn_all_threads_off"},{"location":"reference/hotspot/hardware/#threaded_write","text":"def threaded_write ( handle , target : int , value : int ) Wrapper around write_value for use in threaded calls. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None target None LabJack relay address integer None View Source def threaded_write ( handle , target : int , value : int ) : ' '' Wrapper around `write_value` for use in threaded calls. Parameters ---------- handle LabJack board model handle from `try_open` target LabJack relay address integer '' ' written = False while ( 1 ) : try : if written == False : written = write_value ( handle , target , value = value ) if written == False : time . sleep ( 1 ) else : break else : break except KeyboardInterrupt : answer = input ( 'Do you want to interrupt? y/n' ) if answer . lower () == 'y' : break return","title":"threaded_write"},{"location":"reference/hotspot/hardware/#try_open","text":"def try_open ( model : str , mode : str , retry = True ) Try and open a connection to a LabJack. Parameters: Name Type Description Default model None LabJack board model name, typ. 'T7' None mode None LabJack communication mode, typ. 'USB' None Returns: Type Description name handle to opened LabJack board instance View Source def try_open ( model : str , mode : str , retry = True ) : ''' Try and open a connection to a LabJack . Parameters ---------- model LabJack board model name , typ . ' T7 ' mode LabJack communication mode , typ . ' USB ' Returns ------- name handle to opened LabJack board instance ''' try : name = openS ( model , mode ) except ljm . LJMError as err : print ( ' Error opening LJ connection ' ) print ( err ) if retry : time . sleep ( 1 ) print ( ' Trying again in 1s. ' ) name = try_open ( model , mode , retry = False ) else : return - 1 return name","title":"try_open"},{"location":"reference/hotspot/hardware/#write_value","text":"def write_value ( handle , addr : int , value = 0 ) Write a value to a LabJack, catching errors. Parameters: Name Type Description Default handle None LabJack board model handle from try_open None addr None LabJack relay address integer None Kwargs None None None ------ None None None value int value to write to LabJack relay None Returns: Type Description bool True if successful, False if not View Source def write_value ( handle , addr : int , value = 0 ) : ' '' Write a value to a LabJack, catching errors. Parameters ---------- handle LabJack board model handle from `try_open` addr LabJack relay address integer Kwargs ------ value: int value to write to LabJack relay Returns ------- bool True if successful, False if not '' ' try : eWriteAddress ( handle , addr , 0 , value ) except ljm . LJMError as err : print ( \"Error in write to LJ, specific error is:\" ) print ( err ) return False return True","title":"write_value"},{"location":"reference/hotspot/hw_context/","text":"Module hotspot.hw_context None None View Source # This file abstracts the hardware module imports away and provides contingency # modules so dev and testing can be done on a non-rpi machine without hardware # attached. from adafruit_motor import stepper from labjack import ljm try : from adafruit_motorkit import MotorKit except NotImplementedError as err : print ( err ) print ( 'No Adafruit MotorKit module compatibility found at import. Falling back to dummy class for simulation support.' ) class DummyStepperMotor : def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass # Dummy motorkit class MotorKit : def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor () try : name = ljm . openS ( 'T7' , 'USB' ) eWriteAddress = ljm . eWriteAddress openS = ljm . openS except ljm . LJMError as err : print ( err ) print ( 'No LabJack modules found at import. Falling back to dummy class for simulation support.' ) def dummyEwriteAddress ( handle , addr , mode , value ): return def dummyOpenS ( model : str , mode : str ): return None # Overwrite eWriteAddress = dummyEwriteAddress openS = dummyOpenS Functions dummyEwriteAddress def dummyEwriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return dummyOpenS def dummyOpenS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None eWriteAddress def eWriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return openS def openS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None Classes DummyStepperMotor class DummyStepperMotor ( ) View Source class DummyStepperMotor: def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass Methods onestep def onestep ( self , direction = 1 , style = 1 ) View Source def onestep(self, direction=1, style=1): pass release def release ( self ) View Source def release(self): pass MotorKit class MotorKit ( address = 0 , steppers_microsteps = 1 , pwm_frequency = 1600 ) View Source class MotorKit: def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor ()","title":"Hw Context"},{"location":"reference/hotspot/hw_context/#module-hotspothw_context","text":"None None View Source # This file abstracts the hardware module imports away and provides contingency # modules so dev and testing can be done on a non-rpi machine without hardware # attached. from adafruit_motor import stepper from labjack import ljm try : from adafruit_motorkit import MotorKit except NotImplementedError as err : print ( err ) print ( 'No Adafruit MotorKit module compatibility found at import. Falling back to dummy class for simulation support.' ) class DummyStepperMotor : def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass # Dummy motorkit class MotorKit : def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor () try : name = ljm . openS ( 'T7' , 'USB' ) eWriteAddress = ljm . eWriteAddress openS = ljm . openS except ljm . LJMError as err : print ( err ) print ( 'No LabJack modules found at import. Falling back to dummy class for simulation support.' ) def dummyEwriteAddress ( handle , addr , mode , value ): return def dummyOpenS ( model : str , mode : str ): return None # Overwrite eWriteAddress = dummyEwriteAddress openS = dummyOpenS","title":"Module hotspot.hw_context"},{"location":"reference/hotspot/hw_context/#functions","text":"","title":"Functions"},{"location":"reference/hotspot/hw_context/#dummyewriteaddress","text":"def dummyEwriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return","title":"dummyEwriteAddress"},{"location":"reference/hotspot/hw_context/#dummyopens","text":"def dummyOpenS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None","title":"dummyOpenS"},{"location":"reference/hotspot/hw_context/#ewriteaddress","text":"def eWriteAddress ( handle , addr , mode , value ) View Source def dummyEwriteAddress ( handle , addr , mode , value ) : return","title":"eWriteAddress"},{"location":"reference/hotspot/hw_context/#opens","text":"def openS ( model : str , mode : str ) View Source def dummyOpenS ( model : str , mode : str ) : return None","title":"openS"},{"location":"reference/hotspot/hw_context/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/hw_context/#dummysteppermotor","text":"class DummyStepperMotor ( ) View Source class DummyStepperMotor: def __init__ ( self ): pass def onestep ( self , direction = 1 , style = 1 ): pass def release ( self ): pass","title":"DummyStepperMotor"},{"location":"reference/hotspot/hw_context/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/hw_context/#onestep","text":"def onestep ( self , direction = 1 , style = 1 ) View Source def onestep(self, direction=1, style=1): pass","title":"onestep"},{"location":"reference/hotspot/hw_context/#release","text":"def release ( self ) View Source def release(self): pass","title":"release"},{"location":"reference/hotspot/hw_context/#motorkit","text":"class MotorKit ( address = 0 , steppers_microsteps = 1 , pwm_frequency = 1600 ) View Source class MotorKit: def __init__ ( self , address = 0x0 , steppers_microsteps = 1 , pwm_frequency = 1600 ): self . address = address self . steppers_microsteps = steppers_microsteps self . pwm_frequency = pwm_frequency self . stepper1 = DummyStepperMotor () self . stepper2 = DummyStepperMotor ()","title":"MotorKit"},{"location":"reference/hotspot/telemetry/","text":"Module hotspot.telemetry None None View Source # This file defines functions for outputting telemetry (TM) and visualization. import logging import matplotlib.pyplot as plt import multiprocessing as mp import numpy as np import os import time import h5py import hotspot.constants as const logger = logging . getLogger ( __name__ ) class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ): logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle [ source ] . keys () if 'utc' not in key . lower ()] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: { source } ' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten ()[ i ] for i , key in enumerate ( keys )} plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ): ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self . source ][ 'Time UTC (s)' ] data = file_handle [ self . source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower (): if first_time : ax . plot ( data [:, 0 ], data [:, 1 ], color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [:, 0 ], data [:, 1 ]) else : # line plot for timeseries if first_time : ax . plot ( time [:], data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ]): ax . lines [ j ] . set_data ( time [:], data [:, j ]) else : logger . warn ( f '[ { varname } ] Plotting data of shape { data . shape } not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return class DataRouter : def __init__ ( self , tm_queue : mp . Queue ): logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m %d -%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ): ''' Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. ''' # Otherwise, create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys (): # Get a group, making it if it doesn't exist if source not in f . keys (): f . create_group ( source ) group = f [ source ] for var in packet [ source ] . keys (): data = packet [ source ][ var ] # Get a dataset, making it if it doesn't exist if var in group . keys (): dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1 :])) dset [ - 1 ] = data else : data = np . array ([ packet [ source ][ var ]]) maxshape = ( None , * data . shape [ 1 :]) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ): ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty (): self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def run_gui_event_loop ( self ): plt . pause ( 1 ) return def update_display ( self ): ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys (): first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys (): self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys (): if 'utc' in var . lower (): continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Variables logger Classes DataRouter class DataRouter ( tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f65d47839b0 >> ) View Source class DataRouter : def __init__ ( self , tm_queue : mp . Queue ) : logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m%d-%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def run_gui_event_loop ( self ) : plt . pause ( 1 ) return def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Methods process_packet def process_packet ( self , packet : dict ) Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. View Source def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return process_tm def process_tm ( self , plot_enable = False ) Function to continuously log TM to file and update plots as TM comes in. View Source def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in . ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () run_gui_event_loop def run_gui_event_loop ( self ) View Source def run_gui_event_loop ( self ) : plt . pause ( 1 ) return update_display def update_display ( self ) Function to update plotters. View Source def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Visualizer class Visualizer ( file_handle : h5py . _hl . files . File , source : str ) View Source class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ) : logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle[source ] . keys () if 'utc' not in key . lower () ] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: {source}' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten () [ i ] for i , key in enumerate ( keys ) } plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return Methods update_subplot def update_subplot ( self , file_handle : h5py . _hl . files . File , varname : str , first_time : bool ) View Source def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"Telemetry"},{"location":"reference/hotspot/telemetry/#module-hotspottelemetry","text":"None None View Source # This file defines functions for outputting telemetry (TM) and visualization. import logging import matplotlib.pyplot as plt import multiprocessing as mp import numpy as np import os import time import h5py import hotspot.constants as const logger = logging . getLogger ( __name__ ) class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ): logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle [ source ] . keys () if 'utc' not in key . lower ()] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: { source } ' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten ()[ i ] for i , key in enumerate ( keys )} plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ): ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self . source ][ 'Time UTC (s)' ] data = file_handle [ self . source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower (): if first_time : ax . plot ( data [:, 0 ], data [:, 1 ], color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [:, 0 ], data [:, 1 ]) else : # line plot for timeseries if first_time : ax . plot ( time [:], data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ]): ax . lines [ j ] . set_data ( time [:], data [:, j ]) else : logger . warn ( f '[ { varname } ] Plotting data of shape { data . shape } not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return class DataRouter : def __init__ ( self , tm_queue : mp . Queue ): logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m %d -%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ): ''' Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. ''' # Otherwise, create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys (): # Get a group, making it if it doesn't exist if source not in f . keys (): f . create_group ( source ) group = f [ source ] for var in packet [ source ] . keys (): data = packet [ source ][ var ] # Get a dataset, making it if it doesn't exist if var in group . keys (): dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1 :])) dset [ - 1 ] = data else : data = np . array ([ packet [ source ][ var ]]) maxshape = ( None , * data . shape [ 1 :]) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ): ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty (): self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def run_gui_event_loop ( self ): plt . pause ( 1 ) return def update_display ( self ): ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys (): first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys (): self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys (): if 'utc' in var . lower (): continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"Module hotspot.telemetry"},{"location":"reference/hotspot/telemetry/#variables","text":"logger","title":"Variables"},{"location":"reference/hotspot/telemetry/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/telemetry/#datarouter","text":"class DataRouter ( tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f65d47839b0 >> ) View Source class DataRouter : def __init__ ( self , tm_queue : mp . Queue ) : logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m%d-%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () def run_gui_event_loop ( self ) : plt . pause ( 1 ) return def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"DataRouter"},{"location":"reference/hotspot/telemetry/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/telemetry/#process_packet","text":"def process_packet ( self , packet : dict ) Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Time UTC (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Time UTC (s)'. Values can be 1- or 2-D. View Source def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Time UTC ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Time UTC ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return","title":"process_packet"},{"location":"reference/hotspot/telemetry/#process_tm","text":"def process_tm ( self , plot_enable = False ) Function to continuously log TM to file and update plots as TM comes in. View Source def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in . ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display ()","title":"process_tm"},{"location":"reference/hotspot/telemetry/#run_gui_event_loop","text":"def run_gui_event_loop ( self ) View Source def run_gui_event_loop ( self ) : plt . pause ( 1 ) return","title":"run_gui_event_loop"},{"location":"reference/hotspot/telemetry/#update_display","text":"def update_display ( self ) Function to update plotters. View Source def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'utc' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"update_display"},{"location":"reference/hotspot/telemetry/#visualizer","text":"class Visualizer ( file_handle : h5py . _hl . files . File , source : str ) View Source class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ) : logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle[source ] . keys () if 'utc' not in key . lower () ] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: {source}' ) fig . tight_layout () self . fig = fig self . var_axes = { key : axes . flatten () [ i ] for i , key in enumerate ( keys ) } plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"Visualizer"},{"location":"reference/hotspot/telemetry/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/telemetry/#update_subplot","text":"def update_subplot ( self , file_handle : h5py . _hl . files . File , varname : str , first_time : bool ) View Source def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = file_handle [ self.source ][ 'Time UTC (s)' ] data = file_handle [ self.source ][ varname ] dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"update_subplot"}]}