{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This repo contains code that is a part of the TIME collaboration . Logo by Guochao (Jason) Sun. hotspot Code for driving a cable-driven parallel robot for mapping beams on surfaces. The robot moves and controls switchable thermal infrared sources to scan a 2D x-y plane, and is capable of absolute accuracy at the <3 mm level over a workspace ~0.40m x 0.40m. Running Run python main.py -h for the docstring describing the command line interface. Example python main.py ./data/input/geometry/frame.csv ./data/input/profiles/circle.csv Other Documentation See the HOWTO . Contributing Testing Testing is accomplished with pytest . Passing tests are a prerequisite for committing code, and new code should come with new tests. To run the test suite defined in the tests dir, change dir to the toplevel dir of the repo and execute pytest Pushing changes If you need push permissions, message me. Otherwise, you may fork, create a new branch with your changes, and fill out a Pull Request to have the changes reviewed and merged in. How did you make your algorithm flowcharts? diagrams.net","title":"Home"},{"location":"#hotspot","text":"Code for driving a cable-driven parallel robot for mapping beams on surfaces. The robot moves and controls switchable thermal infrared sources to scan a 2D x-y plane, and is capable of absolute accuracy at the <3 mm level over a workspace ~0.40m x 0.40m.","title":"hotspot"},{"location":"#running","text":"Run python main.py -h for the docstring describing the command line interface.","title":"Running"},{"location":"#example","text":"python main.py ./data/input/geometry/frame.csv ./data/input/profiles/circle.csv","title":"Example"},{"location":"#other-documentation","text":"See the HOWTO .","title":"Other Documentation"},{"location":"#contributing","text":"","title":"Contributing"},{"location":"#testing","text":"Testing is accomplished with pytest . Passing tests are a prerequisite for committing code, and new code should come with new tests. To run the test suite defined in the tests dir, change dir to the toplevel dir of the repo and execute pytest","title":"Testing"},{"location":"#pushing-changes","text":"If you need push permissions, message me. Otherwise, you may fork, create a new branch with your changes, and fill out a Pull Request to have the changes reviewed and merged in.","title":"Pushing changes"},{"location":"#how-did-you-make-your-algorithm-flowcharts","text":"diagrams.net","title":"How did you make your algorithm flowcharts?"},{"location":"HOWTO/","text":"How To This doc contains instructions for various tasks related to setting up and running the hotspot mirror mapper. What is hotspot ? hotspot is a planar cable-driven parallel robot (CDPR), with four stepper motors that move a central raft of hot IR sources by changing the length of cables attached to it. The cables are fixed to an adjustable frame. The frame can clamp to any rectangular surface, but it was designed to clamp to various relay mirrors that couple radiation from the sky to the TIME spectrometer inside the receiver cabin on the ARO 12 meter telescope on Kitt Peak, allowing an electronically controlled, hot, IR-emitting source to be swept across the mirror to observe the detectors' spatial response. What is this document? This document is a comprehensive how-to on setting up, maintaining, and running the mirror mapper. It contains all the information that would be needed to replace and reconfigure major components of the system, however unlikely that may be. It is organized in order of information flow: from the operator (you!) logging into the control computer, to setting up the software environment, connecting the power and signal cables, assembling the mapper frame, creating input files, mounting it on various mirrors, and operating the mapper. Using the control computer The mapper motors are controlled by running the main.py application on a computer with a USB-to-RS485 adapter . The IR sources are controlled via a USB cable connected to a microcontroller. You should check out the hotspot repo if you wish to run the mapper or generate new input files . Setting Up the Environment To run hotspot , you must satisfy the dependencies. They are enumerated in environment.yml , a human-readable file that can be ingested by the conda Python package manager. Is the environment set up? First, check that the environment setup has not been done before. If conda activate hotspot succeeds, skip to software testing with pytest . Anaconda Is Anaconda set up? If the Python environment/package manager Anaconda does not exist on the computer you're running this on, I recommend installing Miniconda according to the instructions . Once that is done, we are ready to set up the hotspot environment. conda environments keep a project's dependencies from polluting your computer's environment and make sure they all play nicely together. conda allows specifying the dependencies needed in a file with a .yml extension. This is done for you. Create the hotspot conda env with conda env create -f environment.yml It should install things like numpy and matplotlib , as well as libraries for the hardware, such as the pyserial library for driving the steppers. There are also packages for documentation. NOTE: packages needed for post-processing of photos to measure mapper performance or for producing predicted beam maps using the code in the verification/ folder are not covered by this .yml . Aside from OpenCV they are just standard scientific Python packages, so the requirements should be easy to meet if this code is needed. Keeping things up to date If you need to install something new later on with conda install or pip , remember to update environment.yml by doing conda env export --from-history | tee environment.yml If your environment.yml has been updated, and you need to update your env with the new environment.yml , do conda env update --file environment.yml --prune Software Testing with pytest In order to verify that basic low-level functionality is unbroken, run pytest from the toplevel directory of the repo. Power Motors Do the motor driver boards have power? Each motor is controlled by an AllMotion EZStepper EZHR17EN . These are chopper driver boards that accept 10-40 V input. Configure a constant-voltage DC power supply to provide: 24 V 4 A The EZStepper drivers are configured in software to draw 50% of the rated 2 A current = 1 A each, for a total of 4 A. In use, the motors may draw somewhat less current. Note: See the AllMotion/American Control Electronics wiring diagram to identify the Vin and GND inputs. Hawkeyes Do the Hawkeyes have power? The Hawkeyes are mounted on a PCB and powered by a power supply connected to the screw terminal. Positive and ground terminals are labeled on the PCB silkscreen (white text). Requirements: 6.7 V (constant voltage) \u2265 2 A The Hawkeye IR-50 source temperature depends on the voltage applied, and the current draw depends on the voltage (see datasheet in pdf dir). The design target temperature is 750 C, requiring a voltage of 6.7V and a current of ~134mA per source, for a total current draw of ~1.74A when all sources are turned on. In practice, Hawkeye sources have not drawn quite this much current. There will be some voltage drop at the screw terminal; this is normal. If one source is powered, the voltage drop is negligible, but if all 13 sources are powered, the voltage drop is approximately .22 V. Do not attempt to compensate for this at the power supply! If you turn up the supply voltage to 6.9 V to get 6.7 V under a 13 source load, a load of a single source will see 6.9 V, drastically reducing its lifetime. Hawkeye Microcontroller The Hawkeye sources are turned on and off by an Adafruit Trinket M0 microcontroller. It gets 5V power via a micro USB cable. Does the microcontroller have power? The Trinket M0's power LED will illuminate when it is connected to the USB port. The Trinket GND pin should be connected to the Hawkeye power supply's ground terminal. Frame Is the frame fully assembled? The 3D printed stepper motor mounts are attached to the beam mapper frame by 5/16-18 x 2\" or 2.25\" bolts with nyloc \"jam\" nuts. Two aluminum registration tabs are screwed into the end of each frame piece opposite the black plastic end caps, using a 5/16-18 x 1/4\" screw. They are long enough to reach an edge of the mirror regardless of if the mirror's corners have been machined off. NOTE: These tabs register the frame to a third edge of the mirror, so it is important that they not be bent . Long 5/16-18 steel threaded rods connect the two halves of the frame. On one end of the threaded rods, threads in the aluminum extrusion provide clamping force. On the other end of the threaded rod, a slide-adjust nut with a thumb button allows easily changing the distance between clamping surfaces, and applies clamping force to the outside of the opposite aluminum extrusion. Care should be exercised with this slide-adjust nut, as pressing the button will release any tension on the threaded rod. Serial Communications We will be talking to devices over serial. Windows Windows users may need to open hotspot/constants.py and edit the COM values to match the COM ports assigned to the Hawkeye microcontroller and USB-to-RS485 converter by the OS. Ubuntu On Ubuntu, our user must be a part of a special group to talk to devices over serial. To see the groups your user is a part of, type groups in a command prompt. Add yourself to the tty and dialout groups, then log out and back in to have the changes take effect: sudo usermod -a -G tty $USER sudo usermod -a -G dialout $USER Motion Outputs Motors Can the computer talk to the motor drivers? The EZHR17EN stepper drivers receive commands from a control computer running the hotspot software as bytes over the RS485 physical layer. Note: Refer to the AllMotion/American Control Electronics EZHR17EN wiring diagram to verify that the RS485 communications connection is correct. The control computer needs either a 9-pin serial output port, or a USB-to-RS485 adapter to send bytes out over the RS485 bus. The inverting/non-inverting outputs are blue and yellow wires. If you are connecting your adapter to the bus for the first time, you may have to guess incorrectly and swap the wires before it will work. The motor drivers must have power and ground (via the 24 VDC power supply) to receive commands. NOTE: RS-485 Connections ought to have a ground wire, although you don't see one pictured here. This is to ensure the differential signal at each receiver is biased correctly. If you experience communication issues on the RS-485 bus, ensure proper grounding. Can the motor drivers command the motors? Note: Refer to the AllMotion/American Control Electronics EZHR17EN wiring diagram to verify that the motor winding connections are correct. The stepper motors themselves have NEMA-17 spec hole patterns, which mate to the 3D printed motor mount brackets which are attached to the beam mapper frame. Each stepper motor should be attached to its motor mount using M3 x 0.5 x 10 mm screws. If attaching motors for the first time, use lubricant, because metal on plastic will be squeaky. At this point, it is important to consider the mapping of motor driver board address -> stepper motor -> motor mount -> corner of beam mapper frame -> corner of raft. The Executive.__init__() function in executive.py specifies this mapping, so the motor installation location and stepper instance in __init__() should match, to ensure the correct motor commands are sent to the correct stepper. The stepper driver boards are addressable with a selector switch on top. Match the address selector to the correct corner of the raft in the __init__() function. Can the encoders provide position feedback? The EZHR17EN boards are capable of reading out quadrature encoders affixed to the stepper shafts. Encoder feedback is critical for accurate positioning of the raft. Note: Refer to the AllMotion/American Control Electronics EZHR17EN wiring diagram to verify that the encoder connections are correct. Spools Can the motors make the lines longer and shorter? The stepper motors drive winch-like drums directly, to change the length of the cables predictably. They are cylindrical drums with helical threads to accept the cables. If they are not already attached, the cable drums should be fixed to the 5 mm stepper motor shaft via one M3 setscrew. The screws mate to steel threaded inserts that are pressed into the PETG plastic spools. The fishing line is affixed to the each spool by wrapping it around the setscrew and screwing it in to the threaded recess on the spool circumference. NOTE: Positive motor rotation is defined by convention to spin the shaft clockwise when viewed from the rear of the motor. Cables should be oriented relative to the spool such that a positive motor rotation produces a positive cable length change (i.e., cable is played out from the spool), and a negative motor rotation winds cable onto the spool. Since helical threads change the position along the drum $y$ that the cable exits as a function of motor position, the actual length of cable change for a given rotation depends on the thread pitch. Also, a controlled spooling mechanism is usually required. In this case, the corresponding eyelet is located some distance from the spool to achieve controlled spooling with less complexity. After attaching the cables to the spools, the other end should be threaded through the ~.9mm hole in the motor mount bracket on the opposite E-W side of the frame. NOTE: All cables should be cut long enough to permit the raft to visit each corner of the frame, even when the frame is as far apart as it can be (~25.5\"). Finally, excess cable should be wound onto the drum by hand, under tension, to ensure the cable is seated in the drum's grooves. Radiation Outputs Will moving the cables move the Hawkeyes? The end effector of this robot is a rectangular raft carrying several Hawkeye Technologies IR-50 emitters. The robot drives the centroid of the effector to a specified position, and the control algorithm performs a sequence of flashes using a number of the emitters to enhance the detectability of the signal in the IR receiver output data. Pass the cables that emerge from the corner eyelets to the closest eyelets on the raft. Wrap the ends of the fishing line around the screws in each corner of the raft, and screw them down. Can the computer command the Hawkeyes? The Hawkeye IR sources are arranged in roughly 3 concentric circles. Each circle is a separately controllable group of sources, which can be turned on and off by the control software. The first group is a single center source. The second group is the inner ring of six sources surrounding the center. The third group is the outer ring of six sources. Turning on more sources increases the intensity that the TIME receiver sees; this may be necessary for mapping optics where the beam is less concentrated. Each group is turned on and off by a MOSFET on the raft. The MOSFET gates are controlled by the outputs of a shift register chip. The shift register multiplexes 8 bits (a byte) received at its input to its 8 output pins. Only 3 of the 8 are connected to MOSFETs. The shift register receives a byte from an Adafruit Trinket M0 microcontroller over SPI via the black silicone ribbon cable, which should be hooked up to the grey connector on the raft. The connector pinout is on the back of the PCB. The other end of the cable is soldered to the Trinket M0 pins. The data connection pinout from the Trinket M0 to the ribbon cable connector is as follows: Trinket M0 GND \u2192 GND The shift register GND must be the same as the microcontroller ground. This should be grounded to the Hawkeye power ground as well. Trinket M0 BAT \u2192 5 V 5 V from the USB connector appears here. This powers the shift register. Trinket M0 2 \u2192 LATCH This pin goes low when an SPI transfer is started Trinket M0 4 \u2192 CLK This pin pulses during an SPI transfer to delineate bits to the shift register. Trinket M0 5 \u2192 PICO (peripheral input, controller output) This pin goes low or high during an SPI transfer to send bits to the shift register. The Trinket M0 receives a byte from the control computer over a USB serial connection and forwards it to the shift register over SPI. Profile Input File .csv: flasher_cmds value Trinket M0 SPI Output Bit Representation (Shift Register Outputs) Trinket M0 RGB LED Color Hawkeyes On 0 0 0000000 (Dimmed) None 1 1 0000001 Red Center 2 2 0000010 Green Inner 3 3 0000011 Yellow Center, Inner 4 4 0000100 Blue Outer 5 5 0000101 Purple Center, Outer 6 6 0000110 Cyan Inner, Outer 7 7 0000111 White Center, Inner, Outer The control computer will flash whichever group of Hawkeyes is specified by the input profile .csv file at 5 Hz. Cable Maintenance What if a cable breaks? The original cable is Spiderwire EZ Braid braided dyneema fishing line (50 lb pull strength), chosen for its stretch resistance. A replacement can be found at any tackle store or Wal-Mart, but a spool of extra cable should already be stored with the beam mapper. Cable length should be carefully sized to allow the raft to reach all corners of the workspace, but with as little extra length as possible at the maximum allowed separation of 25.5\". Coordinate System In order for the raft to be moved to a meaningful position in mirror-space, coordinates must be referenced to sensible locations where the mirror edges and robot frame register to one another. x-axis : plane of contact between the \"south\" frame and an edge of the mirror y-axis : plane of contact between the \"west\" side aluminum registration tab and a perpendicular mirror edge. The coordinate system of the robot therefore has its origin at the SW corner, where the aluminum alignment tab on the fixed frame meets the aluminum extrusion face. Input Files There are two types of input files: geometry and profile . Read on to learn what they are for and what is inside each. Ok, but is there an easy way to make a new one? .ipynb files are provided in the data/input/* directories to assist with making these input files. Most likely, you will only need data/input/create_profile.ipynb . You will need Jupyter installed on the computer running this notebook. Then simply copy the new files to the /data/input/* directory. Geometry Geometry files are one-line .csv files in data/input/geometry . create_geometry.ipynb is provided to script the creation of geometry files. Each one defines the physical setup of the robot when it is in a certain configuration, for instance, when it is installed on a mirror of a certain dimension. Each column entry describes an aspect of the physical setup of the system. A simplistic example: sw_0 sw_1 nw_0 nw_1 se_0 se_1 ne_0 ne_1 w h 0 0 0 1 1 0 1 1 .1 .1 Each corner point is the location of an eyelet through which the cable passes, expressed relative to the SW origin, described above. The width and height of the raft are defined by the separations between eyelets on the raft through which the cable passes. NOTE: If the dimensions of the frame eyelets have been measured relative to each edge, the y-positions of the corner eyelets can be calculated as a function of the separation between the aluminum extrusions that make up the support structure and clamping surfaces. The eyelets of the motor mounts measured 6.19 +/- 0.5 mm from the frame to the face of the motor mount bracket on the interior of the mapping region, and 7.96 +/- 0.02 mm from the face of the motor mount to the eyelet, for a total eyelet offset from the contact patch of 0.014 +/- 0.001 m. This value will be used to calculate eyelet y-positions as a function of frame separation. The eyelet positions should not ever change in the x-direction, unless the motor mounts are removed from the aluminum frames. Profile Profile files are multi-line .csv files in data/input/profiles . Each line defines a new position to which the robot should move, in the coordinate system defined above, and which group of Hawkeye sources should be flashed. profiles/create_profile.ipynb is provided to script the creation of profiles. Upon reaching each location in the profile, the robot is programmed to flash Hawkeye sources on and off (default: 10 \"on\" states, 50% duty cycle, 5 Hz). Which group of sources is enabled is configurable with the flasher_cmds column in the profile .csv. See the table in the previous section. Some examples follow. For example, to move to a single coordinate and flash all three groups of Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 7 .5 .5 to move to a single coordinate and flash only the center Hawkeye: flasher_cmds pos_cmd_0s pos_cmd_1s 1 .5 .5 to move to a single coordinate and flash the center and inner ring Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 2 .5 .5 Building up a sequence of these moves allows a shape to be scanned. Output Files Output files store telemetry for each run in data/output . They are timestamped .hdf5 files. Physical Installation General tips Having two people helps. SAFETY ALERT: BE VERY CAREFUL about touching the buttons on the black slide-adjust nuts If you are loosening or tightening the mapper down to anything, when the mapper is under tension, touching the button could release tension rapidly, potentially causing a fall , potentially on to a very expensive mm-wave optic, which you do not want. If you are adjusting the mapper spacing and you let them off of the threaded rod, they will disassemble themselves rapidly . You don't want to lose any parts. Bring a USB extension cable to make moving the frame to various mirrors easier. That will extend RS485 connection, allowing you to stand or sit in a more comfortable spot. If you can't have the shutter open to let the optical chain see cold sky, bring a lot of flat Eccosorb panels. Don't bother trying to tape Eccosorb to anything. Tape won't stick. Just pinch it in between the mirror and threaded rod. This also helps keep the threaded rod or raft from marring the mirror surface, which is very important. Keep as much stuff (power/data cables, hands, heads, ladders) as possible out of the path of the beam. K1 Underneath shutter, highest up. Put a step ladder inside the K-mirror frame to make the lift easier. Route Hawkeye cables around back of K1 and down. python main.py ./data/input/geometry/K1.csv ./data/input/profiles/K1_<profile>.csv K2 Should be easy. Remove the anti-head-smasher foam first to get to the bottom clamping surface. python main.py ./data/input/geometry/K2.csv ./data/input/profiles/K2_<profile>.csv K3 Pucker factor 11. Have a friend help you mount the mapper; one person to hold the mapper in place, one to secure the slide-adjust nutes. Gravity is working against you, and you're right above F1, but snug things down good and tight when mounting the mapper and you will be fine. I used a crescent wrench on the black slide-adjust nuts for this one, to get a lot of clamping force. Be careful not to release the slide-adjust nuts when using the wrench. python main.py ./data/input/geometry/K3.csv ./data/input/profiles/K3_<profile>.csv F1 Another easy one. python main.py ./data/input/geometry/F1.csv ./data/input/profiles/F1_<profile>.csv P2 Easy. It's down on the floor near the wall. [photo of mapper mounted on P2] Operation When a surface geometry file has been created and the profile for the given shape to be mapped is generated, we are ready to run the program. There should already be geometry and profile files for each mirror in the data/input directories. Homing Pre-mapping checks Make sure that 24 V is being supplied to all driver boards and that the polarity is correct. Make sure that 6.7V is being supplied to the Hawkeyes. Make sure the power supply output is on. Make sure that the cable is wound onto each spool and that no loops of excess cable are trapped underneath the cable wound onto the spools. Check the excess cable played out in the raft's current position. Some excess is fine as long as it doesn't interfere with the raft's motion. Ensure the Hawkeye source power and data cables lines won't interfere with mapper operation, usually, this means routing the cables somewhat along the gravity vector. Ensure the hotspot conda env is active: conda activate hotspot . Mapping Start the program with python main.py ./data/input/geometry/<geometry.csv> ./data/input/profiles/<profile.csv> Perform a homing calibration: c , RETURN key. The motors will drive to each corner in turn, bumping the hard stop three times in order to measure the encoder position where 0 mm of cable is played out. When complete, it will move to the center of the workspace. Verify that the raft reached its home position in the center of the workspace, and that the other axes achieved tension. If not, GOTO 2. If homing succeeded without incident and cables are not taut, check the measurements of the corner eyelets and the raft dimensions provided in the geometry input .csv file. Perform a mapping sequence: r (for run), RETURN key. The raft will drive to each location and flash the Hawkeyes at each point in the sequence. Observe the mapper, ensuring the Hawkeye signal cable does not interfere with the mapper. You may request a mode change at any time. Mode changes are processed at the end of each move. You may abort the program with Ctrl+C . Upon completing a sequence, it may be repeated by requesting the sequence mode again. You may select a different sequence by pressing s and following the prompts. Reference HTML The html documentation of the source code and Markdown materials is generated by portray . To regenerate the documentation, execute: portray as_html -m hotspot -o docs/html/ --overwrite","title":"Howto"},{"location":"HOWTO/#how-to","text":"This doc contains instructions for various tasks related to setting up and running the hotspot mirror mapper.","title":"How To"},{"location":"HOWTO/#what-is-hotspot","text":"hotspot is a planar cable-driven parallel robot (CDPR), with four stepper motors that move a central raft of hot IR sources by changing the length of cables attached to it. The cables are fixed to an adjustable frame. The frame can clamp to any rectangular surface, but it was designed to clamp to various relay mirrors that couple radiation from the sky to the TIME spectrometer inside the receiver cabin on the ARO 12 meter telescope on Kitt Peak, allowing an electronically controlled, hot, IR-emitting source to be swept across the mirror to observe the detectors' spatial response.","title":"What is hotspot?"},{"location":"HOWTO/#what-is-this-document","text":"This document is a comprehensive how-to on setting up, maintaining, and running the mirror mapper. It contains all the information that would be needed to replace and reconfigure major components of the system, however unlikely that may be. It is organized in order of information flow: from the operator (you!) logging into the control computer, to setting up the software environment, connecting the power and signal cables, assembling the mapper frame, creating input files, mounting it on various mirrors, and operating the mapper.","title":"What is this document?"},{"location":"HOWTO/#using-the-control-computer","text":"The mapper motors are controlled by running the main.py application on a computer with a USB-to-RS485 adapter . The IR sources are controlled via a USB cable connected to a microcontroller. You should check out the hotspot repo if you wish to run the mapper or generate new input files .","title":"Using the control computer"},{"location":"HOWTO/#setting-up-the-environment","text":"To run hotspot , you must satisfy the dependencies. They are enumerated in environment.yml , a human-readable file that can be ingested by the conda Python package manager.","title":"Setting Up the Environment"},{"location":"HOWTO/#is-the-environment-set-up","text":"First, check that the environment setup has not been done before. If conda activate hotspot succeeds, skip to software testing with pytest .","title":"Is the environment set up?"},{"location":"HOWTO/#anaconda","text":"","title":"Anaconda"},{"location":"HOWTO/#is-anaconda-set-up","text":"If the Python environment/package manager Anaconda does not exist on the computer you're running this on, I recommend installing Miniconda according to the instructions . Once that is done, we are ready to set up the hotspot environment. conda environments keep a project's dependencies from polluting your computer's environment and make sure they all play nicely together. conda allows specifying the dependencies needed in a file with a .yml extension. This is done for you. Create the hotspot conda env with conda env create -f environment.yml It should install things like numpy and matplotlib , as well as libraries for the hardware, such as the pyserial library for driving the steppers. There are also packages for documentation. NOTE: packages needed for post-processing of photos to measure mapper performance or for producing predicted beam maps using the code in the verification/ folder are not covered by this .yml . Aside from OpenCV they are just standard scientific Python packages, so the requirements should be easy to meet if this code is needed.","title":"Is Anaconda set up?"},{"location":"HOWTO/#keeping-things-up-to-date","text":"If you need to install something new later on with conda install or pip , remember to update environment.yml by doing conda env export --from-history | tee environment.yml If your environment.yml has been updated, and you need to update your env with the new environment.yml , do conda env update --file environment.yml --prune","title":"Keeping things up to date"},{"location":"HOWTO/#software-testing-with-pytest","text":"In order to verify that basic low-level functionality is unbroken, run pytest from the toplevel directory of the repo.","title":"Software Testing with pytest"},{"location":"HOWTO/#power","text":"","title":"Power"},{"location":"HOWTO/#motors","text":"","title":"Motors"},{"location":"HOWTO/#do-the-motor-driver-boards-have-power","text":"Each motor is controlled by an AllMotion EZStepper EZHR17EN . These are chopper driver boards that accept 10-40 V input. Configure a constant-voltage DC power supply to provide: 24 V 4 A The EZStepper drivers are configured in software to draw 50% of the rated 2 A current = 1 A each, for a total of 4 A. In use, the motors may draw somewhat less current. Note: See the AllMotion/American Control Electronics wiring diagram to identify the Vin and GND inputs.","title":"Do the motor driver boards have power?"},{"location":"HOWTO/#hawkeyes","text":"","title":"Hawkeyes"},{"location":"HOWTO/#do-the-hawkeyes-have-power","text":"The Hawkeyes are mounted on a PCB and powered by a power supply connected to the screw terminal. Positive and ground terminals are labeled on the PCB silkscreen (white text). Requirements: 6.7 V (constant voltage) \u2265 2 A The Hawkeye IR-50 source temperature depends on the voltage applied, and the current draw depends on the voltage (see datasheet in pdf dir). The design target temperature is 750 C, requiring a voltage of 6.7V and a current of ~134mA per source, for a total current draw of ~1.74A when all sources are turned on. In practice, Hawkeye sources have not drawn quite this much current. There will be some voltage drop at the screw terminal; this is normal. If one source is powered, the voltage drop is negligible, but if all 13 sources are powered, the voltage drop is approximately .22 V. Do not attempt to compensate for this at the power supply! If you turn up the supply voltage to 6.9 V to get 6.7 V under a 13 source load, a load of a single source will see 6.9 V, drastically reducing its lifetime.","title":"Do the Hawkeyes have power?"},{"location":"HOWTO/#hawkeye-microcontroller","text":"The Hawkeye sources are turned on and off by an Adafruit Trinket M0 microcontroller. It gets 5V power via a micro USB cable.","title":"Hawkeye Microcontroller"},{"location":"HOWTO/#does-the-microcontroller-have-power","text":"The Trinket M0's power LED will illuminate when it is connected to the USB port. The Trinket GND pin should be connected to the Hawkeye power supply's ground terminal.","title":"Does the microcontroller have power?"},{"location":"HOWTO/#frame","text":"","title":"Frame"},{"location":"HOWTO/#is-the-frame-fully-assembled","text":"The 3D printed stepper motor mounts are attached to the beam mapper frame by 5/16-18 x 2\" or 2.25\" bolts with nyloc \"jam\" nuts. Two aluminum registration tabs are screwed into the end of each frame piece opposite the black plastic end caps, using a 5/16-18 x 1/4\" screw. They are long enough to reach an edge of the mirror regardless of if the mirror's corners have been machined off. NOTE: These tabs register the frame to a third edge of the mirror, so it is important that they not be bent . Long 5/16-18 steel threaded rods connect the two halves of the frame. On one end of the threaded rods, threads in the aluminum extrusion provide clamping force. On the other end of the threaded rod, a slide-adjust nut with a thumb button allows easily changing the distance between clamping surfaces, and applies clamping force to the outside of the opposite aluminum extrusion. Care should be exercised with this slide-adjust nut, as pressing the button will release any tension on the threaded rod.","title":"Is the frame fully assembled?"},{"location":"HOWTO/#serial-communications","text":"We will be talking to devices over serial.","title":"Serial Communications"},{"location":"HOWTO/#windows","text":"Windows users may need to open hotspot/constants.py and edit the COM values to match the COM ports assigned to the Hawkeye microcontroller and USB-to-RS485 converter by the OS.","title":"Windows"},{"location":"HOWTO/#ubuntu","text":"On Ubuntu, our user must be a part of a special group to talk to devices over serial. To see the groups your user is a part of, type groups in a command prompt. Add yourself to the tty and dialout groups, then log out and back in to have the changes take effect: sudo usermod -a -G tty $USER sudo usermod -a -G dialout $USER","title":"Ubuntu"},{"location":"HOWTO/#motion-outputs","text":"","title":"Motion Outputs"},{"location":"HOWTO/#motors_1","text":"","title":"Motors"},{"location":"HOWTO/#can-the-computer-talk-to-the-motor-drivers","text":"The EZHR17EN stepper drivers receive commands from a control computer running the hotspot software as bytes over the RS485 physical layer. Note: Refer to the AllMotion/American Control Electronics EZHR17EN wiring diagram to verify that the RS485 communications connection is correct. The control computer needs either a 9-pin serial output port, or a USB-to-RS485 adapter to send bytes out over the RS485 bus. The inverting/non-inverting outputs are blue and yellow wires. If you are connecting your adapter to the bus for the first time, you may have to guess incorrectly and swap the wires before it will work. The motor drivers must have power and ground (via the 24 VDC power supply) to receive commands. NOTE: RS-485 Connections ought to have a ground wire, although you don't see one pictured here. This is to ensure the differential signal at each receiver is biased correctly. If you experience communication issues on the RS-485 bus, ensure proper grounding.","title":"Can the computer talk to the motor drivers?"},{"location":"HOWTO/#can-the-motor-drivers-command-the-motors","text":"Note: Refer to the AllMotion/American Control Electronics EZHR17EN wiring diagram to verify that the motor winding connections are correct. The stepper motors themselves have NEMA-17 spec hole patterns, which mate to the 3D printed motor mount brackets which are attached to the beam mapper frame. Each stepper motor should be attached to its motor mount using M3 x 0.5 x 10 mm screws. If attaching motors for the first time, use lubricant, because metal on plastic will be squeaky. At this point, it is important to consider the mapping of motor driver board address -> stepper motor -> motor mount -> corner of beam mapper frame -> corner of raft. The Executive.__init__() function in executive.py specifies this mapping, so the motor installation location and stepper instance in __init__() should match, to ensure the correct motor commands are sent to the correct stepper. The stepper driver boards are addressable with a selector switch on top. Match the address selector to the correct corner of the raft in the __init__() function.","title":"Can the motor drivers command the motors?"},{"location":"HOWTO/#can-the-encoders-provide-position-feedback","text":"The EZHR17EN boards are capable of reading out quadrature encoders affixed to the stepper shafts. Encoder feedback is critical for accurate positioning of the raft. Note: Refer to the AllMotion/American Control Electronics EZHR17EN wiring diagram to verify that the encoder connections are correct.","title":"Can the encoders provide position feedback?"},{"location":"HOWTO/#spools","text":"","title":"Spools"},{"location":"HOWTO/#can-the-motors-make-the-lines-longer-and-shorter","text":"The stepper motors drive winch-like drums directly, to change the length of the cables predictably. They are cylindrical drums with helical threads to accept the cables. If they are not already attached, the cable drums should be fixed to the 5 mm stepper motor shaft via one M3 setscrew. The screws mate to steel threaded inserts that are pressed into the PETG plastic spools. The fishing line is affixed to the each spool by wrapping it around the setscrew and screwing it in to the threaded recess on the spool circumference. NOTE: Positive motor rotation is defined by convention to spin the shaft clockwise when viewed from the rear of the motor. Cables should be oriented relative to the spool such that a positive motor rotation produces a positive cable length change (i.e., cable is played out from the spool), and a negative motor rotation winds cable onto the spool. Since helical threads change the position along the drum $y$ that the cable exits as a function of motor position, the actual length of cable change for a given rotation depends on the thread pitch. Also, a controlled spooling mechanism is usually required. In this case, the corresponding eyelet is located some distance from the spool to achieve controlled spooling with less complexity. After attaching the cables to the spools, the other end should be threaded through the ~.9mm hole in the motor mount bracket on the opposite E-W side of the frame. NOTE: All cables should be cut long enough to permit the raft to visit each corner of the frame, even when the frame is as far apart as it can be (~25.5\"). Finally, excess cable should be wound onto the drum by hand, under tension, to ensure the cable is seated in the drum's grooves.","title":"Can the motors make the lines longer and shorter?"},{"location":"HOWTO/#radiation-outputs","text":"","title":"Radiation Outputs"},{"location":"HOWTO/#will-moving-the-cables-move-the-hawkeyes","text":"The end effector of this robot is a rectangular raft carrying several Hawkeye Technologies IR-50 emitters. The robot drives the centroid of the effector to a specified position, and the control algorithm performs a sequence of flashes using a number of the emitters to enhance the detectability of the signal in the IR receiver output data. Pass the cables that emerge from the corner eyelets to the closest eyelets on the raft. Wrap the ends of the fishing line around the screws in each corner of the raft, and screw them down.","title":"Will moving the cables move the Hawkeyes?"},{"location":"HOWTO/#can-the-computer-command-the-hawkeyes","text":"The Hawkeye IR sources are arranged in roughly 3 concentric circles. Each circle is a separately controllable group of sources, which can be turned on and off by the control software. The first group is a single center source. The second group is the inner ring of six sources surrounding the center. The third group is the outer ring of six sources. Turning on more sources increases the intensity that the TIME receiver sees; this may be necessary for mapping optics where the beam is less concentrated. Each group is turned on and off by a MOSFET on the raft. The MOSFET gates are controlled by the outputs of a shift register chip. The shift register multiplexes 8 bits (a byte) received at its input to its 8 output pins. Only 3 of the 8 are connected to MOSFETs. The shift register receives a byte from an Adafruit Trinket M0 microcontroller over SPI via the black silicone ribbon cable, which should be hooked up to the grey connector on the raft. The connector pinout is on the back of the PCB. The other end of the cable is soldered to the Trinket M0 pins. The data connection pinout from the Trinket M0 to the ribbon cable connector is as follows: Trinket M0 GND \u2192 GND The shift register GND must be the same as the microcontroller ground. This should be grounded to the Hawkeye power ground as well. Trinket M0 BAT \u2192 5 V 5 V from the USB connector appears here. This powers the shift register. Trinket M0 2 \u2192 LATCH This pin goes low when an SPI transfer is started Trinket M0 4 \u2192 CLK This pin pulses during an SPI transfer to delineate bits to the shift register. Trinket M0 5 \u2192 PICO (peripheral input, controller output) This pin goes low or high during an SPI transfer to send bits to the shift register. The Trinket M0 receives a byte from the control computer over a USB serial connection and forwards it to the shift register over SPI. Profile Input File .csv: flasher_cmds value Trinket M0 SPI Output Bit Representation (Shift Register Outputs) Trinket M0 RGB LED Color Hawkeyes On 0 0 0000000 (Dimmed) None 1 1 0000001 Red Center 2 2 0000010 Green Inner 3 3 0000011 Yellow Center, Inner 4 4 0000100 Blue Outer 5 5 0000101 Purple Center, Outer 6 6 0000110 Cyan Inner, Outer 7 7 0000111 White Center, Inner, Outer The control computer will flash whichever group of Hawkeyes is specified by the input profile .csv file at 5 Hz.","title":"Can the computer command the Hawkeyes?"},{"location":"HOWTO/#cable-maintenance","text":"","title":"Cable Maintenance"},{"location":"HOWTO/#what-if-a-cable-breaks","text":"The original cable is Spiderwire EZ Braid braided dyneema fishing line (50 lb pull strength), chosen for its stretch resistance. A replacement can be found at any tackle store or Wal-Mart, but a spool of extra cable should already be stored with the beam mapper. Cable length should be carefully sized to allow the raft to reach all corners of the workspace, but with as little extra length as possible at the maximum allowed separation of 25.5\".","title":"What if a cable breaks?"},{"location":"HOWTO/#coordinate-system","text":"In order for the raft to be moved to a meaningful position in mirror-space, coordinates must be referenced to sensible locations where the mirror edges and robot frame register to one another. x-axis : plane of contact between the \"south\" frame and an edge of the mirror y-axis : plane of contact between the \"west\" side aluminum registration tab and a perpendicular mirror edge. The coordinate system of the robot therefore has its origin at the SW corner, where the aluminum alignment tab on the fixed frame meets the aluminum extrusion face.","title":"Coordinate System"},{"location":"HOWTO/#input-files","text":"There are two types of input files: geometry and profile . Read on to learn what they are for and what is inside each.","title":"Input Files"},{"location":"HOWTO/#ok-but-is-there-an-easy-way-to-make-a-new-one","text":".ipynb files are provided in the data/input/* directories to assist with making these input files. Most likely, you will only need data/input/create_profile.ipynb . You will need Jupyter installed on the computer running this notebook. Then simply copy the new files to the /data/input/* directory.","title":"Ok, but is there an easy way to make a new one?"},{"location":"HOWTO/#geometry","text":"Geometry files are one-line .csv files in data/input/geometry . create_geometry.ipynb is provided to script the creation of geometry files. Each one defines the physical setup of the robot when it is in a certain configuration, for instance, when it is installed on a mirror of a certain dimension. Each column entry describes an aspect of the physical setup of the system. A simplistic example: sw_0 sw_1 nw_0 nw_1 se_0 se_1 ne_0 ne_1 w h 0 0 0 1 1 0 1 1 .1 .1 Each corner point is the location of an eyelet through which the cable passes, expressed relative to the SW origin, described above. The width and height of the raft are defined by the separations between eyelets on the raft through which the cable passes. NOTE: If the dimensions of the frame eyelets have been measured relative to each edge, the y-positions of the corner eyelets can be calculated as a function of the separation between the aluminum extrusions that make up the support structure and clamping surfaces. The eyelets of the motor mounts measured 6.19 +/- 0.5 mm from the frame to the face of the motor mount bracket on the interior of the mapping region, and 7.96 +/- 0.02 mm from the face of the motor mount to the eyelet, for a total eyelet offset from the contact patch of 0.014 +/- 0.001 m. This value will be used to calculate eyelet y-positions as a function of frame separation. The eyelet positions should not ever change in the x-direction, unless the motor mounts are removed from the aluminum frames.","title":"Geometry"},{"location":"HOWTO/#profile","text":"Profile files are multi-line .csv files in data/input/profiles . Each line defines a new position to which the robot should move, in the coordinate system defined above, and which group of Hawkeye sources should be flashed. profiles/create_profile.ipynb is provided to script the creation of profiles. Upon reaching each location in the profile, the robot is programmed to flash Hawkeye sources on and off (default: 10 \"on\" states, 50% duty cycle, 5 Hz). Which group of sources is enabled is configurable with the flasher_cmds column in the profile .csv. See the table in the previous section. Some examples follow. For example, to move to a single coordinate and flash all three groups of Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 7 .5 .5 to move to a single coordinate and flash only the center Hawkeye: flasher_cmds pos_cmd_0s pos_cmd_1s 1 .5 .5 to move to a single coordinate and flash the center and inner ring Hawkeyes: flasher_cmds pos_cmd_0s pos_cmd_1s 2 .5 .5 Building up a sequence of these moves allows a shape to be scanned.","title":"Profile"},{"location":"HOWTO/#output-files","text":"Output files store telemetry for each run in data/output . They are timestamped .hdf5 files.","title":"Output Files"},{"location":"HOWTO/#physical-installation","text":"","title":"Physical Installation"},{"location":"HOWTO/#general-tips","text":"Having two people helps. SAFETY ALERT: BE VERY CAREFUL about touching the buttons on the black slide-adjust nuts If you are loosening or tightening the mapper down to anything, when the mapper is under tension, touching the button could release tension rapidly, potentially causing a fall , potentially on to a very expensive mm-wave optic, which you do not want. If you are adjusting the mapper spacing and you let them off of the threaded rod, they will disassemble themselves rapidly . You don't want to lose any parts. Bring a USB extension cable to make moving the frame to various mirrors easier. That will extend RS485 connection, allowing you to stand or sit in a more comfortable spot. If you can't have the shutter open to let the optical chain see cold sky, bring a lot of flat Eccosorb panels. Don't bother trying to tape Eccosorb to anything. Tape won't stick. Just pinch it in between the mirror and threaded rod. This also helps keep the threaded rod or raft from marring the mirror surface, which is very important. Keep as much stuff (power/data cables, hands, heads, ladders) as possible out of the path of the beam.","title":"General tips"},{"location":"HOWTO/#k1","text":"Underneath shutter, highest up. Put a step ladder inside the K-mirror frame to make the lift easier. Route Hawkeye cables around back of K1 and down. python main.py ./data/input/geometry/K1.csv ./data/input/profiles/K1_<profile>.csv","title":"K1"},{"location":"HOWTO/#k2","text":"Should be easy. Remove the anti-head-smasher foam first to get to the bottom clamping surface. python main.py ./data/input/geometry/K2.csv ./data/input/profiles/K2_<profile>.csv","title":"K2"},{"location":"HOWTO/#k3","text":"Pucker factor 11. Have a friend help you mount the mapper; one person to hold the mapper in place, one to secure the slide-adjust nutes. Gravity is working against you, and you're right above F1, but snug things down good and tight when mounting the mapper and you will be fine. I used a crescent wrench on the black slide-adjust nuts for this one, to get a lot of clamping force. Be careful not to release the slide-adjust nuts when using the wrench. python main.py ./data/input/geometry/K3.csv ./data/input/profiles/K3_<profile>.csv","title":"K3"},{"location":"HOWTO/#f1","text":"Another easy one. python main.py ./data/input/geometry/F1.csv ./data/input/profiles/F1_<profile>.csv","title":"F1"},{"location":"HOWTO/#p2","text":"Easy. It's down on the floor near the wall. [photo of mapper mounted on P2]","title":"P2"},{"location":"HOWTO/#operation","text":"When a surface geometry file has been created and the profile for the given shape to be mapped is generated, we are ready to run the program. There should already be geometry and profile files for each mirror in the data/input directories.","title":"Operation"},{"location":"HOWTO/#homing","text":"","title":"Homing"},{"location":"HOWTO/#pre-mapping-checks","text":"Make sure that 24 V is being supplied to all driver boards and that the polarity is correct. Make sure that 6.7V is being supplied to the Hawkeyes. Make sure the power supply output is on. Make sure that the cable is wound onto each spool and that no loops of excess cable are trapped underneath the cable wound onto the spools. Check the excess cable played out in the raft's current position. Some excess is fine as long as it doesn't interfere with the raft's motion. Ensure the Hawkeye source power and data cables lines won't interfere with mapper operation, usually, this means routing the cables somewhat along the gravity vector. Ensure the hotspot conda env is active: conda activate hotspot .","title":"Pre-mapping checks"},{"location":"HOWTO/#mapping","text":"Start the program with python main.py ./data/input/geometry/<geometry.csv> ./data/input/profiles/<profile.csv> Perform a homing calibration: c , RETURN key. The motors will drive to each corner in turn, bumping the hard stop three times in order to measure the encoder position where 0 mm of cable is played out. When complete, it will move to the center of the workspace. Verify that the raft reached its home position in the center of the workspace, and that the other axes achieved tension. If not, GOTO 2. If homing succeeded without incident and cables are not taut, check the measurements of the corner eyelets and the raft dimensions provided in the geometry input .csv file. Perform a mapping sequence: r (for run), RETURN key. The raft will drive to each location and flash the Hawkeyes at each point in the sequence. Observe the mapper, ensuring the Hawkeye signal cable does not interfere with the mapper. You may request a mode change at any time. Mode changes are processed at the end of each move. You may abort the program with Ctrl+C . Upon completing a sequence, it may be repeated by requesting the sequence mode again. You may select a different sequence by pressing s and following the prompts.","title":"Mapping"},{"location":"HOWTO/#reference-html","text":"The html documentation of the source code and Markdown materials is generated by portray . To regenerate the documentation, execute: portray as_html -m hotspot -o docs/html/ --overwrite","title":"Reference HTML"},{"location":"reference/hotspot/","text":"Module hotspot Sub-modules hotspot.algorithm hotspot.constants hotspot.executive hotspot.hardware hotspot.hw_context hotspot.telemetry","title":"Index"},{"location":"reference/hotspot/#module-hotspot","text":"","title":"Module hotspot"},{"location":"reference/hotspot/#sub-modules","text":"hotspot.algorithm hotspot.constants hotspot.executive hotspot.hardware hotspot.hw_context hotspot.telemetry","title":"Sub-modules"},{"location":"reference/hotspot/algorithm/","text":"Module hotspot.algorithm View Source # This file houses the algorithms necessary for calculating the control # quantities. # MKS units only. import logging import multiprocessing as mp import numpy as np import sys import time import hotspot.constants as const logger = logging . getLogger ( __name__ ) # logger.setLevel(getattr(logging, const.LOGLEVEL)) class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )): logger . debug ( 'TestSurface init' ) corner_list = [ nw , ne , se , sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { inp } .' assert len ({ elem for elem in corner_list }) == len ( corner_list ), f 'Vertices should be unique: { corner_list } ' # Corner points are expressed as x,y offsets in mirror coordinate frame self . corners = np . array ([[ sw , nw ], [ se , ne ]]) self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] return def is_inbounds ( self , pos : tuple ): ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [ self . sw , self . nw , self . ne , self . se , self . sw ] reason = None for i in range ( len ( vertex_seq ) - 1 ): disp0 = vertex_seq [ i ] - pos disp1 = vertex_seq [ i + 1 ] - pos mag0 = np . linalg . norm ( disp0 ) mag1 = np . linalg . norm ( disp1 ) # is pos too close to a vertex (protect against divide by 0) if ( mag0 < eps or mag1 < eps ): result = False reason = 'Too close to corner' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np . arccos ( np . dot ( v0_hat , v1_hat )) # is pos too close to an edge if np . abs ( ang - np . pi ) < eps : result = False reason = 'Too close to edge' break ang_tot_rad += ang # is pos inside shape if np . abs ( ang_tot_rad - 2. * np . pi ) > eps : result = False reason = f 'Outside shape: { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason : logger . warning ( f 'Bounds check failed: { reason } ' ) return result class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { position } .' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] return @property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos return class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue return @property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location { home_pos } is outside of bounds for surface with corners { self . surf . corners } ' ) @property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command { new_pos } is outside of bounds for surface with corners { self . surf . corners } ' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # update the commanded position logger . debug ( f 'Commanded position: { pos_cmd } ' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move: { lengths_after } ' ) # Cable is wound onto a helical drum, so the length change goes like: # sqrt(helix channel gullet diameter^2 + helix channel pitch^2) # or in machinist's thread-speak: # sqrt(minor diameter^2 + thread pitch^2) # for a single rotation. # The implicit assumption here is one of \"conservation of string,\" and # also of an eyelet distant from the helical drum, invoking the small # angle approximation. num_revs = lengths_after / const . LENGTH_PER_REV angles = 2. * np . pi * num_revs motor_cmds [ 'sw' ] = angles [ 0 , 0 ] motor_cmds [ 'se' ] = angles [ 1 , 0 ] motor_cmds [ 'nw' ] = angles [ 0 , 1 ] motor_cmds [ 'ne' ] = angles [ 1 , 1 ] logger . debug ( f 'Motor commands: { motor_cmds } ' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Angle Command (rad)' : angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds Variables logger Classes Raft class Raft ( position : tuple , width : float , height : float ) Contains the payload-dependent geometry of attachment points, as-constructed/measured. View Source class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {position}.' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] return @ property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @ position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos return Instance variables position Accessor for raft origin position in mirror coordinate frame Robot class Robot ( surf : hotspot . algorithm . TestSurface , raft : hotspot . algorithm . Raft , tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f0182295c90 >> ) Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. View Source class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue return @ property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @ home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location {home_pos} is outside of bounds for surface with corners {self.surf.corners}' ) @ property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @ pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command {new_pos} is outside of bounds for surface with corners {self.surf.corners}' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) # Cable is wound onto a helical drum, so the length change goes like: # sqrt(helix channel gullet diameter^2 + helix channel pitch^2) # or in machinist's thread-speak: # sqrt(minor diameter^2 + thread pitch^2) # for a single rotation. # The implicit assumption here is one of \"conservation of string,\" and # also of an eyelet distant from the helical drum, invoking the small # angle approximation. num_revs = lengths_after / const . LENGTH_PER_REV angles = 2. * np . pi * num_revs motor_cmds [ 'sw' ] = angles [ 0 , 0 ] motor_cmds [ 'se' ] = angles [ 1 , 0 ] motor_cmds [ 'nw' ] = angles [ 0 , 1 ] motor_cmds [ 'ne' ] = angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds}' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Angle Command (rad)' : angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds Instance variables home The location in mirror coordinate frame the robot will guide to when commanded home pos_cmd The location in mirror coordinate frame the robot will guide to for the next move Methods process_input def process_input ( self , pos_cmd : tuple ) Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters: Name Type Description Default pos_cmd None the position command in the frame of the surface None Returns: Type Description dict of tuples dict containing motor commands in radians. View Source def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) # Cable is wound onto a helical drum, so the length change goes like: # sqrt(helix channel gullet diameter^2 + helix channel pitch^2) # or in machinist's thread-speak: # sqrt(minor diameter^2 + thread pitch^2) # for a single rotation. # The implicit assumption here is one of \"conservation of string,\" and # also of an eyelet distant from the helical drum, invoking the small # angle approximation. num_revs = lengths_after / const . LENGTH_PER_REV angles = 2. * np . pi * num_revs motor_cmds [ 'sw' ] = angles [ 0 , 0 ] motor_cmds [ 'se' ] = angles [ 1 , 0 ] motor_cmds [ 'nw' ] = angles [ 0 , 1 ] motor_cmds [ 'ne' ] = angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds}' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Angle Command (rad)' : angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds TestSurface class TestSurface ( sw = ( 0.0 , 0.0 ), se = ( 1.0 , 0.0 ), nw = ( 0.0 , 1.0 ), ne = ( 1.0 , 1.0 ) ) Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. View Source class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )) : logger . debug ( 'TestSurface init' ) corner_list = [ nw, ne, se, sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {inp}.' assert len ( { elem for elem in corner_list } ) == len ( corner_list ), f 'Vertices should be unique: {corner_list}' # Corner points are expressed as x , y offsets in mirror coordinate frame self . corners = np . array ( [ [sw, nw ] , [ se, ne ] ] ) self . sw = self . corners [ 0,0 ] self . se = self . corners [ 1,0 ] self . nw = self . corners [ 0,1 ] self . ne = self . corners [ 1,1 ] return def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.warning(f' Bounds check failed : { reason }' ) return result Methods is_inbounds def is_inbounds ( self , pos : tuple ) Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. View Source def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.warning(f' Bounds check failed : { reason }' ) return result","title":"Algorithm"},{"location":"reference/hotspot/algorithm/#module-hotspotalgorithm","text":"View Source # This file houses the algorithms necessary for calculating the control # quantities. # MKS units only. import logging import multiprocessing as mp import numpy as np import sys import time import hotspot.constants as const logger = logging . getLogger ( __name__ ) # logger.setLevel(getattr(logging, const.LOGLEVEL)) class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )): logger . debug ( 'TestSurface init' ) corner_list = [ nw , ne , se , sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { inp } .' assert len ({ elem for elem in corner_list }) == len ( corner_list ), f 'Vertices should be unique: { corner_list } ' # Corner points are expressed as x,y offsets in mirror coordinate frame self . corners = np . array ([[ sw , nw ], [ se , ne ]]) self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] return def is_inbounds ( self , pos : tuple ): ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [ self . sw , self . nw , self . ne , self . se , self . sw ] reason = None for i in range ( len ( vertex_seq ) - 1 ): disp0 = vertex_seq [ i ] - pos disp1 = vertex_seq [ i + 1 ] - pos mag0 = np . linalg . norm ( disp0 ) mag1 = np . linalg . norm ( disp1 ) # is pos too close to a vertex (protect against divide by 0) if ( mag0 < eps or mag1 < eps ): result = False reason = 'Too close to corner' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np . arccos ( np . dot ( v0_hat , v1_hat )) # is pos too close to an edge if np . abs ( ang - np . pi ) < eps : result = False reason = 'Too close to edge' break ang_tot_rad += ang # is pos inside shape if np . abs ( ang_tot_rad - 2. * np . pi ) > eps : result = False reason = f 'Outside shape: { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason : logger . warning ( f 'Bounds check failed: { reason } ' ) return result class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of { position } .' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] return @property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos return class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue return @property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location { home_pos } is outside of bounds for surface with corners { self . surf . corners } ' ) @property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command { new_pos } is outside of bounds for surface with corners { self . surf . corners } ' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # update the commanded position logger . debug ( f 'Commanded position: { pos_cmd } ' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move: { lengths_after } ' ) # Cable is wound onto a helical drum, so the length change goes like: # sqrt(helix channel gullet diameter^2 + helix channel pitch^2) # or in machinist's thread-speak: # sqrt(minor diameter^2 + thread pitch^2) # for a single rotation. # The implicit assumption here is one of \"conservation of string,\" and # also of an eyelet distant from the helical drum, invoking the small # angle approximation. num_revs = lengths_after / const . LENGTH_PER_REV angles = 2. * np . pi * num_revs motor_cmds [ 'sw' ] = angles [ 0 , 0 ] motor_cmds [ 'se' ] = angles [ 1 , 0 ] motor_cmds [ 'nw' ] = angles [ 0 , 1 ] motor_cmds [ 'ne' ] = angles [ 1 , 1 ] logger . debug ( f 'Motor commands: { motor_cmds } ' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Angle Command (rad)' : angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"Module hotspot.algorithm"},{"location":"reference/hotspot/algorithm/#variables","text":"logger","title":"Variables"},{"location":"reference/hotspot/algorithm/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/algorithm/#raft","text":"class Raft ( position : tuple , width : float , height : float ) Contains the payload-dependent geometry of attachment points, as-constructed/measured. View Source class Raft : ''' Contains the payload-dependent geometry of attachment points, as-constructed/measured. ''' def __init__ ( self , position : tuple , width : float , height : float ): logger . debug ( 'Raft init' ) assert len ( position ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {position}.' # Private attribute maintains coords in raft frame # origin implicit at centroid of rectangle self . _corners_priv = np . array ( [[( - width / 2. , - height / 2. ), ( - width / 2. , height / 2. )], [( width / 2. , - height / 2. ), ( width / 2. , height / 2. )]] ) # Public attribute maintains coords in mirror frame self . corners = self . _corners_priv + position # position of the raft origin in mirror coordinate frame self . _position = position self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] return @ property def position ( self ): '''Accessor for raft origin position in mirror coordinate frame''' return self . _position @ position . setter def position ( self , new_pos ): ''' Setter for raft origin position ensures the raft corners follow when position is updated ''' self . corners = self . _corners_priv + new_pos self . sw = self . corners [ 0 , 0 ] self . se = self . corners [ 1 , 0 ] self . nw = self . corners [ 0 , 1 ] self . ne = self . corners [ 1 , 1 ] self . _position = new_pos return","title":"Raft"},{"location":"reference/hotspot/algorithm/#instance-variables","text":"position Accessor for raft origin position in mirror coordinate frame","title":"Instance variables"},{"location":"reference/hotspot/algorithm/#robot","text":"class Robot ( surf : hotspot . algorithm . TestSurface , raft : hotspot . algorithm . Raft , tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f0182295c90 >> ) Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. View Source class Robot : ''' Contains all information and functions needed to translate a sequence of commands into a set of cable length deltas and velocities, and then into a set of motor commands. ''' def __init__ ( self , surf : TestSurface , raft : Raft , tm_queue : mp . Queue ): logger . debug ( 'Robot init' ) # Geometry self . surf = surf self . raft = raft # Init home to an invalid position until we are homed self . _home = ( - np . inf , - np . inf ) # Start off pos_cmd in an error state, hoping an error will occur # If we attempt to move before issuing a real pos_cmd self . _pos_cmd = self . _home # A handle to the queue for outputting TM packets for vis and logging self . tm_queue = tm_queue return @ property def home ( self ): ''' The location in mirror coordinate frame the robot will guide to when commanded home ''' return self . _home @ home . setter def home ( self , home_pos ): inbounds = self . surf . is_inbounds ( home_pos ) if inbounds : self . _home = home_pos else : raise ValueError ( f 'Home location {home_pos} is outside of bounds for surface with corners {self.surf.corners}' ) @ property def pos_cmd ( self ): ''' The location in mirror coordinate frame the robot will guide to for the next move ''' return self . _pos_cmd @ pos_cmd . setter def pos_cmd ( self , new_pos ): inbounds = self . surf . is_inbounds ( new_pos ) if inbounds : self . _pos_cmd = new_pos else : raise ValueError ( f 'Position command {new_pos} is outside of bounds for surface with corners {self.surf.corners}' ) def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) # Cable is wound onto a helical drum, so the length change goes like: # sqrt(helix channel gullet diameter^2 + helix channel pitch^2) # or in machinist's thread-speak: # sqrt(minor diameter^2 + thread pitch^2) # for a single rotation. # The implicit assumption here is one of \"conservation of string,\" and # also of an eyelet distant from the helical drum, invoking the small # angle approximation. num_revs = lengths_after / const . LENGTH_PER_REV angles = 2. * np . pi * num_revs motor_cmds [ 'sw' ] = angles [ 0 , 0 ] motor_cmds [ 'se' ] = angles [ 1 , 0 ] motor_cmds [ 'nw' ] = angles [ 0 , 1 ] motor_cmds [ 'ne' ] = angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds}' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Angle Command (rad)' : angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"Robot"},{"location":"reference/hotspot/algorithm/#instance-variables_1","text":"home The location in mirror coordinate frame the robot will guide to when commanded home pos_cmd The location in mirror coordinate frame the robot will guide to for the next move","title":"Instance variables"},{"location":"reference/hotspot/algorithm/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/algorithm/#process_input","text":"def process_input ( self , pos_cmd : tuple ) Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters: Name Type Description Default pos_cmd None the position command in the frame of the surface None Returns: Type Description dict of tuples dict containing motor commands in radians. View Source def process_input ( self , pos_cmd : tuple ): ''' Translate a move command into 4 motor commands. Motors should be attached to cables such that increasing the length of the cable played out requires a positive-valued rotation (motor shaft spins clockwise) from rear. Parameters ---------- pos_cmd the position command in the frame of the surface Returns ------- motor_cmds : dict of tuples dict containing motor commands in radians. ''' motor_cmds = { 'sw' : 0. , 'nw' : 0. , 'ne' : 0. , 'se' : 0. } # update the commanded position logger . debug ( f 'Commanded position: {pos_cmd}' ) self . pos_cmd = pos_cmd # update the raft's position to move its corners self . raft . position = pos_cmd lengths_after = np . linalg . norm ( self . raft . corners - self . surf . corners , axis =- 1 ) logger . debug ( f 'Lengths after move:{lengths_after}' ) # Cable is wound onto a helical drum, so the length change goes like: # sqrt(helix channel gullet diameter^2 + helix channel pitch^2) # or in machinist's thread-speak: # sqrt(minor diameter^2 + thread pitch^2) # for a single rotation. # The implicit assumption here is one of \"conservation of string,\" and # also of an eyelet distant from the helical drum, invoking the small # angle approximation. num_revs = lengths_after / const . LENGTH_PER_REV angles = 2. * np . pi * num_revs motor_cmds [ 'sw' ] = angles [ 0 , 0 ] motor_cmds [ 'se' ] = angles [ 1 , 0 ] motor_cmds [ 'nw' ] = angles [ 0 , 1 ] motor_cmds [ 'ne' ] = angles [ 1 , 1 ] logger . debug ( f 'Motor commands: {motor_cmds}' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : pos_cmd , 'Motor Angle Command (rad)' : angles . flatten (), } } self . tm_queue . put ( packet ) return motor_cmds","title":"process_input"},{"location":"reference/hotspot/algorithm/#testsurface","text":"class TestSurface ( sw = ( 0.0 , 0.0 ), se = ( 1.0 , 0.0 ), nw = ( 0.0 , 1.0 ), ne = ( 1.0 , 1.0 ) ) Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. View Source class TestSurface : ''' Contains the mirror-dependent geometry of attachment points, as-constructed/measured, relative to the mirror origin. ''' def __init__ ( self , sw = ( 0. , 0. ), se = ( 1. , 0. ), nw = ( 0. , 1. ), ne = ( 1. , 1. )) : logger . debug ( 'TestSurface init' ) corner_list = [ nw, ne, se, sw ] for inp in corner_list : assert len ( inp ) == 2 , \\ f 'This module is 2D planar only, so points should be 2-vectors instead of {inp}.' assert len ( { elem for elem in corner_list } ) == len ( corner_list ), f 'Vertices should be unique: {corner_list}' # Corner points are expressed as x , y offsets in mirror coordinate frame self . corners = np . array ( [ [sw, nw ] , [ se, ne ] ] ) self . sw = self . corners [ 0,0 ] self . se = self . corners [ 1,0 ] self . nw = self . corners [ 0,1 ] self . ne = self . corners [ 1,1 ] return def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.warning(f' Bounds check failed : { reason }' ) return result","title":"TestSurface"},{"location":"reference/hotspot/algorithm/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/algorithm/#is_inbounds","text":"def is_inbounds ( self , pos : tuple ) Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you're inside the shape. View Source def is_inbounds ( self , pos : tuple ) : ''' Interior/exterior test: sum angles between pos and successive pairs of vertices. If they sum to 360, you' re inside the shape . ''' # ECM: Might be able to exploit matrix math to make faster # e.g. make two arrays of vertices and vectorize the for loop eps = 1e-9 result = True ang_tot_rad = 0. vertex_seq = [self.sw, self.nw, self.ne, self.se, self.sw] reason = None for i in range(len(vertex_seq) - 1): disp0 = vertex_seq[i] - pos disp1 = vertex_seq[i+1] - pos mag0 = np.linalg.norm(disp0) mag1 = np.linalg.norm(disp1) # is pos too close to a vertex (protect against divide by 0) if (mag0 < eps or mag1 < eps): result = False reason = ' Too close to corner ' break v0_hat = disp0 / mag0 v1_hat = disp1 / mag1 ang = np.arccos(np.dot(v0_hat, v1_hat)) # is pos too close to an edge if np.abs(ang - np.pi) < eps: result = False reason = ' Too close to edge ' break ang_tot_rad += ang # is pos inside shape if np.abs(ang_tot_rad - 2. * np.pi) > eps: result = False reason = f' Outside shape : { np . abs ( ang_tot_rad - 2. * np . pi ) } ' if reason: logger.warning(f' Bounds check failed : { reason }' ) return result","title":"is_inbounds"},{"location":"reference/hotspot/constants/","text":"Module hotspot.constants View Source # Numbers that don't change from mirror to mirror # MKS units throughout if not specified. import numpy as np import os import sys # ----------------------------------------------------------------------------- # Stepper drivers # ----------------------------------------------------------------------------- # EZStepper microstepping multiplier. Divides each single step by the modifier: # E.g. a value of 8 splits one 1.8 deg step into eight .225 deg steps. # Default value is 256, and it is discouraged to change it. If you do, you must # send a command to each EZStepper to match your decision here. MICROSTEP_NUM = 256 ENCODER_TICKS_PER_REV = 40000 # Used for converting rotational changes into stepper commands DEG_PER_STEP = 360. / 200. / MICROSTEP_NUM DEG_PER_RAD = 180. / np . pi STEP_PER_TICK = 200. * MICROSTEP_NUM / ENCODER_TICKS_PER_REV # encoder ticks / sec, experimentally determined. EZStepper driver takes 10-40V # more PSU volts = faster current rise time = faster max speed. MAX_SPEED_TICKS = 25000 MAX_ACCEL_TICKS = 400 # Default for EZSteppers and hawkeye driver peripheral SERIAL_BAUD = 9600 # BIG MODE SERIAL_BAUD_FAST = 115200 # if you get garbage replies from stepper drivers, increase this timeout. SERIAL_TIMEOUT = 0.1 # time before performing any actions at each position reached SETTLE_TIME = 1e-3 # for long moves, approximate the intermediate path by moves of this maximum length, m CHUNK_DIST = 0.005 # stepper move current = 2.0 A * (this / 100) MOVE_CURRENT_PCT = 50 HOLD_CURRENT_PCT = 50 # ----------------------------------------------------------------------------- # Physical constants # ----------------------------------------------------------------------------- # Used for converting linear distances into rotational ones. # This is the measured value of the helical drum minor diameter. PULLEY_RADIUS = .03014 / 2. # The helical drum means the length unspooled per radian is longer. # 1.5 mm pitch DRUM_PITCH = 1.5 / 1000. LENGTH_PER_REV = np . sqrt ( DRUM_PITCH ** 2. + ( np . pi * 2. * PULLEY_RADIUS ) ** 2. ) # delta x distance from the NW eyelet to the raft centroid, when it is driven # to the NW limit and the raft isn't cockeyed HOMING_OFFSET_X = 0.0276 # same, but for y HOMING_OFFSET_Y = - 0.0252 # ----------------------------------------------------------------------------- # Software constants # ----------------------------------------------------------------------------- # Limits the total number of commands that may be in the command queue at once. # Pretty much only limited by memory. MAX_QLEN = 2 ** 16 # Change these accordingly to point to the serial ports of the microcontroller # for the Hawkeyes and and serial-RS485 converter for the steppers. if sys . platform . startswith ( 'win' ): HAWKEYE_SERIAL_PORT = 'COM8' STEPPER_SERIAL_PORT = 'COM9' else : HAWKEYE_SERIAL_PORT = '/dev/ttyACM0' STEPPER_SERIAL_PORT = '/dev/ttyUSB0' # Helps with file input/outputs TOPLEVEL_DIR = os . path . abspath ( os . path . join ( __file__ , '..' , '..' )) Variables CHUNK_DIST DEG_PER_RAD DEG_PER_STEP DRUM_PITCH ENCODER_TICKS_PER_REV HAWKEYE_SERIAL_PORT HOLD_CURRENT_PCT HOMING_OFFSET_X HOMING_OFFSET_Y LENGTH_PER_REV MAX_ACCEL_TICKS MAX_QLEN MAX_SPEED_TICKS MICROSTEP_NUM MOVE_CURRENT_PCT PULLEY_RADIUS SERIAL_BAUD SERIAL_BAUD_FAST SERIAL_TIMEOUT SETTLE_TIME STEPPER_SERIAL_PORT STEP_PER_TICK TOPLEVEL_DIR","title":"Constants"},{"location":"reference/hotspot/constants/#module-hotspotconstants","text":"View Source # Numbers that don't change from mirror to mirror # MKS units throughout if not specified. import numpy as np import os import sys # ----------------------------------------------------------------------------- # Stepper drivers # ----------------------------------------------------------------------------- # EZStepper microstepping multiplier. Divides each single step by the modifier: # E.g. a value of 8 splits one 1.8 deg step into eight .225 deg steps. # Default value is 256, and it is discouraged to change it. If you do, you must # send a command to each EZStepper to match your decision here. MICROSTEP_NUM = 256 ENCODER_TICKS_PER_REV = 40000 # Used for converting rotational changes into stepper commands DEG_PER_STEP = 360. / 200. / MICROSTEP_NUM DEG_PER_RAD = 180. / np . pi STEP_PER_TICK = 200. * MICROSTEP_NUM / ENCODER_TICKS_PER_REV # encoder ticks / sec, experimentally determined. EZStepper driver takes 10-40V # more PSU volts = faster current rise time = faster max speed. MAX_SPEED_TICKS = 25000 MAX_ACCEL_TICKS = 400 # Default for EZSteppers and hawkeye driver peripheral SERIAL_BAUD = 9600 # BIG MODE SERIAL_BAUD_FAST = 115200 # if you get garbage replies from stepper drivers, increase this timeout. SERIAL_TIMEOUT = 0.1 # time before performing any actions at each position reached SETTLE_TIME = 1e-3 # for long moves, approximate the intermediate path by moves of this maximum length, m CHUNK_DIST = 0.005 # stepper move current = 2.0 A * (this / 100) MOVE_CURRENT_PCT = 50 HOLD_CURRENT_PCT = 50 # ----------------------------------------------------------------------------- # Physical constants # ----------------------------------------------------------------------------- # Used for converting linear distances into rotational ones. # This is the measured value of the helical drum minor diameter. PULLEY_RADIUS = .03014 / 2. # The helical drum means the length unspooled per radian is longer. # 1.5 mm pitch DRUM_PITCH = 1.5 / 1000. LENGTH_PER_REV = np . sqrt ( DRUM_PITCH ** 2. + ( np . pi * 2. * PULLEY_RADIUS ) ** 2. ) # delta x distance from the NW eyelet to the raft centroid, when it is driven # to the NW limit and the raft isn't cockeyed HOMING_OFFSET_X = 0.0276 # same, but for y HOMING_OFFSET_Y = - 0.0252 # ----------------------------------------------------------------------------- # Software constants # ----------------------------------------------------------------------------- # Limits the total number of commands that may be in the command queue at once. # Pretty much only limited by memory. MAX_QLEN = 2 ** 16 # Change these accordingly to point to the serial ports of the microcontroller # for the Hawkeyes and and serial-RS485 converter for the steppers. if sys . platform . startswith ( 'win' ): HAWKEYE_SERIAL_PORT = 'COM8' STEPPER_SERIAL_PORT = 'COM9' else : HAWKEYE_SERIAL_PORT = '/dev/ttyACM0' STEPPER_SERIAL_PORT = '/dev/ttyUSB0' # Helps with file input/outputs TOPLEVEL_DIR = os . path . abspath ( os . path . join ( __file__ , '..' , '..' ))","title":"Module hotspot.constants"},{"location":"reference/hotspot/constants/#variables","text":"CHUNK_DIST DEG_PER_RAD DEG_PER_STEP DRUM_PITCH ENCODER_TICKS_PER_REV HAWKEYE_SERIAL_PORT HOLD_CURRENT_PCT HOMING_OFFSET_X HOMING_OFFSET_Y LENGTH_PER_REV MAX_ACCEL_TICKS MAX_QLEN MAX_SPEED_TICKS MICROSTEP_NUM MOVE_CURRENT_PCT PULLEY_RADIUS SERIAL_BAUD SERIAL_BAUD_FAST SERIAL_TIMEOUT SETTLE_TIME STEPPER_SERIAL_PORT STEP_PER_TICK TOPLEVEL_DIR","title":"Variables"},{"location":"reference/hotspot/executive/","text":"Module hotspot.executive View Source # This file houses the code to process inputs, send commands to motors and IR # sources, and log/display telemetry import logging import multiprocessing as mp import numpy as np import os import subprocess import sys import threading import time from hotspot.hw_context import hawkeye_serial_instance , stepper_serial_instance , StepperSerial import hotspot.algorithm as alg import hotspot.constants as const import hotspot.hardware as hw import hotspot.telemetry as tm logger = logging . getLogger ( __name__ ) MODES = { 'c' : 'CAL_HOME' , 'h' : 'HOME' , 'r' : 'RUN' , 's' : 'SEL' , 'w' : 'WAIT' , 'b' : 'BLINK' } MODES_VERBOSE = { 'c' : 'Calibrate axes' , 'h' : 'Home goto' , 'r' : 'Run profile' , 's' : 'Select profile' , 'w' : 'Wait' , 'b' : 'Blink all Hawkeyes' } HR = '-' * 80 MENU_STR = ( HR + f ' \\n Listening for mode changes. Type a mode char and press enter: \\n ' + f ' { MODES_VERBOSE } \\n ' + HR ) STEPPER_ORDER = [ 'sw' , 'nw' , 'ne' , 'se' ] # just for convenience class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. self . positions_visited = 0 # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) # Talk to Hawkeyes over USB. self . hawkeye_ser = hawkeye_serial_instance # Talk to EZSteppers over RS485. self . stepper_ser = stepper_serial_instance # This mapping should match the physical setup. Match the corner eyelet # location to the address selector pot on the EZStepper driver board. self . steppers = { 'nw' : 2 , 'ne' : 1 , 'se' : 4 , 'sw' : 3 } # terminate all running commands resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'T \\r\\n ' ) # Swap to faster baud self . stepper_ser . write ( f '/_b { const . SERIAL_BAUD_FAST } R \\r\\n ' . encode ()) self . stepper_ser . close () self . stepper_ser = StepperSerial ( const . STEPPER_SERIAL_PORT , const . SERIAL_BAUD_FAST , timeout = const . SERIAL_TIMEOUT ) for address in self . steppers . keys (): # initialize driver settings resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ address ], ( 'n0' + # clear any special modes f 'm { const . MOVE_CURRENT_PCT } ' + f 'h { const . HOLD_CURRENT_PCT } ' + f 'L { const . MAX_ACCEL_TICKS } ' + # acceleration factor 'aC200' + # encoder coarse correction deadband, ticks 'ac5' + # encoder fine correction deadband, ticks # encoder ratio: 1000 * (usteps / rev) / (encoder ticks / rev) 'aE1280' + # 1280 = 1000 * (256 * 200) / 40000 'au1' + # number of retries allowed under stall condition 'z400000' + # set encoder zero point 'n8' + # enable encoder feedback mode 'R \\r\\n ' ) ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( input ()) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: { fname } ' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number { len ( rows ) } exceeds command' + f ' queue length { const . MAX_QLEN } . Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = int ( rows [ i ][ 0 ]) cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 'r' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'RUN' elif 's' == kbd_in : logger . info ( 'Select sequence requested.' ) self . mode = 'SEL' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' elif 'b' == kbd_in : logger . info ( 'Manual blink mode requested.' ) self . mode = 'BLINK' else : continue if self . mode == 'CAL_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'RUN' : self . sequence ( fname ) elif self . mode == 'SEL' : fname = self . get_new_sequence () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'WAIT' : self . wait () elif self . mode == 'BLINK' : self . blink () self . mode = 'WAIT' print ( MENU_STR ) else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: { self . robot . home } ' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = 0 cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def cal_home ( self ): ''' Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. ''' # ought to be smaller than distance stepper bounced back after hitting hard stop coarse_ticks = 5000 coarse_homing_speed = 80000 fine_ticks = 500 fine_homing_speed = coarse_homing_speed # sets the final zero-point length error for each axis ultra_fine_ticks = 5 ultra_fine_homing_speed = coarse_homing_speed # Home each axis axes = [ 'nw' , 'ne' , 'se' , 'sw' ] for current_axis in axes : logger . info ( f 'Homing to { current_axis } ' ) # turn off current to axes not being homed resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) logger . info ( 'Coarse homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], coarse_ticks , coarse_homing_speed , move_current = 50 , hold_current = 50 ) logger . info ( 'Fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], fine_ticks , fine_homing_speed , move_current = 50 , hold_current = 10 ) logger . info ( 'Ultra-fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], ultra_fine_ticks , ultra_fine_homing_speed , move_current = 100 , hold_current = 10 ) # run to position of hard stop resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], ( 'm50' + 'h50' + f 'V { fine_homing_speed } ' + f 'D { fine_ticks } ' + 'R \\r\\n ' ) ) # set cable length zero point time . sleep ( 1 ) hw . wait_for_ready ( self . stepper_ser , self . steppers [ current_axis ]) resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], 'z0R \\r\\n ' ) time . sleep ( 1 ) # Check to see that homing operation succeeeded. if hw . get_encoder_pos ( self . stepper_ser , self . steppers [ current_axis ]) > 20 : logger . critical ( 'Encoder failed to set zero point during homing. Aborting.' ) sys . exit ( 1 ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'm { const . MOVE_CURRENT_PCT } R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'h { const . HOLD_CURRENT_PCT } R \\r\\n ' ) # Update current encoder position (used for velocity calc in move to # home pos) for ax in axes : address = self . steppers [ ax ] hw . wait_for_ready ( self . stepper_ser , address ) actual_ticks = hw . get_encoder_pos ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'z { actual_ticks } R \\r\\n ' ) hw . wait_for_ready ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'A { actual_ticks } R \\r\\n ' ) self . robot . raft . position = self . robot . surf . sw + np . array ([ 0.1 , 0.1 ]) home = ( np . mean ([ self . robot . surf . ne [ 0 ], self . robot . surf . sw [ 0 ]]), np . mean ([ self . robot . surf . ne [ 1 ], self . robot . surf . sw [ 1 ]]) ) self . robot . home = home self . go_home () logger . info ( f 'Raft is homed with centroid position { self . robot . raft . position } ' ) logger . warning ( 'Verify that the raft has been driven to the center of the workspace and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : home , 'Motor Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/Hawkeyes. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) self . positions_visited = 0 # Make a new timestamped logfile self . router = tm . DataRouter ( self . tm_queue ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_hawkeye_tasks ( cmd ) logger . info ( f 'Raft centroid: { self . robot . raft . position } ' ) logger . info ( f 'Command completed. Sequence progress: { progress : .2f } %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def get_new_sequence ( self ): ''' Prompt the user to input the path to a sequence .csv file to run. Returns ------- fname the filename of the new scan profile to run on next 'r' command ''' profile_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'input' , 'profiles' ) print ( 'Please input the path to a new profile .csv file to run. ' + f 'Profile sequence files are stored in { profile_dir } . \\n Hit Enter' + ' for the prompt.' ) input_str = input ( 'Type a file path, or type \\' l \\' for a list: ' ) if input_str == 'l' : print ( 'Options are:' ) [ print ( file ) for file in os . listdir ( profile_dir )] fname = self . get_new_sequence () else : fname = os . path . abspath ( os . path . join ( profile_dir , input_str )) if not os . path . exists ( fname ): print ( f 'File { fname } does not exist.' ) fname = self . get_new_sequence () else : print ( f 'The next run command (r) will execute this profile: \\n { fname } ' ) return fname def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def blink ( self ): ''' Blink all sources. ''' cmd = {} cmd [ 'flasher_cmds' ] = 7 # center, inner ring, outer ring. binary: 111. self . do_hawkeye_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( 'Blink complete.' ) return def do_motor_tasks ( self , cmd : dict ): ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple , run = True ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = STEPPER_ORDER angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] ticks_to_go , err = hw . all_steppers_ez ( self . stepper_ser , [ self . steppers [ key ] for key in keys ], angs , run = run ) # Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. This ensures all cables stay taut, # even when moving to opposite corners. # CHUNK_DIST is a trade-off between smoothly approximating the needed # stepping profiles and the time taken to send many commands over # serial before starting the move. pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS while dist_to_go > const . CHUNK_DIST : logger . debug ( f 'Dist. to go in this move: { dist_to_go } ' ) # determine a position CHUNK_DIST away from the starting pos along # the direction of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: { v } , Unit vector: { u } ' ) pos_cmd = pos_before + const . CHUNK_DIST * u logger . debug ( f 'Intermediate move: { pos_cmd } ' ) send_pos_cmd ( pos_cmd , run = True ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) # temporary until streaming commands is fixed wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS # Signal ezsteppers to run once we've sent all commands for this move logger . debug ( f 'Final move: { pos_after } ' ) send_pos_cmd ( pos_after , run = True ) time . sleep ( wait_time ) return def take_image ( self ): time . sleep ( 1 ) self . positions_visited += 1 cmd = [ 'bash' , '-c' , f '. takeimg.sh { self . positions_visited } ' ] ret = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) if ret . returncode == 0 : print ( ret . stdout . decode ()) else : if ret . stdout : print ( ret . stdout . decode ()) if ret . stderr : print ( ret . stderr . decode ()) return def do_hawkeye_tasks ( self , cmd : dict ): packet = { 'Hawkeye Cmd' : { 'Local Time (s)' : time . time (), 'Hawkeye Cmd Byte' : np . array ( cmd [ 'flasher_cmds' ]), } } self . tm_queue . put ( packet ) time . sleep ( const . SETTLE_TIME ) # self.take_image() freq = 10. # switching freq, Hz, i.e. flashing freq is 1/2 this num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . send_hawkeye_byte ( self . hawkeye_ser , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) return def close ( self ): # ensure all hawkeyes are left in off state hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) self . hawkeye_ser . close () # Terminate all running commands time . sleep ( .1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'TR \\r\\n ' ) # Release torque time . sleep ( .1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) # Restore default baud hw . ezstepper_write ( self . stepper_ser , '_' , 'b9600R \\r\\n ' ) self . stepper_ser . close () return Variables HR MENU_STR MODES MODES_VERBOSE STEPPER_ORDER logger Classes Executive class Executive ( geometry_file : str , plot_enable = False ) Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Attributes Name Type Description Default geometry_file None Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. None View Source class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. self . positions_visited = 0 # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) # Talk to Hawkeyes over USB. self . hawkeye_ser = hawkeye_serial_instance # Talk to EZSteppers over RS485. self . stepper_ser = stepper_serial_instance # This mapping should match the physical setup. Match the corner eyelet # location to the address selector pot on the EZStepper driver board. self . steppers = { 'nw' : 2 , 'ne' : 1 , 'se' : 4 , 'sw' : 3 } # terminate all running commands resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'T \\r\\n ' ) # Swap to faster baud self . stepper_ser . write ( f '/_b{const.SERIAL_BAUD_FAST}R \\r\\n ' . encode ()) self . stepper_ser . close () self . stepper_ser = StepperSerial ( const . STEPPER_SERIAL_PORT , const . SERIAL_BAUD_FAST , timeout = const . SERIAL_TIMEOUT ) for address in self . steppers . keys (): # initialize driver settings resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ address ], ( 'n0' + # clear any special modes f 'm{const.MOVE_CURRENT_PCT}' + f 'h{const.HOLD_CURRENT_PCT}' + f 'L{const.MAX_ACCEL_TICKS}' + # acceleration factor 'aC200' + # encoder coarse correction deadband, ticks 'ac5' + # encoder fine correction deadband, ticks # encoder ratio: 1000 * (usteps / rev) / (encoder ticks / rev) 'aE1280' + # 1280 = 1000 * (256 * 200) / 40000 'au1' + # number of retries allowed under stall condition 'z400000' + # set encoder zero point 'n8' + # enable encoder feedback mode 'R \\r\\n ' ) ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( input ()) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number {len(rows)} exceeds command' + f ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = int ( rows [ i ][ 0 ]) cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 'r' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'RUN' elif 's' == kbd_in : logger . info ( 'Select sequence requested.' ) self . mode = 'SEL' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' elif 'b' == kbd_in : logger . info ( 'Manual blink mode requested.' ) self . mode = 'BLINK' else : continue if self . mode == 'CAL_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'RUN' : self . sequence ( fname ) elif self . mode == 'SEL' : fname = self . get_new_sequence () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'WAIT' : self . wait () elif self . mode == 'BLINK' : self . blink () self . mode = 'WAIT' print ( MENU_STR ) else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = 0 cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def cal_home ( self ): ''' Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. ''' # ought to be smaller than distance stepper bounced back after hitting hard stop coarse_ticks = 5000 coarse_homing_speed = 80000 fine_ticks = 500 fine_homing_speed = coarse_homing_speed # sets the final zero-point length error for each axis ultra_fine_ticks = 5 ultra_fine_homing_speed = coarse_homing_speed # Home each axis axes = [ 'nw' , 'ne' , 'se' , 'sw' ] for current_axis in axes : logger . info ( f 'Homing to {current_axis}' ) # turn off current to axes not being homed resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) logger . info ( 'Coarse homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], coarse_ticks , coarse_homing_speed , move_current = 50 , hold_current = 50 ) logger . info ( 'Fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], fine_ticks , fine_homing_speed , move_current = 50 , hold_current = 10 ) logger . info ( 'Ultra-fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], ultra_fine_ticks , ultra_fine_homing_speed , move_current = 100 , hold_current = 10 ) # run to position of hard stop resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], ( 'm50' + 'h50' + f 'V{fine_homing_speed}' + f 'D{fine_ticks}' + 'R \\r\\n ' ) ) # set cable length zero point time . sleep ( 1 ) hw . wait_for_ready ( self . stepper_ser , self . steppers [ current_axis ]) resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], 'z0R \\r\\n ' ) time . sleep ( 1 ) # Check to see that homing operation succeeeded. if hw . get_encoder_pos ( self . stepper_ser , self . steppers [ current_axis ]) > 20 : logger . critical ( 'Encoder failed to set zero point during homing. Aborting.' ) sys . exit ( 1 ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'm{const.MOVE_CURRENT_PCT}R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'h{const.HOLD_CURRENT_PCT}R \\r\\n ' ) # Update current encoder position (used for velocity calc in move to # home pos) for ax in axes : address = self . steppers [ ax ] hw . wait_for_ready ( self . stepper_ser , address ) actual_ticks = hw . get_encoder_pos ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'z{actual_ticks}R \\r\\n ' ) hw . wait_for_ready ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'A{actual_ticks}R \\r\\n ' ) self . robot . raft . position = self . robot . surf . sw + np . array ([ 0.1 , 0.1 ]) home = ( np . mean ([ self . robot . surf . ne [ 0 ], self . robot . surf . sw [ 0 ]]), np . mean ([ self . robot . surf . ne [ 1 ], self . robot . surf . sw [ 1 ]]) ) self . robot . home = home self . go_home () logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to the center of the workspace and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : home , 'Motor Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/Hawkeyes. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) self . positions_visited = 0 # Make a new timestamped logfile self . router = tm . DataRouter ( self . tm_queue ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_hawkeye_tasks ( cmd ) logger . info ( f 'Raft centroid: {self.robot.raft.position}' ) logger . info ( f 'Command completed. Sequence progress: {progress:.2f} %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def get_new_sequence ( self ): ''' Prompt the user to input the path to a sequence .csv file to run. Returns ------- fname the filename of the new scan profile to run on next 'r' command ''' profile_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'input' , 'profiles' ) print ( 'Please input the path to a new profile .csv file to run. ' + f 'Profile sequence files are stored in {profile_dir}. \\n Hit Enter' + ' for the prompt.' ) input_str = input ( 'Type a file path, or type \\' l \\' for a list: ' ) if input_str == 'l' : print ( 'Options are:' ) [ print ( file ) for file in os . listdir ( profile_dir )] fname = self . get_new_sequence () else : fname = os . path . abspath ( os . path . join ( profile_dir , input_str )) if not os . path . exists ( fname ): print ( f 'File {fname} does not exist.' ) fname = self . get_new_sequence () else : print ( f 'The next run command (r) will execute this profile: \\n {fname}' ) return fname def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def blink ( self ): ''' Blink all sources. ''' cmd = {} cmd [ 'flasher_cmds' ] = 7 # center, inner ring, outer ring. binary: 111. self . do_hawkeye_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( 'Blink complete.' ) return def do_motor_tasks ( self , cmd : dict ): ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple , run = True ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = STEPPER_ORDER angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] ticks_to_go , err = hw . all_steppers_ez ( self . stepper_ser , [ self . steppers [ key ] for key in keys ], angs , run = run ) # Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. This ensures all cables stay taut, # even when moving to opposite corners. # CHUNK_DIST is a trade-off between smoothly approximating the needed # stepping profiles and the time taken to send many commands over # serial before starting the move. pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS while dist_to_go > const . CHUNK_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position CHUNK_DIST away from the starting pos along # the direction of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + const . CHUNK_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd , run = True ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) # temporary until streaming commands is fixed wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS # Signal ezsteppers to run once we've sent all commands for this move logger . debug ( f 'Final move: {pos_after}' ) send_pos_cmd ( pos_after , run = True ) time . sleep ( wait_time ) return def take_image ( self ): time . sleep ( 1 ) self . positions_visited += 1 cmd = [ 'bash' , '-c' , f '. takeimg.sh {self.positions_visited}' ] ret = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) if ret . returncode == 0 : print ( ret . stdout . decode ()) else : if ret . stdout : print ( ret . stdout . decode ()) if ret . stderr : print ( ret . stderr . decode ()) return def do_hawkeye_tasks ( self , cmd : dict ): packet = { 'Hawkeye Cmd' : { 'Local Time (s)' : time . time (), 'Hawkeye Cmd Byte' : np . array ( cmd [ 'flasher_cmds' ]), } } self . tm_queue . put ( packet ) time . sleep ( const . SETTLE_TIME ) # self.take_image() freq = 10. # switching freq, Hz, i.e. flashing freq is 1/2 this num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . send_hawkeye_byte ( self . hawkeye_ser , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) return def close ( self ): # ensure all hawkeyes are left in off state hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) self . hawkeye_ser . close () # Terminate all running commands time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'TR \\r\\n ' ) # Release torque time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) # Restore default baud hw . ezstepper_write ( self . stepper_ser , '_' , 'b9600R \\r\\n ' ) self . stepper_ser . close () return Methods add_cmds def add_cmds ( self , fname : str ) Read command input file and add commands to the command queue. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def add_cmds ( self , fname : str ) : ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ) : logger . warn ( f 'Input command number {len(rows)} exceeds command' + f ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ) : cmd = {} cmd [ 'flasher_cmds' ] = int ( rows [ i ][ 0 ] ) cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ] , rows [ i ][ 2 ] ) self . cmd_queue . put ( cmd ) return blink def blink ( self ) Blink all sources. View Source def blink ( self ) : '' ' Blink all sources. '' ' cmd = {} cmd [ 'flasher_cmds' ] = 7 # center , inner ring , outer ring . binary : 111 . self . do_hawkeye_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( 'Blink complete.' ) return cal_home def cal_home ( self ) Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. View Source def cal_home ( self ) : ''' Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. ''' # ought to be smaller than distance stepper bounced back after hitting hard stop coarse_ticks = 5000 coarse_homing_speed = 80000 fine_ticks = 500 fine_homing_speed = coarse_homing_speed # sets the final zero - point length error for each axis ultra_fine_ticks = 5 ultra_fine_homing_speed = coarse_homing_speed # Home each axis axes = [ 'nw', 'ne', 'se', 'sw' ] for current_axis in axes : logger . info ( f 'Homing to {current_axis}' ) # turn off current to axes not being homed resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R\\r\\n' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R\\r\\n' ) logger . info ( 'Coarse homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ] , coarse_ticks , coarse_homing_speed , move_current = 50 , hold_current = 50 ) logger . info ( 'Fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ] , fine_ticks , fine_homing_speed , move_current = 50 , hold_current = 10 ) logger . info ( 'Ultra-fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ] , ultra_fine_ticks , ultra_fine_homing_speed , move_current = 100 , hold_current = 10 ) # run to position of hard stop resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ] , ( 'm50' + 'h50' + f 'V{fine_homing_speed}' + f 'D{fine_ticks}' + 'R\\r\\n' ) ) # set cable length zero point time . sleep ( 1 ) hw . wait_for_ready ( self . stepper_ser , self . steppers [ current_axis ] ) resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ] , 'z0R\\r\\n' ) time . sleep ( 1 ) # Check to see that homing operation succeeeded . if hw . get_encoder_pos ( self . stepper_ser , self . steppers [ current_axis ] ) > 20 : logger . critical ( 'Encoder failed to set zero point during homing. Aborting.' ) sys . exit ( 1 ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'm{const.MOVE_CURRENT_PCT}R\\r\\n' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'h{const.HOLD_CURRENT_PCT}R\\r\\n' ) # Update current encoder position ( used for velocity calc in move to # home pos ) for ax in axes : address = self . steppers [ ax ] hw . wait_for_ready ( self . stepper_ser , address ) actual_ticks = hw . get_encoder_pos ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'z{actual_ticks}R\\r\\n' ) hw . wait_for_ready ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'A{actual_ticks}R\\r\\n' ) self . robot . raft . position = self . robot . surf . sw + np . array ( [ 0.1, 0.1 ] ) home = ( np . mean ( [ self.robot.surf.ne[0 ] , self . robot . surf . sw [ 0 ] ] ), np . mean ( [ self.robot.surf.ne[1 ] , self . robot . surf . sw [ 1 ] ] ) ) self . robot . home = home self . go_home () logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to the center of the workspace and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : home , 'Motor Angle Command (rad)' : np . array ( [ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return close def close ( self ) View Source def close ( self ) : # ensure all hawkeyes are left in off state hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) self . hawkeye_ser . close () # Terminate all running commands time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'TR\\r\\n' ) # Release torque time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R\\r\\n' ) hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R\\r\\n' ) # Restore default baud hw . ezstepper_write ( self . stepper_ser , '_' , 'b9600R\\r\\n' ) self . stepper_ser . close () return do_hawkeye_tasks def do_hawkeye_tasks ( self , cmd : dict ) View Source def do_hawkeye_tasks ( self , cmd : dict ): packet = { 'Hawkeye Cmd' : { 'Local Time (s)' : time . time (), 'Hawkeye Cmd Byte' : np . array ( cmd [ 'flasher_cmds' ]), } } self . tm_queue . put ( packet ) time . sleep ( const . SETTLE_TIME ) # self.take_image() freq = 10. # switching freq, Hz, i.e. flashing freq is 1/2 this num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . send_hawkeye_byte ( self . hawkeye_ser , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) return do_motor_tasks def do_motor_tasks ( self , cmd : dict ) Transform the move command into motor commands Parameters: Name Type Description Default cmd Command packet dictionary with keys for position commands to pass to control algorithm None View Source def do_motor_tasks ( self , cmd : dict ) : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple , run = True ) : ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = STEPPER_ORDER angs = [ cmd for cmd in [motor_cmds[key ] for key in keys ]] ticks_to_go , err = hw . all_steppers_ez ( self . stepper_ser , [ self.steppers[key ] for key in keys ] , angs , run = run ) # Linear approximation only holds for small distances , so # chunk up big moves into tiny bits . This ensures all cables stay taut , # even when moving to opposite corners . # CHUNK_DIST is a trade - off between smoothly approximating the needed # stepping profiles and the time taken to send many commands over # serial before starting the move . pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS while dist_to_go > const . CHUNK_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position CHUNK_DIST away from the starting pos along # the direction of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + const . CHUNK_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd , run = True ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) # temporary until streaming commands is fixed wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS # Signal ezsteppers to run once we 've sent all commands for this move logger.debug(f' Final move : { pos_after }' ) send_pos_cmd ( pos_after , run = True ) time . sleep ( wait_time ) return empty_queue def empty_queue ( self , queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f0182295c90 >> ) Completely empty the given Queue object. Parameters: Name Type Description Default queue None Any queue None View Source def empty_queue ( self , queue : mp . Queue ) : '' ' Completely empty the given Queue object. Parameters ---------- queue Any queue '' ' while not queue.empty(): queue.get() return get_new_sequence def get_new_sequence ( self ) Prompt the user to input the path to a sequence .csv file to run. Returns: Type Description fname the filename of the new scan profile to run on next 'r' command View Source def get_new_sequence ( self ): ''' Prompt the user to input the path to a sequence .csv file to run. Returns ------- fname the filename of the new scan profile to run on next 'r' command ''' profile_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'input' , 'profiles' ) print ( 'Please input the path to a new profile .csv file to run. ' + f 'Profile sequence files are stored in {profile_dir}. \\n Hit Enter' + ' for the prompt.' ) input_str = input ( 'Type a file path, or type \\' l \\' for a list: ' ) if input_str == 'l' : print ( 'Options are:' ) [ print ( file ) for file in os . listdir ( profile_dir )] fname = self . get_new_sequence () else : fname = os . path . abspath ( os . path . join ( profile_dir , input_str )) if not os . path . exists ( fname ): print ( f 'File {fname} does not exist.' ) fname = self . get_new_sequence () else : print ( f 'The next run command (r) will execute this profile: \\n {fname}' ) return fname go_home def go_home ( self ) Clear all commands in the queue and drive to the home position. View Source def go_home ( self ) : ''' Clear all commands in the queue and drive to the home position. ''' # If not already home , go there . eps = np . finfo ( float ). eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )) : logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = 0 cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return run def run ( self , fname : str ) Main run function, including processing human input to switch between states. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def run ( self , fname : str ) : '' ' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. '' ' # Allow user input to change the mode. input_thread = threading.Thread( target=self._get_kbd, args=(self.kbd_queue,), daemon=True ) input_thread.start() print(MENU_STR) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty () : kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 'r' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'RUN' elif 's' == kbd_in : logger . info ( 'Select sequence requested.' ) self . mode = 'SEL' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' elif 'b' == kbd_in : logger . info ( 'Manual blink mode requested.' ) self . mode = 'BLINK' else : continue if self . mode == 'CAL_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'RUN' : self . sequence ( fname ) elif self . mode == 'SEL' : fname = self . get_new_sequence () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'WAIT' : self . wait () elif self . mode == 'BLINK' : self . blink () self . mode = 'WAIT' print ( MENU_STR ) else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( '\\nCaught KeyboardInterrupt, shutting down.' ) running = False self . close () return sequence def sequence ( self , fname : str ) On each call, pop a new command off of the command queue and dispatch it to motors/Hawkeyes. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate None View Source def sequence ( self , fname : str ): ''' On each call , pop a new command off of the command queue and dispatch it to motors / Hawkeyes . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col : - flasher_cmds : 1 or 0 depending on whether that address is enabled - pos_cmd_0s : 0 th element of position command coordinate - pos_cmd_1s : 1 st element of position command coordinate ''' # If we are changing to sequence from another mode , ensure we start # fresh if self . mode != self . last_mode : logger . info ( ' Beginning command sequence . ' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) self . positions_visited = 0 # Make a new timestamped logfile self . router = tm . DataRouter ( self . tm_queue ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = ' WAIT ' return else : cmd = self . cmd_queue . get () progress = 100 . * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks , then LJ tasks , so IR source tasks happen at the end of each move . self . do_motor_tasks ( cmd ) self . do_hawkeye_tasks ( cmd ) logger . info ( f ' Raft centroid : { self . robot . raft . position } ' ) logger . info ( f ' Command completed . Sequence progress : { progress : .2 f } % ' ) self . router . process_tm ( plot_enable = self . plot_enable ) return take_image def take_image ( self ) View Source def take_image ( self ) : time . sleep ( 1 ) self . positions_visited += 1 cmd = [ 'bash' , '-c' , f '. takeimg.sh {self.positions_visited}' ] ret = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) if ret . returncode == 0 : print ( ret . stdout . decode ()) else : if ret . stdout : print ( ret . stdout . decode ()) if ret . stderr : print ( ret . stderr . decode ()) return wait def wait ( self ) View Source def wait ( self ) : if self . plot_enable : self . router . run_gui_event_loop () return","title":"Executive"},{"location":"reference/hotspot/executive/#module-hotspotexecutive","text":"View Source # This file houses the code to process inputs, send commands to motors and IR # sources, and log/display telemetry import logging import multiprocessing as mp import numpy as np import os import subprocess import sys import threading import time from hotspot.hw_context import hawkeye_serial_instance , stepper_serial_instance , StepperSerial import hotspot.algorithm as alg import hotspot.constants as const import hotspot.hardware as hw import hotspot.telemetry as tm logger = logging . getLogger ( __name__ ) MODES = { 'c' : 'CAL_HOME' , 'h' : 'HOME' , 'r' : 'RUN' , 's' : 'SEL' , 'w' : 'WAIT' , 'b' : 'BLINK' } MODES_VERBOSE = { 'c' : 'Calibrate axes' , 'h' : 'Home goto' , 'r' : 'Run profile' , 's' : 'Select profile' , 'w' : 'Wait' , 'b' : 'Blink all Hawkeyes' } HR = '-' * 80 MENU_STR = ( HR + f ' \\n Listening for mode changes. Type a mode char and press enter: \\n ' + f ' { MODES_VERBOSE } \\n ' + HR ) STEPPER_ORDER = [ 'sw' , 'nw' , 'ne' , 'se' ] # just for convenience class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. self . positions_visited = 0 # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) # Talk to Hawkeyes over USB. self . hawkeye_ser = hawkeye_serial_instance # Talk to EZSteppers over RS485. self . stepper_ser = stepper_serial_instance # This mapping should match the physical setup. Match the corner eyelet # location to the address selector pot on the EZStepper driver board. self . steppers = { 'nw' : 2 , 'ne' : 1 , 'se' : 4 , 'sw' : 3 } # terminate all running commands resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'T \\r\\n ' ) # Swap to faster baud self . stepper_ser . write ( f '/_b { const . SERIAL_BAUD_FAST } R \\r\\n ' . encode ()) self . stepper_ser . close () self . stepper_ser = StepperSerial ( const . STEPPER_SERIAL_PORT , const . SERIAL_BAUD_FAST , timeout = const . SERIAL_TIMEOUT ) for address in self . steppers . keys (): # initialize driver settings resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ address ], ( 'n0' + # clear any special modes f 'm { const . MOVE_CURRENT_PCT } ' + f 'h { const . HOLD_CURRENT_PCT } ' + f 'L { const . MAX_ACCEL_TICKS } ' + # acceleration factor 'aC200' + # encoder coarse correction deadband, ticks 'ac5' + # encoder fine correction deadband, ticks # encoder ratio: 1000 * (usteps / rev) / (encoder ticks / rev) 'aE1280' + # 1280 = 1000 * (256 * 200) / 40000 'au1' + # number of retries allowed under stall condition 'z400000' + # set encoder zero point 'n8' + # enable encoder feedback mode 'R \\r\\n ' ) ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( input ()) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: { fname } ' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number { len ( rows ) } exceeds command' + f ' queue length { const . MAX_QLEN } . Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = int ( rows [ i ][ 0 ]) cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 'r' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'RUN' elif 's' == kbd_in : logger . info ( 'Select sequence requested.' ) self . mode = 'SEL' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' elif 'b' == kbd_in : logger . info ( 'Manual blink mode requested.' ) self . mode = 'BLINK' else : continue if self . mode == 'CAL_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'RUN' : self . sequence ( fname ) elif self . mode == 'SEL' : fname = self . get_new_sequence () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'WAIT' : self . wait () elif self . mode == 'BLINK' : self . blink () self . mode = 'WAIT' print ( MENU_STR ) else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: { self . robot . home } ' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = 0 cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def cal_home ( self ): ''' Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. ''' # ought to be smaller than distance stepper bounced back after hitting hard stop coarse_ticks = 5000 coarse_homing_speed = 80000 fine_ticks = 500 fine_homing_speed = coarse_homing_speed # sets the final zero-point length error for each axis ultra_fine_ticks = 5 ultra_fine_homing_speed = coarse_homing_speed # Home each axis axes = [ 'nw' , 'ne' , 'se' , 'sw' ] for current_axis in axes : logger . info ( f 'Homing to { current_axis } ' ) # turn off current to axes not being homed resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) logger . info ( 'Coarse homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], coarse_ticks , coarse_homing_speed , move_current = 50 , hold_current = 50 ) logger . info ( 'Fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], fine_ticks , fine_homing_speed , move_current = 50 , hold_current = 10 ) logger . info ( 'Ultra-fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], ultra_fine_ticks , ultra_fine_homing_speed , move_current = 100 , hold_current = 10 ) # run to position of hard stop resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], ( 'm50' + 'h50' + f 'V { fine_homing_speed } ' + f 'D { fine_ticks } ' + 'R \\r\\n ' ) ) # set cable length zero point time . sleep ( 1 ) hw . wait_for_ready ( self . stepper_ser , self . steppers [ current_axis ]) resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], 'z0R \\r\\n ' ) time . sleep ( 1 ) # Check to see that homing operation succeeeded. if hw . get_encoder_pos ( self . stepper_ser , self . steppers [ current_axis ]) > 20 : logger . critical ( 'Encoder failed to set zero point during homing. Aborting.' ) sys . exit ( 1 ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'm { const . MOVE_CURRENT_PCT } R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'h { const . HOLD_CURRENT_PCT } R \\r\\n ' ) # Update current encoder position (used for velocity calc in move to # home pos) for ax in axes : address = self . steppers [ ax ] hw . wait_for_ready ( self . stepper_ser , address ) actual_ticks = hw . get_encoder_pos ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'z { actual_ticks } R \\r\\n ' ) hw . wait_for_ready ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'A { actual_ticks } R \\r\\n ' ) self . robot . raft . position = self . robot . surf . sw + np . array ([ 0.1 , 0.1 ]) home = ( np . mean ([ self . robot . surf . ne [ 0 ], self . robot . surf . sw [ 0 ]]), np . mean ([ self . robot . surf . ne [ 1 ], self . robot . surf . sw [ 1 ]]) ) self . robot . home = home self . go_home () logger . info ( f 'Raft is homed with centroid position { self . robot . raft . position } ' ) logger . warning ( 'Verify that the raft has been driven to the center of the workspace and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : home , 'Motor Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/Hawkeyes. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) self . positions_visited = 0 # Make a new timestamped logfile self . router = tm . DataRouter ( self . tm_queue ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_hawkeye_tasks ( cmd ) logger . info ( f 'Raft centroid: { self . robot . raft . position } ' ) logger . info ( f 'Command completed. Sequence progress: { progress : .2f } %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def get_new_sequence ( self ): ''' Prompt the user to input the path to a sequence .csv file to run. Returns ------- fname the filename of the new scan profile to run on next 'r' command ''' profile_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'input' , 'profiles' ) print ( 'Please input the path to a new profile .csv file to run. ' + f 'Profile sequence files are stored in { profile_dir } . \\n Hit Enter' + ' for the prompt.' ) input_str = input ( 'Type a file path, or type \\' l \\' for a list: ' ) if input_str == 'l' : print ( 'Options are:' ) [ print ( file ) for file in os . listdir ( profile_dir )] fname = self . get_new_sequence () else : fname = os . path . abspath ( os . path . join ( profile_dir , input_str )) if not os . path . exists ( fname ): print ( f 'File { fname } does not exist.' ) fname = self . get_new_sequence () else : print ( f 'The next run command (r) will execute this profile: \\n { fname } ' ) return fname def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def blink ( self ): ''' Blink all sources. ''' cmd = {} cmd [ 'flasher_cmds' ] = 7 # center, inner ring, outer ring. binary: 111. self . do_hawkeye_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( 'Blink complete.' ) return def do_motor_tasks ( self , cmd : dict ): ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple , run = True ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = STEPPER_ORDER angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] ticks_to_go , err = hw . all_steppers_ez ( self . stepper_ser , [ self . steppers [ key ] for key in keys ], angs , run = run ) # Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. This ensures all cables stay taut, # even when moving to opposite corners. # CHUNK_DIST is a trade-off between smoothly approximating the needed # stepping profiles and the time taken to send many commands over # serial before starting the move. pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS while dist_to_go > const . CHUNK_DIST : logger . debug ( f 'Dist. to go in this move: { dist_to_go } ' ) # determine a position CHUNK_DIST away from the starting pos along # the direction of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: { v } , Unit vector: { u } ' ) pos_cmd = pos_before + const . CHUNK_DIST * u logger . debug ( f 'Intermediate move: { pos_cmd } ' ) send_pos_cmd ( pos_cmd , run = True ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) # temporary until streaming commands is fixed wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS # Signal ezsteppers to run once we've sent all commands for this move logger . debug ( f 'Final move: { pos_after } ' ) send_pos_cmd ( pos_after , run = True ) time . sleep ( wait_time ) return def take_image ( self ): time . sleep ( 1 ) self . positions_visited += 1 cmd = [ 'bash' , '-c' , f '. takeimg.sh { self . positions_visited } ' ] ret = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) if ret . returncode == 0 : print ( ret . stdout . decode ()) else : if ret . stdout : print ( ret . stdout . decode ()) if ret . stderr : print ( ret . stderr . decode ()) return def do_hawkeye_tasks ( self , cmd : dict ): packet = { 'Hawkeye Cmd' : { 'Local Time (s)' : time . time (), 'Hawkeye Cmd Byte' : np . array ( cmd [ 'flasher_cmds' ]), } } self . tm_queue . put ( packet ) time . sleep ( const . SETTLE_TIME ) # self.take_image() freq = 10. # switching freq, Hz, i.e. flashing freq is 1/2 this num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . send_hawkeye_byte ( self . hawkeye_ser , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) return def close ( self ): # ensure all hawkeyes are left in off state hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) self . hawkeye_ser . close () # Terminate all running commands time . sleep ( .1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'TR \\r\\n ' ) # Release torque time . sleep ( .1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) # Restore default baud hw . ezstepper_write ( self . stepper_ser , '_' , 'b9600R \\r\\n ' ) self . stepper_ser . close () return","title":"Module hotspot.executive"},{"location":"reference/hotspot/executive/#variables","text":"HR MENU_STR MODES MODES_VERBOSE STEPPER_ORDER logger","title":"Variables"},{"location":"reference/hotspot/executive/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/executive/#executive","text":"class Executive ( geometry_file : str , plot_enable = False ) Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry.","title":"Executive"},{"location":"reference/hotspot/executive/#attributes","text":"Name Type Description Default geometry_file None Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. None View Source class Executive : ''' Handles control flow with a state machine, initializes the algorithm's Robot class, ingests command files to process and dispatch tasks to hardware, and outputs telemetry. Parameters ---------- geometry_file Text file with 10 cols specifying the geometry of the robot for a given surface. This file defines 4 pairs of points describing cable endpoints where they are attached to the mirror, in the mirror coordinate frame, and the rectangular geometry of the central effector as a width and height. ''' def __init__ ( self , geometry_file : str , plot_enable = False ): logger . debug ( 'Executive init' ) # Set defaults self . mode = 'WAIT' self . last_mode = 'WAIT' self . kbd_queue = mp . Queue ( 1 ) self . cmd_queue = mp . Queue ( const . MAX_QLEN ) self . tm_queue = mp . Queue ( const . MAX_QLEN ) self . sequence_len = 0. self . positions_visited = 0 # Handle telemetry output self . router = tm . DataRouter ( self . tm_queue ) self . plot_enable = plot_enable # Read in positions of cable endpoints and raft dimensions ( sw_0 , sw_1 , nw_0 , nw_1 , se_0 , se_1 , ne_0 , ne_1 , w , h ) = np . loadtxt ( geometry_file , dtype = float , delimiter = ',' , skiprows = 1 , ) sw = ( sw_0 , sw_1 ) nw = ( nw_0 , nw_1 ) se = ( se_0 , se_1 ) ne = ( ne_0 , ne_1 ) surf = alg . TestSurface ( sw = sw , se = se , nw = nw , ne = ne ) # Initialize the raft to 0,0 until homed. raft = alg . Raft (( 0 , 0 ), w , h ) self . robot = alg . Robot ( surf , raft , self . tm_queue ) # Talk to Hawkeyes over USB. self . hawkeye_ser = hawkeye_serial_instance # Talk to EZSteppers over RS485. self . stepper_ser = stepper_serial_instance # This mapping should match the physical setup. Match the corner eyelet # location to the address selector pot on the EZStepper driver board. self . steppers = { 'nw' : 2 , 'ne' : 1 , 'se' : 4 , 'sw' : 3 } # terminate all running commands resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'T \\r\\n ' ) # Swap to faster baud self . stepper_ser . write ( f '/_b{const.SERIAL_BAUD_FAST}R \\r\\n ' . encode ()) self . stepper_ser . close () self . stepper_ser = StepperSerial ( const . STEPPER_SERIAL_PORT , const . SERIAL_BAUD_FAST , timeout = const . SERIAL_TIMEOUT ) for address in self . steppers . keys (): # initialize driver settings resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ address ], ( 'n0' + # clear any special modes f 'm{const.MOVE_CURRENT_PCT}' + f 'h{const.HOLD_CURRENT_PCT}' + f 'L{const.MAX_ACCEL_TICKS}' + # acceleration factor 'aC200' + # encoder coarse correction deadband, ticks 'ac5' + # encoder fine correction deadband, ticks # encoder ratio: 1000 * (usteps / rev) / (encoder ticks / rev) 'aE1280' + # 1280 = 1000 * (256 * 200) / 40000 'au1' + # number of retries allowed under stall condition 'z400000' + # set encoder zero point 'n8' + # enable encoder feedback mode 'R \\r\\n ' ) ) return def _get_kbd ( self , queue : mp . Queue ): ''' Helper function to run in a separate thread and add user input chars to a buffer. Parameters ---------- queue Threadsafe structure for handling user keyboard input for mode switching ''' while True : queue . put ( input ()) def add_cmds ( self , fname : str ): ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ): logger . warn ( f 'Input command number {len(rows)} exceeds command' + f ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ): cmd = {} cmd [ 'flasher_cmds' ] = int ( rows [ i ][ 0 ]) cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ], rows [ i ][ 2 ]) self . cmd_queue . put ( cmd ) return def empty_queue ( self , queue : mp . Queue ): ''' Completely empty the given Queue object. Parameters ---------- queue Any queue ''' while not queue . empty (): queue . get () return def run ( self , fname : str ): ''' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' # Allow user input to change the mode. input_thread = threading . Thread ( target = self . _get_kbd , args = ( self . kbd_queue ,), daemon = True ) input_thread . start () print ( MENU_STR ) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty (): kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 'r' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'RUN' elif 's' == kbd_in : logger . info ( 'Select sequence requested.' ) self . mode = 'SEL' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' elif 'b' == kbd_in : logger . info ( 'Manual blink mode requested.' ) self . mode = 'BLINK' else : continue if self . mode == 'CAL_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'RUN' : self . sequence ( fname ) elif self . mode == 'SEL' : fname = self . get_new_sequence () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'WAIT' : self . wait () elif self . mode == 'BLINK' : self . blink () self . mode = 'WAIT' print ( MENU_STR ) else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( ' \\n Caught KeyboardInterrupt, shutting down.' ) running = False self . close () return def go_home ( self ): ''' Clear all commands in the queue and drive to the home position. ''' # If not already home, go there. eps = np . finfo ( float ) . eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )): logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = 0 cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return def cal_home ( self ): ''' Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. ''' # ought to be smaller than distance stepper bounced back after hitting hard stop coarse_ticks = 5000 coarse_homing_speed = 80000 fine_ticks = 500 fine_homing_speed = coarse_homing_speed # sets the final zero-point length error for each axis ultra_fine_ticks = 5 ultra_fine_homing_speed = coarse_homing_speed # Home each axis axes = [ 'nw' , 'ne' , 'se' , 'sw' ] for current_axis in axes : logger . info ( f 'Homing to {current_axis}' ) # turn off current to axes not being homed resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) logger . info ( 'Coarse homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], coarse_ticks , coarse_homing_speed , move_current = 50 , hold_current = 50 ) logger . info ( 'Fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], fine_ticks , fine_homing_speed , move_current = 50 , hold_current = 10 ) logger . info ( 'Ultra-fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ], ultra_fine_ticks , ultra_fine_homing_speed , move_current = 100 , hold_current = 10 ) # run to position of hard stop resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], ( 'm50' + 'h50' + f 'V{fine_homing_speed}' + f 'D{fine_ticks}' + 'R \\r\\n ' ) ) # set cable length zero point time . sleep ( 1 ) hw . wait_for_ready ( self . stepper_ser , self . steppers [ current_axis ]) resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ], 'z0R \\r\\n ' ) time . sleep ( 1 ) # Check to see that homing operation succeeeded. if hw . get_encoder_pos ( self . stepper_ser , self . steppers [ current_axis ]) > 20 : logger . critical ( 'Encoder failed to set zero point during homing. Aborting.' ) sys . exit ( 1 ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'm{const.MOVE_CURRENT_PCT}R \\r\\n ' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'h{const.HOLD_CURRENT_PCT}R \\r\\n ' ) # Update current encoder position (used for velocity calc in move to # home pos) for ax in axes : address = self . steppers [ ax ] hw . wait_for_ready ( self . stepper_ser , address ) actual_ticks = hw . get_encoder_pos ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'z{actual_ticks}R \\r\\n ' ) hw . wait_for_ready ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'A{actual_ticks}R \\r\\n ' ) self . robot . raft . position = self . robot . surf . sw + np . array ([ 0.1 , 0.1 ]) home = ( np . mean ([ self . robot . surf . ne [ 0 ], self . robot . surf . sw [ 0 ]]), np . mean ([ self . robot . surf . ne [ 1 ], self . robot . surf . sw [ 1 ]]) ) self . robot . home = home self . go_home () logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to the center of the workspace and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : home , 'Motor Angle Command (rad)' : np . array ([ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return def sequence ( self , fname : str ): ''' On each call, pop a new command off of the command queue and dispatch it to motors/Hawkeyes. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate ''' # If we are changing to sequence from another mode, ensure we start # fresh if self . mode != self . last_mode : logger . info ( 'Beginning command sequence.' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) self . positions_visited = 0 # Make a new timestamped logfile self . router = tm . DataRouter ( self . tm_queue ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = 'WAIT' return else : cmd = self . cmd_queue . get () progress = 100. * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks, then LJ tasks, so IR source tasks happen at the end of each move. self . do_motor_tasks ( cmd ) self . do_hawkeye_tasks ( cmd ) logger . info ( f 'Raft centroid: {self.robot.raft.position}' ) logger . info ( f 'Command completed. Sequence progress: {progress:.2f} %' ) self . router . process_tm ( plot_enable = self . plot_enable ) return def get_new_sequence ( self ): ''' Prompt the user to input the path to a sequence .csv file to run. Returns ------- fname the filename of the new scan profile to run on next 'r' command ''' profile_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'input' , 'profiles' ) print ( 'Please input the path to a new profile .csv file to run. ' + f 'Profile sequence files are stored in {profile_dir}. \\n Hit Enter' + ' for the prompt.' ) input_str = input ( 'Type a file path, or type \\' l \\' for a list: ' ) if input_str == 'l' : print ( 'Options are:' ) [ print ( file ) for file in os . listdir ( profile_dir )] fname = self . get_new_sequence () else : fname = os . path . abspath ( os . path . join ( profile_dir , input_str )) if not os . path . exists ( fname ): print ( f 'File {fname} does not exist.' ) fname = self . get_new_sequence () else : print ( f 'The next run command (r) will execute this profile: \\n {fname}' ) return fname def wait ( self ): if self . plot_enable : self . router . run_gui_event_loop () return def blink ( self ): ''' Blink all sources. ''' cmd = {} cmd [ 'flasher_cmds' ] = 7 # center, inner ring, outer ring. binary: 111. self . do_hawkeye_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( 'Blink complete.' ) return def do_motor_tasks ( self , cmd : dict ): ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple , run = True ): ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = STEPPER_ORDER angs = [ cmd for cmd in [ motor_cmds [ key ] for key in keys ]] ticks_to_go , err = hw . all_steppers_ez ( self . stepper_ser , [ self . steppers [ key ] for key in keys ], angs , run = run ) # Linear approximation only holds for small distances, so # chunk up big moves into tiny bits. This ensures all cables stay taut, # even when moving to opposite corners. # CHUNK_DIST is a trade-off between smoothly approximating the needed # stepping profiles and the time taken to send many commands over # serial before starting the move. pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS while dist_to_go > const . CHUNK_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position CHUNK_DIST away from the starting pos along # the direction of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + const . CHUNK_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd , run = True ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) # temporary until streaming commands is fixed wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS # Signal ezsteppers to run once we've sent all commands for this move logger . debug ( f 'Final move: {pos_after}' ) send_pos_cmd ( pos_after , run = True ) time . sleep ( wait_time ) return def take_image ( self ): time . sleep ( 1 ) self . positions_visited += 1 cmd = [ 'bash' , '-c' , f '. takeimg.sh {self.positions_visited}' ] ret = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) if ret . returncode == 0 : print ( ret . stdout . decode ()) else : if ret . stdout : print ( ret . stdout . decode ()) if ret . stderr : print ( ret . stderr . decode ()) return def do_hawkeye_tasks ( self , cmd : dict ): packet = { 'Hawkeye Cmd' : { 'Local Time (s)' : time . time (), 'Hawkeye Cmd Byte' : np . array ( cmd [ 'flasher_cmds' ]), } } self . tm_queue . put ( packet ) time . sleep ( const . SETTLE_TIME ) # self.take_image() freq = 10. # switching freq, Hz, i.e. flashing freq is 1/2 this num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . send_hawkeye_byte ( self . hawkeye_ser , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) return def close ( self ): # ensure all hawkeyes are left in off state hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) self . hawkeye_ser . close () # Terminate all running commands time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'TR \\r\\n ' ) # Release torque time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R \\r\\n ' ) hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R \\r\\n ' ) # Restore default baud hw . ezstepper_write ( self . stepper_ser , '_' , 'b9600R \\r\\n ' ) self . stepper_ser . close () return","title":"Attributes"},{"location":"reference/hotspot/executive/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/executive/#add_cmds","text":"def add_cmds ( self , fname : str ) Read command input file and add commands to the command queue. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def add_cmds ( self , fname : str ) : ''' Read command input file and add commands to the command queue. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. ''' logger . info ( f 'Parsing command sequence: {fname}' ) rows = np . genfromtxt ( fname , dtype = None , delimiter = ',' , skip_header = 1 , encoding = 'utf8' ) rows = np . atleast_1d ( rows ) self . sequence_len = len ( rows ) if ( self . sequence_len > const . MAX_QLEN ) : logger . warn ( f 'Input command number {len(rows)} exceeds command' + f ' queue length {const.MAX_QLEN}. Increase' + ' constants.MAX_QLEN.' ) for i in range ( self . sequence_len ) : cmd = {} cmd [ 'flasher_cmds' ] = int ( rows [ i ][ 0 ] ) cmd [ 'pos_cmd' ] = ( rows [ i ][ 1 ] , rows [ i ][ 2 ] ) self . cmd_queue . put ( cmd ) return","title":"add_cmds"},{"location":"reference/hotspot/executive/#blink","text":"def blink ( self ) Blink all sources. View Source def blink ( self ) : '' ' Blink all sources. '' ' cmd = {} cmd [ 'flasher_cmds' ] = 7 # center , inner ring , outer ring . binary : 111 . self . do_hawkeye_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( 'Blink complete.' ) return","title":"blink"},{"location":"reference/hotspot/executive/#cal_home","text":"def cal_home ( self ) Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. View Source def cal_home ( self ) : ''' Moves motors to limits to calibrate the stepper positions. In turn, move each motor to its hard stop and record the encoder position. Assumptions: - All cables are slack, but without excessive cable played out. - Corners form a rectangle. ''' # ought to be smaller than distance stepper bounced back after hitting hard stop coarse_ticks = 5000 coarse_homing_speed = 80000 fine_ticks = 500 fine_homing_speed = coarse_homing_speed # sets the final zero - point length error for each axis ultra_fine_ticks = 5 ultra_fine_homing_speed = coarse_homing_speed # Home each axis axes = [ 'nw', 'ne', 'se', 'sw' ] for current_axis in axes : logger . info ( f 'Homing to {current_axis}' ) # turn off current to axes not being homed resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R\\r\\n' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R\\r\\n' ) logger . info ( 'Coarse homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ] , coarse_ticks , coarse_homing_speed , move_current = 50 , hold_current = 50 ) logger . info ( 'Fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ] , fine_ticks , fine_homing_speed , move_current = 50 , hold_current = 10 ) logger . info ( 'Ultra-fine homing against hard stop.' ) hw . bump_hard_stop ( self . stepper_ser , self . steppers [ current_axis ] , ultra_fine_ticks , ultra_fine_homing_speed , move_current = 100 , hold_current = 10 ) # run to position of hard stop resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ] , ( 'm50' + 'h50' + f 'V{fine_homing_speed}' + f 'D{fine_ticks}' + 'R\\r\\n' ) ) # set cable length zero point time . sleep ( 1 ) hw . wait_for_ready ( self . stepper_ser , self . steppers [ current_axis ] ) resp = hw . ezstepper_write ( self . stepper_ser , self . steppers [ current_axis ] , 'z0R\\r\\n' ) time . sleep ( 1 ) # Check to see that homing operation succeeeded . if hw . get_encoder_pos ( self . stepper_ser , self . steppers [ current_axis ] ) > 20 : logger . critical ( 'Encoder failed to set zero point during homing. Aborting.' ) sys . exit ( 1 ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'm{const.MOVE_CURRENT_PCT}R\\r\\n' ) resp = hw . ezstepper_write ( self . stepper_ser , '_' , f 'h{const.HOLD_CURRENT_PCT}R\\r\\n' ) # Update current encoder position ( used for velocity calc in move to # home pos ) for ax in axes : address = self . steppers [ ax ] hw . wait_for_ready ( self . stepper_ser , address ) actual_ticks = hw . get_encoder_pos ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'z{actual_ticks}R\\r\\n' ) hw . wait_for_ready ( self . stepper_ser , address ) hw . ezstepper_write ( self . stepper_ser , address , f 'A{actual_ticks}R\\r\\n' ) self . robot . raft . position = self . robot . surf . sw + np . array ( [ 0.1, 0.1 ] ) home = ( np . mean ( [ self.robot.surf.ne[0 ] , self . robot . surf . sw [ 0 ] ] ), np . mean ( [ self.robot.surf.ne[1 ] , self . robot . surf . sw [ 1 ] ] ) ) self . robot . home = home self . go_home () logger . info ( f 'Raft is homed with centroid position {self.robot.raft.position}' ) logger . warning ( 'Verify that the raft has been driven to the center of the workspace and all cables are taut. If not, request CAL_HOME again.' ) packet = { 'algorithm' : { 'Local Time (s)' : time . time (), 'Position Command (m)' : home , 'Motor Angle Command (rad)' : np . array ( [ 0. ] * len ( self . steppers . keys ())), } } self . tm_queue . put ( packet ) self . router . process_tm ( plot_enable = self . plot_enable ) return","title":"cal_home"},{"location":"reference/hotspot/executive/#close","text":"def close ( self ) View Source def close ( self ) : # ensure all hawkeyes are left in off state hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) self . hawkeye_ser . close () # Terminate all running commands time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'TR\\r\\n' ) # Release torque time . sleep ( . 1 ) hw . ezstepper_write ( self . stepper_ser , '_' , 'm0R\\r\\n' ) hw . ezstepper_write ( self . stepper_ser , '_' , 'h0R\\r\\n' ) # Restore default baud hw . ezstepper_write ( self . stepper_ser , '_' , 'b9600R\\r\\n' ) self . stepper_ser . close () return","title":"close"},{"location":"reference/hotspot/executive/#do_hawkeye_tasks","text":"def do_hawkeye_tasks ( self , cmd : dict ) View Source def do_hawkeye_tasks ( self , cmd : dict ): packet = { 'Hawkeye Cmd' : { 'Local Time (s)' : time . time (), 'Hawkeye Cmd Byte' : np . array ( cmd [ 'flasher_cmds' ]), } } self . tm_queue . put ( packet ) time . sleep ( const . SETTLE_TIME ) # self.take_image() freq = 10. # switching freq, Hz, i.e. flashing freq is 1/2 this num_blinks = 10 flipflop = 0 while num_blinks > 0 : start_time = time . time () if flipflop : hw . send_hawkeye_byte ( self . hawkeye_ser , cmd [ 'flasher_cmds' ]) num_blinks -= 1 else : hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) flipflop = 1 - flipflop # sleep off remaining time to fudge actions at frequency freq time . sleep (( 1. / freq ) - ( time . time () - start_time )) hw . send_hawkeye_byte ( self . hawkeye_ser , 0 ) return","title":"do_hawkeye_tasks"},{"location":"reference/hotspot/executive/#do_motor_tasks","text":"def do_motor_tasks ( self , cmd : dict ) Transform the move command into motor commands Parameters: Name Type Description Default cmd Command packet dictionary with keys for position commands to pass to control algorithm None View Source def do_motor_tasks ( self , cmd : dict ) : ''' Transform the move command into motor commands Parameters ---------- cmd: Command packet dictionary with keys for position commands to pass to control algorithm ''' def send_pos_cmd ( cmd_tuple : tuple , run = True ) : ''' Helper to send position commands to control algorithm and collect results ''' motor_cmds = self . robot . process_input ( cmd_tuple ) # bootleg OrderedDict keys = STEPPER_ORDER angs = [ cmd for cmd in [motor_cmds[key ] for key in keys ]] ticks_to_go , err = hw . all_steppers_ez ( self . stepper_ser , [ self.steppers[key ] for key in keys ] , angs , run = run ) # Linear approximation only holds for small distances , so # chunk up big moves into tiny bits . This ensures all cables stay taut , # even when moving to opposite corners . # CHUNK_DIST is a trade - off between smoothly approximating the needed # stepping profiles and the time taken to send many commands over # serial before starting the move . pos_before = self . robot . raft . position pos_after = cmd [ 'pos_cmd' ] dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS while dist_to_go > const . CHUNK_DIST : logger . debug ( f 'Dist. to go in this move: {dist_to_go}' ) # determine a position CHUNK_DIST away from the starting pos along # the direction of travel v = np . array ( pos_after ) - np . array ( pos_before ) u = v / np . linalg . norm ( v ) # the unit vector pointing along the line logger . debug ( f 'Direction vector: {v}, Unit vector: {u}' ) pos_cmd = pos_before + const . CHUNK_DIST * u logger . debug ( f 'Intermediate move: {pos_cmd}' ) send_pos_cmd ( pos_cmd , run = True ) # alg updates raft position # calculate new dist to go pos_before = self . robot . raft . position dist_to_go = np . linalg . norm ( np . array ( pos_after ) - np . array ( pos_before )) # temporary until streaming commands is fixed wait_time = dist_to_go * const . ENCODER_TICKS_PER_REV / const . LENGTH_PER_REV / const . MAX_SPEED_TICKS # Signal ezsteppers to run once we 've sent all commands for this move logger.debug(f' Final move : { pos_after }' ) send_pos_cmd ( pos_after , run = True ) time . sleep ( wait_time ) return","title":"do_motor_tasks"},{"location":"reference/hotspot/executive/#empty_queue","text":"def empty_queue ( self , queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f0182295c90 >> ) Completely empty the given Queue object. Parameters: Name Type Description Default queue None Any queue None View Source def empty_queue ( self , queue : mp . Queue ) : '' ' Completely empty the given Queue object. Parameters ---------- queue Any queue '' ' while not queue.empty(): queue.get() return","title":"empty_queue"},{"location":"reference/hotspot/executive/#get_new_sequence","text":"def get_new_sequence ( self ) Prompt the user to input the path to a sequence .csv file to run. Returns: Type Description fname the filename of the new scan profile to run on next 'r' command View Source def get_new_sequence ( self ): ''' Prompt the user to input the path to a sequence .csv file to run. Returns ------- fname the filename of the new scan profile to run on next 'r' command ''' profile_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'input' , 'profiles' ) print ( 'Please input the path to a new profile .csv file to run. ' + f 'Profile sequence files are stored in {profile_dir}. \\n Hit Enter' + ' for the prompt.' ) input_str = input ( 'Type a file path, or type \\' l \\' for a list: ' ) if input_str == 'l' : print ( 'Options are:' ) [ print ( file ) for file in os . listdir ( profile_dir )] fname = self . get_new_sequence () else : fname = os . path . abspath ( os . path . join ( profile_dir , input_str )) if not os . path . exists ( fname ): print ( f 'File {fname} does not exist.' ) fname = self . get_new_sequence () else : print ( f 'The next run command (r) will execute this profile: \\n {fname}' ) return fname","title":"get_new_sequence"},{"location":"reference/hotspot/executive/#go_home","text":"def go_home ( self ) Clear all commands in the queue and drive to the home position. View Source def go_home ( self ) : ''' Clear all commands in the queue and drive to the home position. ''' # If not already home , go there . eps = np . finfo ( float ). eps if not all ( abs ( a - b ) < eps for a , b in zip ( self . robot . raft . position , self . robot . home )) : logger . info ( f 'Clearing command queue and commanding home: {self.robot.home}' ) self . empty_queue ( self . cmd_queue ) cmd = {} cmd [ 'flasher_cmd' ] = 0 cmd [ 'pos_cmd' ] = self . robot . home self . do_motor_tasks ( cmd ) self . router . process_tm ( plot_enable = self . plot_enable ) logger . info ( f 'Home.' ) else : logger . info ( 'Already home, nothing to do.' ) return","title":"go_home"},{"location":"reference/hotspot/executive/#run","text":"def run ( self , fname : str ) Main run function, including processing human input to switch between states. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. None View Source def run ( self , fname : str ) : '' ' Main run function, including processing human input to switch between states. Parameters ---------- fname .csv-formatted file containing a sequence of commands, one per col. Data spec described in docstring of sequence() function. '' ' # Allow user input to change the mode. input_thread = threading.Thread( target=self._get_kbd, args=(self.kbd_queue,), daemon=True ) input_thread.start() print(MENU_STR) # Start off in WAIT mode to await user input. self . mode = 'WAIT' self . last_mode = self . mode running = True while running : try : # Check for user input if not self . kbd_queue . empty () : kbd_in = self . kbd_queue . get_nowait () if 'c' == kbd_in : logger . info ( 'Home calibration requested.' ) self . mode = 'CAL_HOME' elif 'h' == kbd_in : logger . info ( 'Moving to home requested.' ) self . mode = 'HOME' elif 'r' == kbd_in : logger . info ( 'Sequence run requested.' ) self . mode = 'RUN' elif 's' == kbd_in : logger . info ( 'Select sequence requested.' ) self . mode = 'SEL' elif 'w' == kbd_in : logger . info ( 'Wait mode requested.' ) self . mode = 'WAIT' elif 'b' == kbd_in : logger . info ( 'Manual blink mode requested.' ) self . mode = 'BLINK' else : continue if self . mode == 'CAL_HOME' : self . cal_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'HOME' : self . go_home () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'RUN' : self . sequence ( fname ) elif self . mode == 'SEL' : fname = self . get_new_sequence () self . mode = 'WAIT' print ( MENU_STR ) elif self . mode == 'WAIT' : self . wait () elif self . mode == 'BLINK' : self . blink () self . mode = 'WAIT' print ( MENU_STR ) else : pass self . last_mode = self . mode except KeyboardInterrupt : print ( '\\nCaught KeyboardInterrupt, shutting down.' ) running = False self . close () return","title":"run"},{"location":"reference/hotspot/executive/#sequence","text":"def sequence ( self , fname : str ) On each call, pop a new command off of the command queue and dispatch it to motors/Hawkeyes. Parameters: Name Type Description Default fname None .csv-formatted file containing a sequence of commands, one per col: - flasher_cmds: 1 or 0 depending on whether that address is enabled - pos_cmd_0s: 0th element of position command coordinate - pos_cmd_1s: 1st element of position command coordinate None View Source def sequence ( self , fname : str ): ''' On each call , pop a new command off of the command queue and dispatch it to motors / Hawkeyes . Parameters ---------- fname . csv - formatted file containing a sequence of commands , one per col : - flasher_cmds : 1 or 0 depending on whether that address is enabled - pos_cmd_0s : 0 th element of position command coordinate - pos_cmd_1s : 1 st element of position command coordinate ''' # If we are changing to sequence from another mode , ensure we start # fresh if self . mode != self . last_mode : logger . info ( ' Beginning command sequence . ' ) self . empty_queue ( self . cmd_queue ) self . add_cmds ( fname ) self . positions_visited = 0 # Make a new timestamped logfile self . router = tm . DataRouter ( self . tm_queue ) num_remaining = self . cmd_queue . qsize () if num_remaining < 1 : self . mode = ' WAIT ' return else : cmd = self . cmd_queue . get () progress = 100 . * ( 1 + self . sequence_len - num_remaining ) / self . sequence_len # Do motor tasks , then LJ tasks , so IR source tasks happen at the end of each move . self . do_motor_tasks ( cmd ) self . do_hawkeye_tasks ( cmd ) logger . info ( f ' Raft centroid : { self . robot . raft . position } ' ) logger . info ( f ' Command completed . Sequence progress : { progress : .2 f } % ' ) self . router . process_tm ( plot_enable = self . plot_enable ) return","title":"sequence"},{"location":"reference/hotspot/executive/#take_image","text":"def take_image ( self ) View Source def take_image ( self ) : time . sleep ( 1 ) self . positions_visited += 1 cmd = [ 'bash' , '-c' , f '. takeimg.sh {self.positions_visited}' ] ret = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) if ret . returncode == 0 : print ( ret . stdout . decode ()) else : if ret . stdout : print ( ret . stdout . decode ()) if ret . stderr : print ( ret . stderr . decode ()) return","title":"take_image"},{"location":"reference/hotspot/executive/#wait","text":"def wait ( self ) View Source def wait ( self ) : if self . plot_enable : self . router . run_gui_event_loop () return","title":"wait"},{"location":"reference/hotspot/hardware/","text":"Module hotspot.hardware View Source # This file defines the interfaces used to command the hardware . import logging import numpy as np import sys import time import hotspot . constants as const from hotspot . hw_context import StepperSerial , HawkeyeSerial logger = logging . getLogger ( __ name__ ) IDX_READY_BIT = 2 IDX_STATUS_BYTE = 2 NUM_TRAILING_BYTES = 3 # Conventions : # - positive steps / angular rates spin the motor shaft clockwise ( CW ) when # viewed from the rear . # - negative steps / angular rates spin the motor shaft counterclockwise ( CCW ) # when viewed from the rear . # ----------------------------------------------------------------------------- # Helper classes # ----------------------------------------------------------------------------- class CommandBuffer : ''' Handles building a string of commands to send over serial. Continuous movement requires a sequence of carefully orchestrated absolute angle and velocity commands. In order to avoid serial transfer/ ready waiting overhead, it's most efficient to send a long sequence to each stepper controller , and then run them all together . All methods deal in strings , not byte objects . ''' def __init__(self, addresses): ''' Addresses are EZStepper bus addresses , e . g . [ 2 , 1 , 3 , 4 ] ''' self.buffer_map = {address : '' for address in addresses} def put(self, address, command_str): self.buffer_map[address] += command_str logger.debug(f' CommandBuffer : put () { address } : { command_str } -> { self . buffer_map [ address ]} ') def empty(self, address): ''' Use after sending''' self.buffer_map[address] = '' def terminate(self, address): ''' Use before sending''' self.buffer_map[address] += '\\r\\n' def get(self, address): return self.buffer_map[address] # ----------------------------------------------------------------------------- # Stepper functions # ----------------------------------------------------------------------------- def ezstepper_check_status(resp): ''' Compare the status byte from the EZStepper to some common error codes . Parameters ---------- resp bytes , EZStepper response , after throwing away garbage bytes Returns ------- status_good bool , True if response is nonempty and no unusual status byte patterns found ''' status_good = True if resp: # bits 0-3 form an error code: see EZStepper docs status = resp[IDX_STATUS_BYTE] & 0b00001111 else: status = b'' status_good = False if 2 == status: logger.warning(' Bad command error ( illegal command was sent ) ') status_good = False if 5 == status: logger.warning(' Communications Error ( Internal communications error ) ') status_good = False if 9 == status: logger.warning(' Overload error ( Physical system could not keep up with commanded position ) ') status_good = False if 11 == status: logger.warning(' Move not allowed') status_good = False if 15 == status: logger.warning(' Command overflow ( unit was already executing a command when another command was received ) ') status_good = False if status not in [b'', 0, 2, 9, 11, 15]: logger.warning(f' Unrecognized error code { status }. Consult EZStepper documentation . ') return status_good def ezstepper_check_ready(resp): ''' The EZStepper is ready to accept a new command if the ready bit is set . Parameters ---------- resp bytes , EZStepper response , after throwing away garbage bytes Returns ------- bool True if ready bit is set ''' return bool(resp[IDX_READY_BIT] & 0b00100000) def wait_for_ready(ser, address, ready_timeout=10.0): ''' Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper ready_timeout ( optional ) float , time in seconds before deciding the stepper is unresponsive ''' resp = b'' ready = False if ' _ ' != address: # only send a new command if ezstepper not busy start_busywait = time.time() query = (f'/ { address } Q \\r\\n').encode() while not ready and (time.time() - start_busywait) < ready_timeout: ser.write(query) line = ser.readline() if line: resp = look_for_response(line) logger.debug(f' Ready response : { resp } ') if resp: ready = ezstepper_check_ready(resp) status_good = ezstepper_check_status(resp) logger.debug(f' Waited { time . time () - start_busywait : .4 f } sec for ready signal') if not ready: logger.warning(f' EZStepper { address } was not ready in allotted time { ready_timeout } sec') return def look_for_response(resp): ''' Responses addressed to the controller node begin with / 0 , with possible junk before . Parameters ---------- resp bytes , EZStepper response , straight out of serial Returns ------- resp Any bytes after / 0 ''' if (b' / 0' in resp ) and ( b'\\x03' in resp ) : resp = resp [ resp . find ( b'/0' ) : ] else : resp = b'' return resp def ezstepper_write ( ser : StepperSerial , address , command_str : str ) : ''' Builds a serial command to send to EZStepper(s), checks status bytes in response, and returns response bytes. Parameters ---------- ser pyserial instance, the port to send bytes over from address str, address of ezstepper command_str string, chars to send over EZStepper bus Returns ------- resp bytes, serial response from EZStepper Example: ``` ezstepper.write(ser, 1, ' A1000R \\r\\n') ezstepper.write(ser, ' _ ', ' A12000 \\r\\n') ezstepper.write(ser, ' _ ', ' R \\r\\n') ``` ''' ser . write (( f'/{address}' + command_str ). encode ()) logger . debug ( 'EZStepper cmd: {}' . format (( f'/{address}' + command_str ). rstrip ( '\\r\\n' ))) # we do not anticipate a response from \"all call\" commands . if '_' == address : resp = b'' else : resp = look_for_response ( ser . readline ()) status_good = ezstepper_check_status ( resp ) logger . debug ( 'EZStepper response: {}' . format ( resp . rstrip ( b'\\r\\n' ))) return resp def get_encoder_pos ( ser : StepperSerial , address ) : ''' Gets EZStepper's encoder counts in terms of ticks . It is critical for accurate operation that this call succeeds , so the program will exit if it fails . Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper Returns ------- ticks Number of encoder ticks counted by encoder . A 10000 line encoder has 4 * 10000 = 40000 lines per revolution . ''' ticks = 0 resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries = 10 while not resp and retries > 0: resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries -= 1 logger.warning(f' Encoder { address } was slow to respond . Retrying , { retries } remaining . ') retries = 10 while not ezstepper_check_status(resp) and retries > 0: retries -= 1 logger.warning(f' Encoder { address } status was bad : { resp }. Retrying , { retries } remaining . ') if retries < 0: logger.critical(f' Encoder { address } status bad : { resp }. Is EZStepper / encoder connected ? ') sys.exit(1) else: payload = resp[IDX_STATUS_BYTE+1:-NUM_TRAILING_BYTES] logger.debug(f' Encoder reading : { payload } ') if payload: ticks = int(payload.decode('utf - 8 ')) else: logger.critical(f' Encoder { address } didn\\'t respond.' ) sys . exit ( 1 ) return ticks def bump_hard_stop ( ser : StepperSerial , address : int , ticks : int , speed : int , hold_current = 50 , move_current = 50 ) : ''' Run the motor backward until it can't anymore . Parameters ---------- ser pyserial instance , the port to send bytes over from address ezstepper selector switch number to send command to ticks encoder ticks to move on each trial while searching for hard stop speed encoder ticks per second hold_current ( optional ) target current , % of 2 A limit for motor when stationary move_current ( optional ) target current , % of 2 A limit for motor when moving Returns ------- prev_ticks The last encoder position before the hard stop was hit ''' max_tries = 10000 # may take several moves to hit a hard stop tries = 0 prev_ticks = 800000 # more ticks than we have total available cable curr_ticks = prev_ticks - 1 while ((curr_ticks < prev_ticks) and (tries < max_tries)): prev_ticks = curr_ticks wait_for_ready(ser, address) resp = ezstepper_write( ser, address, ( f'm { move_current } ' + f'h { hold_current } ' + f' V { speed } ' + f' D { ticks } ' + ' R \\r\\n' ) ) curr_ticks = get_encoder_pos(ser, address) tries += 1 return prev_ticks def all_steppers_ez(ser: StepperSerial, addresses: list, radians: list, run=True): ''' Send serial commands to AllMotion EZHR17EN driver boards . Driver boards should already be in position - correction mode , so will take encoder ticks as commands . The driver boards handle achieving the requested absolute position . Commands in radians are converted to encoder ticks and sent to driver boards in order , based on their addresses [ 1 , 2 , 3 , 4 ]. Parameters ---------- ser pyserial instance , the port to send bytes over from addresses iterable of addresses e . g . [ 1 , 2 , 3 , 4 ] to route commands to radians iterable of signed angle to move each stepper to ( radians ) run ( optional ) If True , execute EZStepper command buffer after adding to it . Returns ------- ticks_to_go iterable of integers reporting the number of encoder ticks moved by each stepper err iterable of rounding errors incurred by converting radians to encoder ticks ''' # Get the current absolute encoder position current_ticks_raw = [get_encoder_pos(ser, address) for address in addresses] current_ticks = current_ticks_raw logger.debug(f' Current encoder positions before move : { current_ticks } ') # Get the final absolute position radians = np.array(radians) ticks_float = radians * const.DEG_PER_RAD / const.DEG_PER_STEP / const.STEP_PER_TICK ticks_int = np.round(ticks_float).astype(int) ticks_to_go = np.round(ticks_float - current_ticks).astype(int) err = (ticks_float - current_ticks) - ticks_to_go logger.debug(f' Commanded encoder positions : { ticks_int } ') logger.debug(f' Delta encoder positions : { ticks_to_go } ') if any([tick_int < 0 for tick_int in ticks_int]): logger.warning(f' Move command past hard stop detected : { addresses } : { ticks_int } ') # Set the velocity of each motor such that they arrive at the final # position at the same time. # The motor with the longest move moves at the maximum velocity. max_ticks = np.max(np.abs(ticks_to_go)) t_move = max(max_ticks / const.MAX_SPEED_TICKS, 1e-9) vels = np.round(np.abs(ticks_to_go) / t_move).astype(int) logger.debug(f' Motor speeds : { vels } ticks / sec') for i in range(len(ticks_to_go)): if (ticks_to_go[i] and vels[i]): # Set velocity and command absolute encoder ticks wait_for_ready(ser, addresses[i]) resp = ezstepper_write( ser, addresses[i], ( f' V { vels [ i ]} ' + f' A { ticks_int [ i ]} ' + '\\r\\n' ) ) # Execute buffered move commands for all addresses if run: ezstepper_write(ser, ' _ ', ' R \\r\\n') return ticks_to_go, err # ----------------------------------------------------------------------------- # Hawkeye functions # ----------------------------------------------------------------------------- def send_hawkeye_byte(ser: HawkeyeSerial, data: int): ''' Control three groups of Hawkeye IR sources on the raft . Each of the first three bits of the ` data ` byte turns on one of the three available groups of Hawkeyes on the raft : center , inner ring , and outer ring . The byte is sent over serial to a microcontroller , which forwards the byte to a shift register on the raft via SPI . For example : - data = 1 -> 001 -> center Hawkeye only - data = 2 -> 010 -> inner ring only - data = 3 -> 011 -> center and inner - data = 7 -> 111 -> center , inner , outer Parameters ---------- ser pyserial instance , the port to send byte over from data ( int ) integer whose binary representation will appear at the shift register outputs on the raft ''' assert isinstance(data, int) if data > 255: data = 255 if data < 0: data = 0 ser.write(f' { data } \\r\\n ' . encode ()) return Variables IDX_READY_BIT IDX_STATUS_BYTE NUM_TRAILING_BYTES logger Functions all_steppers_ez def all_steppers_ez ( ser : hotspot . hw_context . DummySerial , addresses : list , radians : list , run = True ) Send serial commands to AllMotion EZHR17EN driver boards. Driver boards should already be in position-correction mode, so will take encoder ticks as commands. The driver boards handle achieving the requested absolute position. Commands in radians are converted to encoder ticks and sent to driver boards in order, based on their addresses [1,2,3,4]. Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None addresses None iterable of addresses e.g. [1,2,3,4] to route commands to None radians None iterable of signed angle to move each stepper to (radians) None run (optional) None If True, execute EZStepper command buffer after adding to it. None Returns: Type Description ticks_to_go iterable of integers reporting the number of encoder ticks moved by each stepper View Source def all_steppers_ez ( ser : StepperSerial , addresses : list , radians : list , run = True ) : ''' Send serial commands to AllMotion EZHR17EN driver boards. Driver boards should already be in position-correction mode, so will take encoder ticks as commands. The driver boards handle achieving the requested absolute position. Commands in radians are converted to encoder ticks and sent to driver boards in order, based on their addresses [1,2,3,4]. Parameters ---------- ser pyserial instance, the port to send bytes over from addresses iterable of addresses e.g. [1,2,3,4] to route commands to radians iterable of signed angle to move each stepper to (radians) run (optional) If True, execute EZStepper command buffer after adding to it. Returns ------- ticks_to_go iterable of integers reporting the number of encoder ticks moved by each stepper err iterable of rounding errors incurred by converting radians to encoder ticks ''' # Get the current absolute encoder position current_ticks_raw = [ get_encoder_pos(ser, address) for address in addresses ] current_ticks = current_ticks_raw logger . debug ( f 'Current encoder positions before move: {current_ticks}' ) # Get the final absolute position radians = np . array ( radians ) ticks_float = radians * const . DEG_PER_RAD / const . DEG_PER_STEP / const . STEP_PER_TICK ticks_int = np . round ( ticks_float ). astype ( int ) ticks_to_go = np . round ( ticks_float - current_ticks ). astype ( int ) err = ( ticks_float - current_ticks ) - ticks_to_go logger . debug ( f 'Commanded encoder positions: {ticks_int}' ) logger . debug ( f 'Delta encoder positions: {ticks_to_go}' ) if any ( [ tick_int < 0 for tick_int in ticks_int ] ) : logger . warning ( f 'Move command past hard stop detected: {addresses} : {ticks_int}' ) # Set the velocity of each motor such that they arrive at the final # position at the same time . # The motor with the longest move moves at the maximum velocity . max_ticks = np . max ( np . abs ( ticks_to_go )) t_move = max ( max_ticks / const . MAX_SPEED_TICKS , 1e-9 ) vels = np . round ( np . abs ( ticks_to_go ) / t_move ). astype ( int ) logger . debug ( f 'Motor speeds: {vels} ticks / sec' ) for i in range ( len ( ticks_to_go )) : if ( ticks_to_go [ i ] and vels [ i ] ) : # Set velocity and command absolute encoder ticks wait_for_ready ( ser , addresses [ i ] ) resp = ezstepper_write ( ser , addresses [ i ] , ( f 'V{vels[i]}' + f 'A{ticks_int[i]}' + '\\r\\n' ) ) # Execute buffered move commands for all addresses if run : ezstepper_write ( ser , '_' , 'R\\r\\n' ) return ticks_to_go , err bump_hard_stop def bump_hard_stop ( ser : hotspot . hw_context . DummySerial , address : int , ticks : int , speed : int , hold_current = 50 , move_current = 50 ) Run the motor backward until it can't anymore. Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None address None ezstepper selector switch number to send command to None ticks None encoder ticks to move on each trial while searching for hard stop None speed None encoder ticks per second None hold_current (optional) None target current, % of 2 A limit for motor when stationary None move_current (optional) None target current, % of 2 A limit for motor when moving None Returns: Type Description prev_ticks The last encoder position before the hard stop was hit View Source def bump_hard_stop ( ser : StepperSerial , address : int , ticks : int , speed : int , hold_current = 50 , move_current = 50 ): ''' Run the motor backward until it can ' t anymore . Parameters ---------- ser pyserial instance , the port to send bytes over from address ezstepper selector switch number to send command to ticks encoder ticks to move on each trial while searching for hard stop speed encoder ticks per second hold_current ( optional ) target current , % of 2 A limit for motor when stationary move_current ( optional ) target current , % of 2 A limit for motor when moving Returns ------- prev_ticks The last encoder position before the hard stop was hit ''' max_tries = 10000 # may take several moves to hit a hard stop tries = 0 prev_ticks = 800000 # more ticks than we have total available cable curr_ticks = prev_ticks - 1 while (( curr_ticks < prev_ticks ) and ( tries < max_tries )): prev_ticks = curr_ticks wait_for_ready ( ser , address ) resp = ezstepper_write ( ser , address , ( f ' m { move_current } ' + f ' h { hold_current } ' + f ' V { speed } ' + f ' D { ticks } ' + ' R \\ r \\ n ' ) ) curr_ticks = get_encoder_pos ( ser , address ) tries += 1 return prev_ticks ezstepper_check_ready def ezstepper_check_ready ( resp ) The EZStepper is ready to accept a new command if the ready bit is set. Parameters: Name Type Description Default resp None bytes, EZStepper response, after throwing away garbage bytes None Returns: Type Description bool True if ready bit is set View Source def ezstepper_check_ready ( resp ) : ''' The EZStepper is ready to accept a new command if the ready bit is set. Parameters ---------- resp bytes, EZStepper response, after throwing away garbage bytes Returns ------- bool True if ready bit is set ''' return bool ( resp [ IDX_READY_BIT ] & 0 b00100000 ) ezstepper_check_status def ezstepper_check_status ( resp ) Compare the status byte from the EZStepper to some common error codes. Parameters: Name Type Description Default resp None bytes, EZStepper response, after throwing away garbage bytes None Returns: Type Description status_good bool, True if response is nonempty and no unusual status byte patterns found View Source def ezstepper_check_status ( resp ) : ''' Compare the status byte from the EZStepper to some common error codes. Parameters ---------- resp bytes, EZStepper response, after throwing away garbage bytes Returns ------- status_good bool, True if response is nonempty and no unusual status byte patterns found ''' status_good = True if resp : # bits 0 - 3 form an error code : see EZStepper docs status = resp [ IDX_STATUS_BYTE ] & 0 b00001111 else : status = b '' status_good = False if 2 == status : logger . warning ( 'Bad command error (illegal command was sent)' ) status_good = False if 5 == status : logger . warning ( 'Communications Error (Internal communications error)' ) status_good = False if 9 == status : logger . warning ( 'Overload error (Physical system could not keep up with commanded position)' ) status_good = False if 11 == status : logger . warning ( 'Move not allowed' ) status_good = False if 15 == status : logger . warning ( 'Command overflow (unit was already executing a command when another command was received)' ) status_good = False if status not in [ b'', 0, 2, 9, 11, 15 ] : logger . warning ( f 'Unrecognized error code {status}. Consult EZStepper documentation.' ) return status_good ezstepper_write def ezstepper_write ( ser : hotspot . hw_context . DummySerial , address , command_str : str ) Builds a serial command to send to EZStepper(s), checks status bytes in response, and returns response bytes. Parameters ---------- ser pyserial instance, the port to send bytes over from address str, address of ezstepper command_str string, chars to send over EZStepper bus Returns ------- resp bytes, serial response from EZStepper Example: ``` ezstepper.write(ser, 1, 'A1000R ') ezstepper.write(ser, ' ', 'A12000 ') ezstepper.write(ser, ' ', 'R ') ``` View Source def ezstepper_write ( ser : StepperSerial , address , command_str : str ): ''' Builds a serial command to send to EZStepper ( s ), checks status bytes in response , and returns response bytes . Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper command_str string , chars to send over EZStepper bus Returns ------- resp bytes , serial response from EZStepper Example : ``` ezstepper . write ( ser , 1 , ' A1000R \\ r \\ n ' ) ezstepper . write ( ser , '_' , ' A12000 \\ r \\ n ' ) ezstepper . write ( ser , '_' , ' R \\ r \\ n ' ) ``` ''' ser . write (( f ' / { address } ' + command_str ). encode ()) logger . debug ( ' EZStepper cmd : {} ' . format (( f ' / { address } ' + command_str ). rstrip ( '\\ r \\ n ' ))) # we do not anticipate a response from \"all call\" commands . if '_' == address : resp = b '' else : resp = look_for_response ( ser . readline ()) status_good = ezstepper_check_status ( resp ) logger . debug ( ' EZStepper response : {} ' . format ( resp . rstrip ( b '\\ r \\ n ' ))) return resp get_encoder_pos def get_encoder_pos ( ser : hotspot . hw_context . DummySerial , address ) Gets EZStepper's encoder counts in terms of ticks. It is critical for accurate operation that this call succeeds, so the program will exit if it fails. Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None address None str, address of ezstepper None Returns: Type Description ticks Number of encoder ticks counted by encoder. A 10000 line encoder has 4 * 10000 = 40000 lines per revolution. View Source def get_encoder_pos ( ser : StepperSerial , address ) : ''' Gets EZStepper's encoder counts in terms of ticks . It is critical for accurate operation that this call succeeds , so the program will exit if it fails . Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper Returns ------- ticks Number of encoder ticks counted by encoder . A 10000 line encoder has 4 * 10000 = 40000 lines per revolution . ''' ticks = 0 resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries = 10 while not resp and retries > 0: resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries -= 1 logger.warning(f' Encoder { address } was slow to respond . Retrying , { retries } remaining . ') retries = 10 while not ezstepper_check_status(resp) and retries > 0: retries -= 1 logger.warning(f' Encoder { address } status was bad : { resp }. Retrying , { retries } remaining . ') if retries < 0: logger.critical(f' Encoder { address } status bad : { resp }. Is EZStepper / encoder connected ? ') sys.exit(1) else: payload = resp[IDX_STATUS_BYTE+1:-NUM_TRAILING_BYTES] logger.debug(f' Encoder reading : { payload } ') if payload: ticks = int(payload.decode('utf - 8 ')) else: logger.critical(f' Encoder { address } didn\\'t respond.' ) sys . exit ( 1 ) return ticks look_for_response def look_for_response ( resp ) Responses addressed to the controller node begin with /0, with possible junk before. Parameters: Name Type Description Default resp None bytes, EZStepper response, straight out of serial None Returns: Type Description resp Any bytes after /0 View Source def look_for_response ( resp ): ''' Responses addressed to the controller node begin with / 0 , with possible junk before . Parameters ---------- resp bytes , EZStepper response , straight out of serial Returns ------- resp Any bytes after / 0 ''' if ( b ' / 0 ' in resp ) and ( b '\\ x03 ' in resp ): resp = resp [ resp . find ( b ' / 0 ' ):] else : resp = b '' return resp send_hawkeye_byte def send_hawkeye_byte ( ser : hotspot . hw_context . DummySerial , data : int ) Control three groups of Hawkeye IR sources on the raft. Each of the first three bits of the data byte turns on one of the three available groups of Hawkeyes on the raft: center, inner ring, and outer ring. The byte is sent over serial to a microcontroller, which forwards the byte to a shift register on the raft via SPI. For example: - data = 1 -> 001 -> center Hawkeye only - data = 2 -> 010 -> inner ring only - data = 3 -> 011 -> center and inner - data = 7 -> 111 -> center, inner, outer Parameters: Name Type Description Default ser None pyserial instance, the port to send byte over from None data (int) None integer whose binary representation will appear at the shift register outputs on the raft None View Source def send_hawkeye_byte ( ser : HawkeyeSerial , data : int ) : ' '' Control three groups of Hawkeye IR sources on the raft. Each of the first three bits of the `data` byte turns on one of the three available groups of Hawkeyes on the raft: center, inner ring, and outer ring. The byte is sent over serial to a microcontroller, which forwards the byte to a shift register on the raft via SPI. For example: - data = 1 -> 001 -> center Hawkeye only - data = 2 -> 010 -> inner ring only - data = 3 -> 011 -> center and inner - data = 7 -> 111 -> center, inner, outer Parameters ---------- ser pyserial instance, the port to send byte over from data (int) integer whose binary representation will appear at the shift register outputs on the raft '' ' assert isinstance ( data , int ) if data > 255 : data = 255 if data < 0 : data = 0 ser . write ( f '{data} \\r\\n ' . encode ()) return wait_for_ready def wait_for_ready ( ser , address , ready_timeout = 10.0 ) Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None address None str, address of ezstepper None ready_timeout (optional) None float, time in seconds before deciding the stepper is unresponsive None View Source def wait_for_ready ( ser , address , ready_timeout = 10.0 ): ''' Parameters ---------- ser pyserial instance, the port to send bytes over from address str, address of ezstepper ready_timeout (optional) float, time in seconds before deciding the stepper is unresponsive ''' resp = b '' ready = False if '_' != address : # only send a new command if ezstepper not busy start_busywait = time . time () query = ( f '/{address}Q \\r\\n ' ) . encode () while not ready and ( time . time () - start_busywait ) < ready_timeout : ser . write ( query ) line = ser . readline () if line : resp = look_for_response ( line ) logger . debug ( f 'Ready response: {resp}' ) if resp : ready = ezstepper_check_ready ( resp ) status_good = ezstepper_check_status ( resp ) logger . debug ( f 'Waited {time.time() - start_busywait:.4f} sec for ready signal' ) if not ready : logger . warning ( f 'EZStepper {address} was not ready in allotted time {ready_timeout} sec' ) return Classes CommandBuffer class CommandBuffer ( addresses ) Handles building a string of commands to send over serial. Continuous movement requires a sequence of carefully orchestrated absolute angle and velocity commands. In order to avoid serial transfer/ ready waiting overhead, it's most efficient to send a long sequence to each stepper controller, and then run them all together. All methods deal in strings, not byte objects. View Source class CommandBuffer : ''' Handles building a string of commands to send over serial. Continuous movement requires a sequence of carefully orchestrated absolute angle and velocity commands. In order to avoid serial transfer/ ready waiting overhead, it' s most efficient to send a long sequence to each stepper controller , and then run them all together . All methods deal in strings , not byte objects . ''' def __init__(self, addresses): ''' Addresses are EZStepper bus addresses , e . g . [ 2,1,3,4 ] ''' self.buffer_map = {address : '' for address in addresses} def put(self, address, command_str): self.buffer_map[address] += command_str logger.debug(f' CommandBuffer : put () { address }: { command_str } -> { self . buffer_map [ address ] } ') def empty(self, address): ''' Use after sending ''' self.buffer_map[address] = '' def terminate(self, address): ''' Use before sending ''' self.buffer_map[address] += ' \\ r \\ n ' def get ( self , address ) : return self . buffer_map [ address ] Methods empty def empty ( self , address ) Use after sending View Source def empty ( self , address ) : '''Use after sending''' self . buffer_map [ address ] = '' get def get ( self , address ) View Source def get ( self , address ) : return self . buffer_map [ address ] put def put ( self , address , command_str ) View Source def put ( self , address , command_str ) : self . buffer_map [ address ] += command_str logger . debug ( f 'CommandBuffer:put() {address}: {command_str} -> {self.buffer_map[address]}' ) terminate def terminate ( self , address ) Use before sending View Source def terminate ( self , address ) : '''Use before sending''' self . buffer_map [ address ] += '\\r\\n'","title":"Hardware"},{"location":"reference/hotspot/hardware/#module-hotspothardware","text":"View Source # This file defines the interfaces used to command the hardware . import logging import numpy as np import sys import time import hotspot . constants as const from hotspot . hw_context import StepperSerial , HawkeyeSerial logger = logging . getLogger ( __ name__ ) IDX_READY_BIT = 2 IDX_STATUS_BYTE = 2 NUM_TRAILING_BYTES = 3 # Conventions : # - positive steps / angular rates spin the motor shaft clockwise ( CW ) when # viewed from the rear . # - negative steps / angular rates spin the motor shaft counterclockwise ( CCW ) # when viewed from the rear . # ----------------------------------------------------------------------------- # Helper classes # ----------------------------------------------------------------------------- class CommandBuffer : ''' Handles building a string of commands to send over serial. Continuous movement requires a sequence of carefully orchestrated absolute angle and velocity commands. In order to avoid serial transfer/ ready waiting overhead, it's most efficient to send a long sequence to each stepper controller , and then run them all together . All methods deal in strings , not byte objects . ''' def __init__(self, addresses): ''' Addresses are EZStepper bus addresses , e . g . [ 2 , 1 , 3 , 4 ] ''' self.buffer_map = {address : '' for address in addresses} def put(self, address, command_str): self.buffer_map[address] += command_str logger.debug(f' CommandBuffer : put () { address } : { command_str } -> { self . buffer_map [ address ]} ') def empty(self, address): ''' Use after sending''' self.buffer_map[address] = '' def terminate(self, address): ''' Use before sending''' self.buffer_map[address] += '\\r\\n' def get(self, address): return self.buffer_map[address] # ----------------------------------------------------------------------------- # Stepper functions # ----------------------------------------------------------------------------- def ezstepper_check_status(resp): ''' Compare the status byte from the EZStepper to some common error codes . Parameters ---------- resp bytes , EZStepper response , after throwing away garbage bytes Returns ------- status_good bool , True if response is nonempty and no unusual status byte patterns found ''' status_good = True if resp: # bits 0-3 form an error code: see EZStepper docs status = resp[IDX_STATUS_BYTE] & 0b00001111 else: status = b'' status_good = False if 2 == status: logger.warning(' Bad command error ( illegal command was sent ) ') status_good = False if 5 == status: logger.warning(' Communications Error ( Internal communications error ) ') status_good = False if 9 == status: logger.warning(' Overload error ( Physical system could not keep up with commanded position ) ') status_good = False if 11 == status: logger.warning(' Move not allowed') status_good = False if 15 == status: logger.warning(' Command overflow ( unit was already executing a command when another command was received ) ') status_good = False if status not in [b'', 0, 2, 9, 11, 15]: logger.warning(f' Unrecognized error code { status }. Consult EZStepper documentation . ') return status_good def ezstepper_check_ready(resp): ''' The EZStepper is ready to accept a new command if the ready bit is set . Parameters ---------- resp bytes , EZStepper response , after throwing away garbage bytes Returns ------- bool True if ready bit is set ''' return bool(resp[IDX_READY_BIT] & 0b00100000) def wait_for_ready(ser, address, ready_timeout=10.0): ''' Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper ready_timeout ( optional ) float , time in seconds before deciding the stepper is unresponsive ''' resp = b'' ready = False if ' _ ' != address: # only send a new command if ezstepper not busy start_busywait = time.time() query = (f'/ { address } Q \\r\\n').encode() while not ready and (time.time() - start_busywait) < ready_timeout: ser.write(query) line = ser.readline() if line: resp = look_for_response(line) logger.debug(f' Ready response : { resp } ') if resp: ready = ezstepper_check_ready(resp) status_good = ezstepper_check_status(resp) logger.debug(f' Waited { time . time () - start_busywait : .4 f } sec for ready signal') if not ready: logger.warning(f' EZStepper { address } was not ready in allotted time { ready_timeout } sec') return def look_for_response(resp): ''' Responses addressed to the controller node begin with / 0 , with possible junk before . Parameters ---------- resp bytes , EZStepper response , straight out of serial Returns ------- resp Any bytes after / 0 ''' if (b' / 0' in resp ) and ( b'\\x03' in resp ) : resp = resp [ resp . find ( b'/0' ) : ] else : resp = b'' return resp def ezstepper_write ( ser : StepperSerial , address , command_str : str ) : ''' Builds a serial command to send to EZStepper(s), checks status bytes in response, and returns response bytes. Parameters ---------- ser pyserial instance, the port to send bytes over from address str, address of ezstepper command_str string, chars to send over EZStepper bus Returns ------- resp bytes, serial response from EZStepper Example: ``` ezstepper.write(ser, 1, ' A1000R \\r\\n') ezstepper.write(ser, ' _ ', ' A12000 \\r\\n') ezstepper.write(ser, ' _ ', ' R \\r\\n') ``` ''' ser . write (( f'/{address}' + command_str ). encode ()) logger . debug ( 'EZStepper cmd: {}' . format (( f'/{address}' + command_str ). rstrip ( '\\r\\n' ))) # we do not anticipate a response from \"all call\" commands . if '_' == address : resp = b'' else : resp = look_for_response ( ser . readline ()) status_good = ezstepper_check_status ( resp ) logger . debug ( 'EZStepper response: {}' . format ( resp . rstrip ( b'\\r\\n' ))) return resp def get_encoder_pos ( ser : StepperSerial , address ) : ''' Gets EZStepper's encoder counts in terms of ticks . It is critical for accurate operation that this call succeeds , so the program will exit if it fails . Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper Returns ------- ticks Number of encoder ticks counted by encoder . A 10000 line encoder has 4 * 10000 = 40000 lines per revolution . ''' ticks = 0 resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries = 10 while not resp and retries > 0: resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries -= 1 logger.warning(f' Encoder { address } was slow to respond . Retrying , { retries } remaining . ') retries = 10 while not ezstepper_check_status(resp) and retries > 0: retries -= 1 logger.warning(f' Encoder { address } status was bad : { resp }. Retrying , { retries } remaining . ') if retries < 0: logger.critical(f' Encoder { address } status bad : { resp }. Is EZStepper / encoder connected ? ') sys.exit(1) else: payload = resp[IDX_STATUS_BYTE+1:-NUM_TRAILING_BYTES] logger.debug(f' Encoder reading : { payload } ') if payload: ticks = int(payload.decode('utf - 8 ')) else: logger.critical(f' Encoder { address } didn\\'t respond.' ) sys . exit ( 1 ) return ticks def bump_hard_stop ( ser : StepperSerial , address : int , ticks : int , speed : int , hold_current = 50 , move_current = 50 ) : ''' Run the motor backward until it can't anymore . Parameters ---------- ser pyserial instance , the port to send bytes over from address ezstepper selector switch number to send command to ticks encoder ticks to move on each trial while searching for hard stop speed encoder ticks per second hold_current ( optional ) target current , % of 2 A limit for motor when stationary move_current ( optional ) target current , % of 2 A limit for motor when moving Returns ------- prev_ticks The last encoder position before the hard stop was hit ''' max_tries = 10000 # may take several moves to hit a hard stop tries = 0 prev_ticks = 800000 # more ticks than we have total available cable curr_ticks = prev_ticks - 1 while ((curr_ticks < prev_ticks) and (tries < max_tries)): prev_ticks = curr_ticks wait_for_ready(ser, address) resp = ezstepper_write( ser, address, ( f'm { move_current } ' + f'h { hold_current } ' + f' V { speed } ' + f' D { ticks } ' + ' R \\r\\n' ) ) curr_ticks = get_encoder_pos(ser, address) tries += 1 return prev_ticks def all_steppers_ez(ser: StepperSerial, addresses: list, radians: list, run=True): ''' Send serial commands to AllMotion EZHR17EN driver boards . Driver boards should already be in position - correction mode , so will take encoder ticks as commands . The driver boards handle achieving the requested absolute position . Commands in radians are converted to encoder ticks and sent to driver boards in order , based on their addresses [ 1 , 2 , 3 , 4 ]. Parameters ---------- ser pyserial instance , the port to send bytes over from addresses iterable of addresses e . g . [ 1 , 2 , 3 , 4 ] to route commands to radians iterable of signed angle to move each stepper to ( radians ) run ( optional ) If True , execute EZStepper command buffer after adding to it . Returns ------- ticks_to_go iterable of integers reporting the number of encoder ticks moved by each stepper err iterable of rounding errors incurred by converting radians to encoder ticks ''' # Get the current absolute encoder position current_ticks_raw = [get_encoder_pos(ser, address) for address in addresses] current_ticks = current_ticks_raw logger.debug(f' Current encoder positions before move : { current_ticks } ') # Get the final absolute position radians = np.array(radians) ticks_float = radians * const.DEG_PER_RAD / const.DEG_PER_STEP / const.STEP_PER_TICK ticks_int = np.round(ticks_float).astype(int) ticks_to_go = np.round(ticks_float - current_ticks).astype(int) err = (ticks_float - current_ticks) - ticks_to_go logger.debug(f' Commanded encoder positions : { ticks_int } ') logger.debug(f' Delta encoder positions : { ticks_to_go } ') if any([tick_int < 0 for tick_int in ticks_int]): logger.warning(f' Move command past hard stop detected : { addresses } : { ticks_int } ') # Set the velocity of each motor such that they arrive at the final # position at the same time. # The motor with the longest move moves at the maximum velocity. max_ticks = np.max(np.abs(ticks_to_go)) t_move = max(max_ticks / const.MAX_SPEED_TICKS, 1e-9) vels = np.round(np.abs(ticks_to_go) / t_move).astype(int) logger.debug(f' Motor speeds : { vels } ticks / sec') for i in range(len(ticks_to_go)): if (ticks_to_go[i] and vels[i]): # Set velocity and command absolute encoder ticks wait_for_ready(ser, addresses[i]) resp = ezstepper_write( ser, addresses[i], ( f' V { vels [ i ]} ' + f' A { ticks_int [ i ]} ' + '\\r\\n' ) ) # Execute buffered move commands for all addresses if run: ezstepper_write(ser, ' _ ', ' R \\r\\n') return ticks_to_go, err # ----------------------------------------------------------------------------- # Hawkeye functions # ----------------------------------------------------------------------------- def send_hawkeye_byte(ser: HawkeyeSerial, data: int): ''' Control three groups of Hawkeye IR sources on the raft . Each of the first three bits of the ` data ` byte turns on one of the three available groups of Hawkeyes on the raft : center , inner ring , and outer ring . The byte is sent over serial to a microcontroller , which forwards the byte to a shift register on the raft via SPI . For example : - data = 1 -> 001 -> center Hawkeye only - data = 2 -> 010 -> inner ring only - data = 3 -> 011 -> center and inner - data = 7 -> 111 -> center , inner , outer Parameters ---------- ser pyserial instance , the port to send byte over from data ( int ) integer whose binary representation will appear at the shift register outputs on the raft ''' assert isinstance(data, int) if data > 255: data = 255 if data < 0: data = 0 ser.write(f' { data } \\r\\n ' . encode ()) return","title":"Module hotspot.hardware"},{"location":"reference/hotspot/hardware/#variables","text":"IDX_READY_BIT IDX_STATUS_BYTE NUM_TRAILING_BYTES logger","title":"Variables"},{"location":"reference/hotspot/hardware/#functions","text":"","title":"Functions"},{"location":"reference/hotspot/hardware/#all_steppers_ez","text":"def all_steppers_ez ( ser : hotspot . hw_context . DummySerial , addresses : list , radians : list , run = True ) Send serial commands to AllMotion EZHR17EN driver boards. Driver boards should already be in position-correction mode, so will take encoder ticks as commands. The driver boards handle achieving the requested absolute position. Commands in radians are converted to encoder ticks and sent to driver boards in order, based on their addresses [1,2,3,4]. Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None addresses None iterable of addresses e.g. [1,2,3,4] to route commands to None radians None iterable of signed angle to move each stepper to (radians) None run (optional) None If True, execute EZStepper command buffer after adding to it. None Returns: Type Description ticks_to_go iterable of integers reporting the number of encoder ticks moved by each stepper View Source def all_steppers_ez ( ser : StepperSerial , addresses : list , radians : list , run = True ) : ''' Send serial commands to AllMotion EZHR17EN driver boards. Driver boards should already be in position-correction mode, so will take encoder ticks as commands. The driver boards handle achieving the requested absolute position. Commands in radians are converted to encoder ticks and sent to driver boards in order, based on their addresses [1,2,3,4]. Parameters ---------- ser pyserial instance, the port to send bytes over from addresses iterable of addresses e.g. [1,2,3,4] to route commands to radians iterable of signed angle to move each stepper to (radians) run (optional) If True, execute EZStepper command buffer after adding to it. Returns ------- ticks_to_go iterable of integers reporting the number of encoder ticks moved by each stepper err iterable of rounding errors incurred by converting radians to encoder ticks ''' # Get the current absolute encoder position current_ticks_raw = [ get_encoder_pos(ser, address) for address in addresses ] current_ticks = current_ticks_raw logger . debug ( f 'Current encoder positions before move: {current_ticks}' ) # Get the final absolute position radians = np . array ( radians ) ticks_float = radians * const . DEG_PER_RAD / const . DEG_PER_STEP / const . STEP_PER_TICK ticks_int = np . round ( ticks_float ). astype ( int ) ticks_to_go = np . round ( ticks_float - current_ticks ). astype ( int ) err = ( ticks_float - current_ticks ) - ticks_to_go logger . debug ( f 'Commanded encoder positions: {ticks_int}' ) logger . debug ( f 'Delta encoder positions: {ticks_to_go}' ) if any ( [ tick_int < 0 for tick_int in ticks_int ] ) : logger . warning ( f 'Move command past hard stop detected: {addresses} : {ticks_int}' ) # Set the velocity of each motor such that they arrive at the final # position at the same time . # The motor with the longest move moves at the maximum velocity . max_ticks = np . max ( np . abs ( ticks_to_go )) t_move = max ( max_ticks / const . MAX_SPEED_TICKS , 1e-9 ) vels = np . round ( np . abs ( ticks_to_go ) / t_move ). astype ( int ) logger . debug ( f 'Motor speeds: {vels} ticks / sec' ) for i in range ( len ( ticks_to_go )) : if ( ticks_to_go [ i ] and vels [ i ] ) : # Set velocity and command absolute encoder ticks wait_for_ready ( ser , addresses [ i ] ) resp = ezstepper_write ( ser , addresses [ i ] , ( f 'V{vels[i]}' + f 'A{ticks_int[i]}' + '\\r\\n' ) ) # Execute buffered move commands for all addresses if run : ezstepper_write ( ser , '_' , 'R\\r\\n' ) return ticks_to_go , err","title":"all_steppers_ez"},{"location":"reference/hotspot/hardware/#bump_hard_stop","text":"def bump_hard_stop ( ser : hotspot . hw_context . DummySerial , address : int , ticks : int , speed : int , hold_current = 50 , move_current = 50 ) Run the motor backward until it can't anymore. Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None address None ezstepper selector switch number to send command to None ticks None encoder ticks to move on each trial while searching for hard stop None speed None encoder ticks per second None hold_current (optional) None target current, % of 2 A limit for motor when stationary None move_current (optional) None target current, % of 2 A limit for motor when moving None Returns: Type Description prev_ticks The last encoder position before the hard stop was hit View Source def bump_hard_stop ( ser : StepperSerial , address : int , ticks : int , speed : int , hold_current = 50 , move_current = 50 ): ''' Run the motor backward until it can ' t anymore . Parameters ---------- ser pyserial instance , the port to send bytes over from address ezstepper selector switch number to send command to ticks encoder ticks to move on each trial while searching for hard stop speed encoder ticks per second hold_current ( optional ) target current , % of 2 A limit for motor when stationary move_current ( optional ) target current , % of 2 A limit for motor when moving Returns ------- prev_ticks The last encoder position before the hard stop was hit ''' max_tries = 10000 # may take several moves to hit a hard stop tries = 0 prev_ticks = 800000 # more ticks than we have total available cable curr_ticks = prev_ticks - 1 while (( curr_ticks < prev_ticks ) and ( tries < max_tries )): prev_ticks = curr_ticks wait_for_ready ( ser , address ) resp = ezstepper_write ( ser , address , ( f ' m { move_current } ' + f ' h { hold_current } ' + f ' V { speed } ' + f ' D { ticks } ' + ' R \\ r \\ n ' ) ) curr_ticks = get_encoder_pos ( ser , address ) tries += 1 return prev_ticks","title":"bump_hard_stop"},{"location":"reference/hotspot/hardware/#ezstepper_check_ready","text":"def ezstepper_check_ready ( resp ) The EZStepper is ready to accept a new command if the ready bit is set. Parameters: Name Type Description Default resp None bytes, EZStepper response, after throwing away garbage bytes None Returns: Type Description bool True if ready bit is set View Source def ezstepper_check_ready ( resp ) : ''' The EZStepper is ready to accept a new command if the ready bit is set. Parameters ---------- resp bytes, EZStepper response, after throwing away garbage bytes Returns ------- bool True if ready bit is set ''' return bool ( resp [ IDX_READY_BIT ] & 0 b00100000 )","title":"ezstepper_check_ready"},{"location":"reference/hotspot/hardware/#ezstepper_check_status","text":"def ezstepper_check_status ( resp ) Compare the status byte from the EZStepper to some common error codes. Parameters: Name Type Description Default resp None bytes, EZStepper response, after throwing away garbage bytes None Returns: Type Description status_good bool, True if response is nonempty and no unusual status byte patterns found View Source def ezstepper_check_status ( resp ) : ''' Compare the status byte from the EZStepper to some common error codes. Parameters ---------- resp bytes, EZStepper response, after throwing away garbage bytes Returns ------- status_good bool, True if response is nonempty and no unusual status byte patterns found ''' status_good = True if resp : # bits 0 - 3 form an error code : see EZStepper docs status = resp [ IDX_STATUS_BYTE ] & 0 b00001111 else : status = b '' status_good = False if 2 == status : logger . warning ( 'Bad command error (illegal command was sent)' ) status_good = False if 5 == status : logger . warning ( 'Communications Error (Internal communications error)' ) status_good = False if 9 == status : logger . warning ( 'Overload error (Physical system could not keep up with commanded position)' ) status_good = False if 11 == status : logger . warning ( 'Move not allowed' ) status_good = False if 15 == status : logger . warning ( 'Command overflow (unit was already executing a command when another command was received)' ) status_good = False if status not in [ b'', 0, 2, 9, 11, 15 ] : logger . warning ( f 'Unrecognized error code {status}. Consult EZStepper documentation.' ) return status_good","title":"ezstepper_check_status"},{"location":"reference/hotspot/hardware/#ezstepper_write","text":"def ezstepper_write ( ser : hotspot . hw_context . DummySerial , address , command_str : str ) Builds a serial command to send to EZStepper(s), checks status bytes in response, and returns response bytes. Parameters ---------- ser pyserial instance, the port to send bytes over from address str, address of ezstepper command_str string, chars to send over EZStepper bus Returns ------- resp bytes, serial response from EZStepper Example: ``` ezstepper.write(ser, 1, 'A1000R ') ezstepper.write(ser, ' ', 'A12000 ') ezstepper.write(ser, ' ', 'R ') ``` View Source def ezstepper_write ( ser : StepperSerial , address , command_str : str ): ''' Builds a serial command to send to EZStepper ( s ), checks status bytes in response , and returns response bytes . Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper command_str string , chars to send over EZStepper bus Returns ------- resp bytes , serial response from EZStepper Example : ``` ezstepper . write ( ser , 1 , ' A1000R \\ r \\ n ' ) ezstepper . write ( ser , '_' , ' A12000 \\ r \\ n ' ) ezstepper . write ( ser , '_' , ' R \\ r \\ n ' ) ``` ''' ser . write (( f ' / { address } ' + command_str ). encode ()) logger . debug ( ' EZStepper cmd : {} ' . format (( f ' / { address } ' + command_str ). rstrip ( '\\ r \\ n ' ))) # we do not anticipate a response from \"all call\" commands . if '_' == address : resp = b '' else : resp = look_for_response ( ser . readline ()) status_good = ezstepper_check_status ( resp ) logger . debug ( ' EZStepper response : {} ' . format ( resp . rstrip ( b '\\ r \\ n ' ))) return resp","title":"ezstepper_write"},{"location":"reference/hotspot/hardware/#get_encoder_pos","text":"def get_encoder_pos ( ser : hotspot . hw_context . DummySerial , address ) Gets EZStepper's encoder counts in terms of ticks. It is critical for accurate operation that this call succeeds, so the program will exit if it fails. Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None address None str, address of ezstepper None Returns: Type Description ticks Number of encoder ticks counted by encoder. A 10000 line encoder has 4 * 10000 = 40000 lines per revolution. View Source def get_encoder_pos ( ser : StepperSerial , address ) : ''' Gets EZStepper's encoder counts in terms of ticks . It is critical for accurate operation that this call succeeds , so the program will exit if it fails . Parameters ---------- ser pyserial instance , the port to send bytes over from address str , address of ezstepper Returns ------- ticks Number of encoder ticks counted by encoder . A 10000 line encoder has 4 * 10000 = 40000 lines per revolution . ''' ticks = 0 resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries = 10 while not resp and retries > 0: resp = ezstepper_write(ser, address, ' ? 8 R \\r\\n') retries -= 1 logger.warning(f' Encoder { address } was slow to respond . Retrying , { retries } remaining . ') retries = 10 while not ezstepper_check_status(resp) and retries > 0: retries -= 1 logger.warning(f' Encoder { address } status was bad : { resp }. Retrying , { retries } remaining . ') if retries < 0: logger.critical(f' Encoder { address } status bad : { resp }. Is EZStepper / encoder connected ? ') sys.exit(1) else: payload = resp[IDX_STATUS_BYTE+1:-NUM_TRAILING_BYTES] logger.debug(f' Encoder reading : { payload } ') if payload: ticks = int(payload.decode('utf - 8 ')) else: logger.critical(f' Encoder { address } didn\\'t respond.' ) sys . exit ( 1 ) return ticks","title":"get_encoder_pos"},{"location":"reference/hotspot/hardware/#look_for_response","text":"def look_for_response ( resp ) Responses addressed to the controller node begin with /0, with possible junk before. Parameters: Name Type Description Default resp None bytes, EZStepper response, straight out of serial None Returns: Type Description resp Any bytes after /0 View Source def look_for_response ( resp ): ''' Responses addressed to the controller node begin with / 0 , with possible junk before . Parameters ---------- resp bytes , EZStepper response , straight out of serial Returns ------- resp Any bytes after / 0 ''' if ( b ' / 0 ' in resp ) and ( b '\\ x03 ' in resp ): resp = resp [ resp . find ( b ' / 0 ' ):] else : resp = b '' return resp","title":"look_for_response"},{"location":"reference/hotspot/hardware/#send_hawkeye_byte","text":"def send_hawkeye_byte ( ser : hotspot . hw_context . DummySerial , data : int ) Control three groups of Hawkeye IR sources on the raft. Each of the first three bits of the data byte turns on one of the three available groups of Hawkeyes on the raft: center, inner ring, and outer ring. The byte is sent over serial to a microcontroller, which forwards the byte to a shift register on the raft via SPI. For example: - data = 1 -> 001 -> center Hawkeye only - data = 2 -> 010 -> inner ring only - data = 3 -> 011 -> center and inner - data = 7 -> 111 -> center, inner, outer Parameters: Name Type Description Default ser None pyserial instance, the port to send byte over from None data (int) None integer whose binary representation will appear at the shift register outputs on the raft None View Source def send_hawkeye_byte ( ser : HawkeyeSerial , data : int ) : ' '' Control three groups of Hawkeye IR sources on the raft. Each of the first three bits of the `data` byte turns on one of the three available groups of Hawkeyes on the raft: center, inner ring, and outer ring. The byte is sent over serial to a microcontroller, which forwards the byte to a shift register on the raft via SPI. For example: - data = 1 -> 001 -> center Hawkeye only - data = 2 -> 010 -> inner ring only - data = 3 -> 011 -> center and inner - data = 7 -> 111 -> center, inner, outer Parameters ---------- ser pyserial instance, the port to send byte over from data (int) integer whose binary representation will appear at the shift register outputs on the raft '' ' assert isinstance ( data , int ) if data > 255 : data = 255 if data < 0 : data = 0 ser . write ( f '{data} \\r\\n ' . encode ()) return","title":"send_hawkeye_byte"},{"location":"reference/hotspot/hardware/#wait_for_ready","text":"def wait_for_ready ( ser , address , ready_timeout = 10.0 ) Parameters: Name Type Description Default ser None pyserial instance, the port to send bytes over from None address None str, address of ezstepper None ready_timeout (optional) None float, time in seconds before deciding the stepper is unresponsive None View Source def wait_for_ready ( ser , address , ready_timeout = 10.0 ): ''' Parameters ---------- ser pyserial instance, the port to send bytes over from address str, address of ezstepper ready_timeout (optional) float, time in seconds before deciding the stepper is unresponsive ''' resp = b '' ready = False if '_' != address : # only send a new command if ezstepper not busy start_busywait = time . time () query = ( f '/{address}Q \\r\\n ' ) . encode () while not ready and ( time . time () - start_busywait ) < ready_timeout : ser . write ( query ) line = ser . readline () if line : resp = look_for_response ( line ) logger . debug ( f 'Ready response: {resp}' ) if resp : ready = ezstepper_check_ready ( resp ) status_good = ezstepper_check_status ( resp ) logger . debug ( f 'Waited {time.time() - start_busywait:.4f} sec for ready signal' ) if not ready : logger . warning ( f 'EZStepper {address} was not ready in allotted time {ready_timeout} sec' ) return","title":"wait_for_ready"},{"location":"reference/hotspot/hardware/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/hardware/#commandbuffer","text":"class CommandBuffer ( addresses ) Handles building a string of commands to send over serial. Continuous movement requires a sequence of carefully orchestrated absolute angle and velocity commands. In order to avoid serial transfer/ ready waiting overhead, it's most efficient to send a long sequence to each stepper controller, and then run them all together. All methods deal in strings, not byte objects. View Source class CommandBuffer : ''' Handles building a string of commands to send over serial. Continuous movement requires a sequence of carefully orchestrated absolute angle and velocity commands. In order to avoid serial transfer/ ready waiting overhead, it' s most efficient to send a long sequence to each stepper controller , and then run them all together . All methods deal in strings , not byte objects . ''' def __init__(self, addresses): ''' Addresses are EZStepper bus addresses , e . g . [ 2,1,3,4 ] ''' self.buffer_map = {address : '' for address in addresses} def put(self, address, command_str): self.buffer_map[address] += command_str logger.debug(f' CommandBuffer : put () { address }: { command_str } -> { self . buffer_map [ address ] } ') def empty(self, address): ''' Use after sending ''' self.buffer_map[address] = '' def terminate(self, address): ''' Use before sending ''' self.buffer_map[address] += ' \\ r \\ n ' def get ( self , address ) : return self . buffer_map [ address ]","title":"CommandBuffer"},{"location":"reference/hotspot/hardware/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/hardware/#empty","text":"def empty ( self , address ) Use after sending View Source def empty ( self , address ) : '''Use after sending''' self . buffer_map [ address ] = ''","title":"empty"},{"location":"reference/hotspot/hardware/#get","text":"def get ( self , address ) View Source def get ( self , address ) : return self . buffer_map [ address ]","title":"get"},{"location":"reference/hotspot/hardware/#put","text":"def put ( self , address , command_str ) View Source def put ( self , address , command_str ) : self . buffer_map [ address ] += command_str logger . debug ( f 'CommandBuffer:put() {address}: {command_str} -> {self.buffer_map[address]}' )","title":"put"},{"location":"reference/hotspot/hardware/#terminate","text":"def terminate ( self , address ) Use before sending View Source def terminate ( self , address ) : '''Use before sending''' self . buffer_map [ address ] += '\\r\\n'","title":"terminate"},{"location":"reference/hotspot/hw_context/","text":"Module hotspot.hw_context View Source # This file abstracts the hardware module imports away and provides contingency # modules so dev and testing can be done on a machine without hardware # attached. import serial import hotspot.constants as const class DummySerial : def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b '' def close ( self ): pass try : stepper_serial_instance = serial . Serial ( const . STEPPER_SERIAL_PORT , const . SERIAL_BAUD , timeout = const . SERIAL_TIMEOUT ) StepperSerial = serial . Serial except serial . serialutil . SerialException as err : print ( err ) print ( f 'Open constants.py and try another STEPPER_SERIAL_PORT, or connect' + ' a device to the serial port.' ) print ( 'This program cannot continue without steppers connected.' ) stepper_serial_instance = DummySerial () StepperSerial = DummySerial try : hawkeye_serial_instance = serial . Serial ( const . HAWKEYE_SERIAL_PORT , const . SERIAL_BAUD , timeout = const . SERIAL_TIMEOUT ) HawkeyeSerial = serial . Serial except serial . serialutil . SerialException as err : print ( err ) print ( f 'Open constants.py and try another HAWKEYE_SERIAL_PORT, or connect' + ' a device to the serial port.' ) print ( 'Continuing with dummy serial port.' ) hawkeye_serial_instance = DummySerial () HawkeyeSerial = DummySerial Variables hawkeye_serial_instance stepper_serial_instance Classes DummySerial class DummySerial ( * args , ** kwargs ) View Source class DummySerial: def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b'' def close ( self ): pass Methods close def close ( self ) View Source def close(self): pass readline def readline ( self ) View Source def readline ( self ) : return b '' write def write ( self , bytes ) View Source def write(self, bytes): pass HawkeyeSerial class HawkeyeSerial ( * args , ** kwargs ) View Source class DummySerial: def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b'' def close ( self ): pass Methods close def close ( self ) View Source def close(self): pass readline def readline ( self ) View Source def readline ( self ) : return b '' write def write ( self , bytes ) View Source def write(self, bytes): pass StepperSerial class StepperSerial ( * args , ** kwargs ) View Source class DummySerial: def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b'' def close ( self ): pass Methods close def close ( self ) View Source def close(self): pass readline def readline ( self ) View Source def readline ( self ) : return b '' write def write ( self , bytes ) View Source def write(self, bytes): pass","title":"Hw Context"},{"location":"reference/hotspot/hw_context/#module-hotspothw_context","text":"View Source # This file abstracts the hardware module imports away and provides contingency # modules so dev and testing can be done on a machine without hardware # attached. import serial import hotspot.constants as const class DummySerial : def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b '' def close ( self ): pass try : stepper_serial_instance = serial . Serial ( const . STEPPER_SERIAL_PORT , const . SERIAL_BAUD , timeout = const . SERIAL_TIMEOUT ) StepperSerial = serial . Serial except serial . serialutil . SerialException as err : print ( err ) print ( f 'Open constants.py and try another STEPPER_SERIAL_PORT, or connect' + ' a device to the serial port.' ) print ( 'This program cannot continue without steppers connected.' ) stepper_serial_instance = DummySerial () StepperSerial = DummySerial try : hawkeye_serial_instance = serial . Serial ( const . HAWKEYE_SERIAL_PORT , const . SERIAL_BAUD , timeout = const . SERIAL_TIMEOUT ) HawkeyeSerial = serial . Serial except serial . serialutil . SerialException as err : print ( err ) print ( f 'Open constants.py and try another HAWKEYE_SERIAL_PORT, or connect' + ' a device to the serial port.' ) print ( 'Continuing with dummy serial port.' ) hawkeye_serial_instance = DummySerial () HawkeyeSerial = DummySerial","title":"Module hotspot.hw_context"},{"location":"reference/hotspot/hw_context/#variables","text":"hawkeye_serial_instance stepper_serial_instance","title":"Variables"},{"location":"reference/hotspot/hw_context/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/hw_context/#dummyserial","text":"class DummySerial ( * args , ** kwargs ) View Source class DummySerial: def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b'' def close ( self ): pass","title":"DummySerial"},{"location":"reference/hotspot/hw_context/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/hw_context/#close","text":"def close ( self ) View Source def close(self): pass","title":"close"},{"location":"reference/hotspot/hw_context/#readline","text":"def readline ( self ) View Source def readline ( self ) : return b ''","title":"readline"},{"location":"reference/hotspot/hw_context/#write","text":"def write ( self , bytes ) View Source def write(self, bytes): pass","title":"write"},{"location":"reference/hotspot/hw_context/#hawkeyeserial","text":"class HawkeyeSerial ( * args , ** kwargs ) View Source class DummySerial: def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b'' def close ( self ): pass","title":"HawkeyeSerial"},{"location":"reference/hotspot/hw_context/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/hw_context/#close_1","text":"def close ( self ) View Source def close(self): pass","title":"close"},{"location":"reference/hotspot/hw_context/#readline_1","text":"def readline ( self ) View Source def readline ( self ) : return b ''","title":"readline"},{"location":"reference/hotspot/hw_context/#write_1","text":"def write ( self , bytes ) View Source def write(self, bytes): pass","title":"write"},{"location":"reference/hotspot/hw_context/#stepperserial","text":"class StepperSerial ( * args , ** kwargs ) View Source class DummySerial: def __init__ ( self , * args , ** kwargs ): pass def write ( self , bytes ): pass def readline ( self ): return b'' def close ( self ): pass","title":"StepperSerial"},{"location":"reference/hotspot/hw_context/#methods_2","text":"","title":"Methods"},{"location":"reference/hotspot/hw_context/#close_2","text":"def close ( self ) View Source def close(self): pass","title":"close"},{"location":"reference/hotspot/hw_context/#readline_2","text":"def readline ( self ) View Source def readline ( self ) : return b ''","title":"readline"},{"location":"reference/hotspot/hw_context/#write_2","text":"def write ( self , bytes ) View Source def write(self, bytes): pass","title":"write"},{"location":"reference/hotspot/telemetry/","text":"Module hotspot.telemetry View Source # This file defines functions for outputting telemetry (TM) and visualization. import logging import matplotlib.pyplot as plt import multiprocessing as mp import numpy as np import os import time import h5py import hotspot.constants as const logger = logging . getLogger ( __name__ ) class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ): logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle [ source ] . keys () if 'local time' not in key . lower ()] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: { source } ' ) self . fig = fig self . var_axes = { key : axes . flatten ()[ i ] for i , key in enumerate ( keys )} plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ): ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = np . atleast_1d ( file_handle [ self . source ][ 'Local Time (s)' ]) data = np . atleast_1d ( file_handle [ self . source ][ varname ]) dim = len ( data . shape ) if dim < 2 : # 1D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower (): if first_time : ax . plot ( data [:, 0 ], data [:, 1 ], color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [:, 0 ], data [:, 1 ]) else : # line plot for timeseries if first_time : ax . plot ( time [:], data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ]): ax . lines [ j ] . set_data ( time [:], data [:, j ]) else : logger . warn ( f '[ { varname } ] Plotting data of shape { data . shape } not implemented.' ) ax . relim () ax . autoscale () fig . tight_layout () fig . canvas . draw () plt . pause ( 1e-9 ) return class DataRouter : def __init__ ( self , tm_queue : mp . Queue ): logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m %d -%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} return def process_packet ( self , packet : dict ): ''' Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Local Time (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Local Time (s)'. Values can be 1- or 2-D. ''' # Otherwise, create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys (): # Get a group, making it if it doesn't exist if source not in f . keys (): f . create_group ( source ) group = f [ source ] for var in packet [ source ] . keys (): data = packet [ source ][ var ] # Get a dataset, making it if it doesn't exist if var in group . keys (): dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1 :])) dset [ - 1 ] = data else : data = np . array ([ packet [ source ][ var ]]) maxshape = ( None , * data . shape [ 1 :]) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ): ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty (): self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () return def run_gui_event_loop ( self ): plt . pause ( 1 ) return def update_display ( self ): ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys (): first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys (): self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys (): if 'local time' in var . lower (): continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Variables logger Classes DataRouter class DataRouter ( tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f0182295c90 >> ) View Source class DataRouter : def __init__ ( self , tm_queue : mp . Queue ) : logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m%d-%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} return def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Local Time ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Local Time ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () return def run_gui_event_loop ( self ) : plt . pause ( 1 ) return def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'local time' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Methods process_packet def process_packet ( self , packet : dict ) Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Local Time (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Local Time (s)'. Values can be 1- or 2-D. View Source def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Local Time ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Local Time ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return process_tm def process_tm ( self , plot_enable = False ) Function to continuously log TM to file and update plots as TM comes in. View Source def process_tm ( self , plot_enable = False ) : '' ' Function to continuously log TM to file and update plots as TM comes in. '' ' while not self.tm_queue.empty(): self.process_packet(self.tm_queue.get()) if plot_enable: self.update_display() return run_gui_event_loop def run_gui_event_loop ( self ) View Source def run_gui_event_loop ( self ) : plt . pause ( 1 ) return update_display def update_display ( self ) Function to update plotters. View Source def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'local time' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return Visualizer class Visualizer ( file_handle : h5py . _hl . files . File , source : str ) Keeps track of plotting objects to enable updating plots for a given source View Source class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ) : logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle[source ] . keys () if 'local time' not in key . lower () ] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: {source}' ) self . fig = fig self . var_axes = { key : axes . flatten () [ i ] for i , key in enumerate ( keys ) } plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = np . atleast_1d ( file_handle [ self.source ][ 'Local Time (s)' ] ) data = np . atleast_1d ( file_handle [ self.source ][ varname ] ) dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . tight_layout () fig . canvas . draw () plt . pause ( 1e-9 ) return Methods update_subplot def update_subplot ( self , file_handle : h5py . _hl . files . File , varname : str , first_time : bool ) View Source def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = np . atleast_1d ( file_handle [ self.source ][ 'Local Time (s)' ] ) data = np . atleast_1d ( file_handle [ self.source ][ varname ] ) dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . tight_layout () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"Telemetry"},{"location":"reference/hotspot/telemetry/#module-hotspottelemetry","text":"View Source # This file defines functions for outputting telemetry (TM) and visualization. import logging import matplotlib.pyplot as plt import multiprocessing as mp import numpy as np import os import time import h5py import hotspot.constants as const logger = logging . getLogger ( __name__ ) class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ): logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle [ source ] . keys () if 'local time' not in key . lower ()] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: { source } ' ) self . fig = fig self . var_axes = { key : axes . flatten ()[ i ] for i , key in enumerate ( keys )} plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ): ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = np . atleast_1d ( file_handle [ self . source ][ 'Local Time (s)' ]) data = np . atleast_1d ( file_handle [ self . source ][ varname ]) dim = len ( data . shape ) if dim < 2 : # 1D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower (): if first_time : ax . plot ( data [:, 0 ], data [:, 1 ], color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [:, 0 ], data [:, 1 ]) else : # line plot for timeseries if first_time : ax . plot ( time [:], data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ]): ax . lines [ j ] . set_data ( time [:], data [:, j ]) else : logger . warn ( f '[ { varname } ] Plotting data of shape { data . shape } not implemented.' ) ax . relim () ax . autoscale () fig . tight_layout () fig . canvas . draw () plt . pause ( 1e-9 ) return class DataRouter : def __init__ ( self , tm_queue : mp . Queue ): logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m %d -%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} return def process_packet ( self , packet : dict ): ''' Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Local Time (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Local Time (s)'. Values can be 1- or 2-D. ''' # Otherwise, create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys (): # Get a group, making it if it doesn't exist if source not in f . keys (): f . create_group ( source ) group = f [ source ] for var in packet [ source ] . keys (): data = packet [ source ][ var ] # Get a dataset, making it if it doesn't exist if var in group . keys (): dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1 :])) dset [ - 1 ] = data else : data = np . array ([ packet [ source ][ var ]]) maxshape = ( None , * data . shape [ 1 :]) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ): ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty (): self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () return def run_gui_event_loop ( self ): plt . pause ( 1 ) return def update_display ( self ): ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys (): first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys (): self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys (): if 'local time' in var . lower (): continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"Module hotspot.telemetry"},{"location":"reference/hotspot/telemetry/#variables","text":"logger","title":"Variables"},{"location":"reference/hotspot/telemetry/#classes","text":"","title":"Classes"},{"location":"reference/hotspot/telemetry/#datarouter","text":"class DataRouter ( tm_queue : < bound method BaseContext . Queue of < multiprocessing . context . DefaultContext object at 0x7f0182295c90 >> ) View Source class DataRouter : def __init__ ( self , tm_queue : mp . Queue ) : logger . debug ( 'DataRouter init' ) # map output data to the correct file self . output_dir = os . path . join ( const . TOPLEVEL_DIR , 'data' , 'output' ) self . time_str = time . strftime ( '_%Y%m%d-%H%M%S' ) self . fname = os . path . join ( self . output_dir , 'hotspot' + self . time_str + '.hdf5' ) self . tm_queue = tm_queue self . visualizers = {} return def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Local Time ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Local Time ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return def process_tm ( self , plot_enable = False ) : ''' Function to continuously log TM to file and update plots as TM comes in. ''' while not self . tm_queue . empty () : self . process_packet ( self . tm_queue . get ()) if plot_enable : self . update_display () return def run_gui_event_loop ( self ) : plt . pause ( 1 ) return def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'local time' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"DataRouter"},{"location":"reference/hotspot/telemetry/#methods","text":"","title":"Methods"},{"location":"reference/hotspot/telemetry/#process_packet","text":"def process_packet ( self , packet : dict ) Route a TM packet to the hdf5 group. Packet format: { 'source' : 'Local Time (s)' : value (all packets should have this key) 'variable0' : value, 'variable1' : value } Times are referenced to UNIX epoch UTC. All packets should have the key 'Local Time (s)'. Values can be 1- or 2-D. View Source def process_packet ( self , packet : dict ) : ''' Route a TM packet to the hdf5 group. Packet format: { ' source ' : ' Local Time ( s ) ' : value (all packets should have this key) ' variable0 ' : value, ' variable1 ' : value } Times are referenced to UNIX epoch UTC. All packets should have the key ' Local Time ( s ) '. Values can be 1- or 2-D. ''' # Otherwise , create or add to output file on disk with h5py . File ( self . fname , 'a' ) as f : for source in packet . keys () : # Get a group , making it if it doesn 't exist if source not in f.keys(): f.create_group(source) group = f[source] for var in packet[source].keys(): data = packet[source][var] # Get a dataset, making it if it doesn' t exist if var in group . keys () : dset = group [ var ] # extend row axis by one dset . resize (( dset . shape [ 0 ] + 1 , * dset . shape [ 1: ] )) dset [ -1 ] = data else : data = np . array ( [ packet[source ][ var ] ] ) maxshape = ( None , * data . shape [ 1: ] ) group . create_dataset ( var , maxshape = maxshape , data = data , chunks = True ) # Need chunked to enable resizing return","title":"process_packet"},{"location":"reference/hotspot/telemetry/#process_tm","text":"def process_tm ( self , plot_enable = False ) Function to continuously log TM to file and update plots as TM comes in. View Source def process_tm ( self , plot_enable = False ) : '' ' Function to continuously log TM to file and update plots as TM comes in. '' ' while not self.tm_queue.empty(): self.process_packet(self.tm_queue.get()) if plot_enable: self.update_display() return","title":"process_tm"},{"location":"reference/hotspot/telemetry/#run_gui_event_loop","text":"def run_gui_event_loop ( self ) View Source def run_gui_event_loop ( self ) : plt . pause ( 1 ) return","title":"run_gui_event_loop"},{"location":"reference/hotspot/telemetry/#update_display","text":"def update_display ( self ) Function to update plotters. View Source def update_display ( self ) : ''' Function to update plotters. ''' with h5py . File ( self . fname ) as f : for source in f . keys () : first_time = False # Make a new visualizer if needed if source not in self . visualizers . keys () : self . visualizers [ source ] = Visualizer ( f , source ) first_time = True for var in f [ source ] . keys () : if 'local time' in var . lower () : continue self . visualizers [ source ] . update_subplot ( f , var , first_time ) return","title":"update_display"},{"location":"reference/hotspot/telemetry/#visualizer","text":"class Visualizer ( file_handle : h5py . _hl . files . File , source : str ) Keeps track of plotting objects to enable updating plots for a given source View Source class Visualizer : ''' Keeps track of plotting objects to enable updating plots for a given source ''' def __init__ ( self , file_handle : h5py . File , source : str ) : logger . debug ( 'Visualiser init' ) self . file_handle = file_handle self . source = source keys = [ key for key in file_handle[source ] . keys () if 'local time' not in key . lower () ] fig , axes = plt . subplots ( nrows = len ( keys ), squeeze = False ) fig . suptitle ( f 'Packet: {source}' ) self . fig = fig self . var_axes = { key : axes . flatten () [ i ] for i , key in enumerate ( keys ) } plt . ion () plt . show () def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = np . atleast_1d ( file_handle [ self.source ][ 'Local Time (s)' ] ) data = np . atleast_1d ( file_handle [ self.source ][ varname ] ) dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . tight_layout () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"Visualizer"},{"location":"reference/hotspot/telemetry/#methods_1","text":"","title":"Methods"},{"location":"reference/hotspot/telemetry/#update_subplot","text":"def update_subplot ( self , file_handle : h5py . _hl . files . File , varname : str , first_time : bool ) View Source def update_subplot ( self , file_handle : h5py . File , varname : str , first_time : bool ) : ax = self . var_axes [ varname ] fig = ax . get_figure () if first_time : ax . set_title ( varname ) ax . grid ( True ) time = np . atleast_1d ( file_handle [ self.source ][ 'Local Time (s)' ] ) data = np . atleast_1d ( file_handle [ self.source ][ varname ] ) dim = len ( data . shape ) if dim < 2 : # 1 D data if first_time : ax . plot ( time , data ) else : l = ax . lines [ 0 ] l . set_data ( time , data ) elif dim < 3 : # scatter plot for positions if 'position' in varname . lower () : if first_time : ax . plot ( data [ :,0 ] , data [ :,1 ] , color = 'k' , marker = 'o' , linestyle = 'None' ) else : l = ax . lines [ 0 ] l . set_data ( data [ :,0 ] , data [ :,1 ] ) else : # line plot for timeseries if first_time : ax . plot ( time [ : ] , data , marker = 'o' , alpha = 0.3 ) else : for j in range ( data . shape [ 1 ] ) : ax . lines [ j ] . set_data ( time [ : ] , data [ :,j ] ) else : logger . warn ( f '[{varname}] Plotting data of shape {data.shape} not implemented.' ) ax . relim () ax . autoscale () fig . tight_layout () fig . canvas . draw () plt . pause ( 1e-9 ) return","title":"update_subplot"}]}